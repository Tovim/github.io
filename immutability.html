<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title> - Beginning Elm</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/main.css">
<!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">    deformuje zobrazení font awsome -->
</head>

<body>

<section class="heading">
<h1> 4.2 </h1>
<h2>Neměnitelnost</h2>
</section>

<div class="page-content">
<div class="container">

<div class="breadcrumb-holder">
<header id="breadcrumb" class="breadcrumb">
<a href="aa-index.html" class="breadcrumb-toggle">
  <span></span>
  <span></span>
  <span></span>
</a>

<span class="breadcrumb-section">syntaxe</span>

<a class="breadcrumb-next" href="pure-functions.html">
<i class="fa fa-angle-right"></i><span>Next article</span>
</a>
<a class="breadcrumb-previous" href="benefits-intro.html">
<i class="fa fa-angle-left"></i><span>Previous article</span>
</a>
          
</header>
</div>

<article class="content">
<p>V sekci <a href="value.html" target="_blank">Value</a> jsme si řekli, že hodnota v Elmu je cokoliv, co může být vytvořeno jako výsledek výpočtu. Také jsme si řekli, že hodnoty Elmu jsou neměnitelné, což znamená že je nelze po vytvoření změnit. Opět, Elm si opět tento koncept vypůjčil z matematiky. Na příklad, číslo <code class="highlighter-rouge">3</code> v matematice je hodnota, kterou nelze změnit. Zajisté, můžeme k němu přičíst či od něj odečíst jiná čísla ale číslo <code class="highlighter-rouge">3</code> samotné se nikdy nezmění. Přičteme-li <code class="highlighter-rouge">1</code> ke <code class="highlighter-rouge">3</code>, dostaneme <code class="highlighter-rouge">4</code> - úplně nové číslo. To je přesně totéž, k čemu dojde, když se pokusíme změnit hodnotu (třeba seznam) v Elmu.</p>

<h3 id="immutable-constants">Neměnitelné konstanty</h3>

<p>Všechny konstanty v Elmu jsou neměnitelné. Jednou přiřazená hodnota nemůže být změněna na jinou hodnotu (ve stejném lexikálním prostoru, zvaném scope). Přicházíte-li z <a href="https://en.wikipedia.org/wiki/Imperative_programming" target="_blank">imperativního jazyka</a>, může to být pro vás matoucí. V oněch jazycích je obvyklé psát kód takto:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Proměnné <code class="highlighter-rouge">x</code> přiřazujeme hodnotu <code class="highlighter-rouge">1</code>. Potom téže proměnné přiřazujeme součet původní hodnoty <code class="highlighter-rouge">x</code> a čísla <code class="highlighter-rouge">1</code>, čímž měníme hodnotu <code class="highlighter-rouge">x</code>. Zkusme si totéž v Elmu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">1</span>

<span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1">-------------------------- BAD RECURSION -----------------------------</span>
<span class="p">`</span><span class="n">x</span><span class="p">`</span> <span class="n">is</span> <span class="n">defined</span> <span class="n">directly</span> <span class="kr">in</span> <span class="n">terms</span> <span class="kr">of</span> <span class="n">itself</span><span class="p">,</span> <span class="n">causing</span> <span class="n">an</span> <span class="n">infinite</span> <span class="n">loop</span><span class="o">.</span>

<span class="mi">5</span><span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="o">^</span>
<span class="kt">Maybe</span> <span class="n">you</span> <span class="n">are</span> <span class="n">trying</span> <span class="n">to</span> <span class="n">mutate</span> <span class="n">a</span> <span class="n">variable</span><span class="o">?</span> <span class="kt">Elm</span> <span class="n">does</span> <span class="n">not</span> <span class="n">have</span> <span class="n">mutation</span><span class="p">,</span>
<span class="n">so</span> <span class="n">when</span> <span class="kt">I</span> <span class="n">see</span> <span class="p">`</span><span class="n">x</span><span class="p">`</span> <span class="n">defined</span> <span class="kr">in</span> <span class="n">terms</span> <span class="kr">of</span> <span class="p">`</span><span class="n">x</span><span class="p">`,</span> <span class="kt">I</span> <span class="n">treat</span> <span class="n">it</span> <span class="n">as</span> <span class="n">a</span> <span class="n">recursive</span>
<span class="n">definition</span><span class="o">.</span> <span class="kt">Try</span> <span class="n">giving</span> <span class="n">the</span> <span class="n">new</span> <span class="n">value</span> <span class="n">a</span> <span class="n">new</span> <span class="n">name</span><span class="o">!</span>

<span class="kt">Maybe</span> <span class="n">you</span> <span class="kt">DO</span> <span class="n">want</span> <span class="n">a</span> <span class="n">recursive</span> <span class="n">value</span><span class="o">?</span> <span class="kt">To</span> <span class="n">define</span> <span class="p">`</span><span class="n">x</span><span class="p">`</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">know</span> <span class="n">what</span>
<span class="p">`</span><span class="n">x</span><span class="p">`</span> <span class="n">is</span><span class="p">,</span> <span class="n">so</span> <span class="kr">let</span><span class="err">’</span><span class="n">s</span> <span class="n">expand</span> <span class="n">it</span><span class="o">.</span> <span class="kt">Wait</span><span class="p">,</span> <span class="n">but</span> <span class="n">now</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">know</span> <span class="n">what</span> <span class="p">`</span><span class="n">x</span><span class="p">`</span> <span class="n">is</span><span class="p">,</span>
<span class="n">so</span> <span class="kr">let</span><span class="err">’</span><span class="n">s</span> <span class="n">expand</span> <span class="n">it</span><span class="o">...</span> <span class="kt">This</span> <span class="n">will</span> <span class="n">keep</span> <span class="n">going</span> <span class="n">infinitely</span><span class="o">!</span></code></pre></figure>

<p>Jako obvykle, Elm poskytuje popisné chybové hlášení s poukazem na to, že neumožňuje mutaci hodnot. Definice jako <code class="highlighter-rouge">x = x + 1</code> jsou nepřípustné jak v algebře, tak v Elmu, protože jsme již definovali <code class="highlighter-rouge">x</code> jako <code class="highlighter-rouge">1</code> a nyní říkáme, že  <code class="highlighter-rouge">x</code> je <code class="highlighter-rouge">2</code>. Obojí nemůže současně být pravda.</p>

<p>Věnujeme-li pozornost chybové zprávě, Elm se nám vlastně zkouší sdělit, proč v tomto případě nemůže připustit mutaci. Když se pokoušíme vyhodnoti výraz jako <code class="highlighter-rouge">x = x + 1</code>, vpodstatě žádáme Elm aby vytvořil konstantu jménem <code class="highlighter-rouge">x</code>, která je definována sama sebou, vytvářejíc tak nekonečnou smyčku. Tato smyčka může mít toto rozvedení:</p>

<dl>
  <dt>Recursive definition</dt>
  <dd><code class="highlighter-rouge">x = x + 1</code><br />
<code class="highlighter-rouge">x = (x + 1) + 1</code><br />
<code class="highlighter-rouge">x = ((x + 1) + 1) + 1</code><br />
<code class="highlighter-rouge">x = (((x + 1) + 1) + 1) + 1</code><br />
<code class="highlighter-rouge">x = ((((x + 1) + 1) + 1) + 1) + 1</code><br />
<code class="highlighter-rouge">...</code></dd>
</dl>

<p>Elm nám také říká, že můžeme zápis opravit přiřazením výrazu <code class="highlighter-rouge">x + 1</code> k novému jménu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">1</span>

<span class="o">&gt;</span> <span class="n">xPlusOne</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span></code></pre></figure>

<p>V imperativním jazyce je <code class="highlighter-rouge">x</code> příhodně označováno jako <em>proměnná</em> (variable), protože se její hodnota může měnit i po její deklaraci. Naproti tomu v Elmu je<code class="highlighter-rouge">x</code> konstantou. Protože Elm nepřipouští mutace, nemá tento jazyk žádné proměnné. Znamená to, že nemůžeme použít totéž jméno pro prezentaci jiné hodnoty někde jinde v kódu? Ne tak docela. Konstantě stejného jména nelze přiřadit jinou hodnotu pouze ve stejné lexikální části kódu, zvané <em>scope</em>.</p>

<dl>
<dt>Scope</dt>
<dd>Scope je oblast programu, ve které definované konstanty existují a jsou dostupné. Konstaty vytvořené v této oblasti nejsou přístupné z místa mimo oblast. Jakmile provádění programu opustí tuto oblast, jsou všechny její konstanty a hodnoty zničeny.</dd>
</dl>

<p>Konstanty jako <code class="highlighter-rouge">x</code> jsou lokální ve své oblasti, takže jejich životnost je obvykle krátká. Když jejich oblast již není aktuální, jsou zničeny. Jméno konstanty lze použít pro prezentaci jiné hodnoty. Definice funkce, zobrazená níže, je dobrou ukázkou konstanty v omezené oblasti (scope).<br>
Zkopírujte si ji hned nad <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">multiplyByFive</span> <span class="n">number</span> <span class="o">=</span>
    <span class="kr">let</span>
        <span class="n">multiplier</span> <span class="o">=</span>
            <span class="mi">5</span>
    <span class="kr">in</span>
        <span class="n">number</span> <span class="o">*</span> <span class="n">multiplier</span>


<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Nyní aplikujte funkci <code class="highlighter-rouge">multiplyByFive</code> v <code class="highlighter-rouge">main</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">main</span> <span class="o">=</span>
    <span class="n">multiplyByFive</span> <span class="mi">3</span>
        <span class="o">|&gt;</span> <span class="n">toString</span>
        <span class="o">|&gt;</span> <span class="kt">Html</span><span class="o">.</span><span class="n">text</span></code></pre></figure>

<p>Nemáte-li <code class="highlighter-rouge">elm-reactor</code> již spuštěný, spusťte jej z adresáře <code class="highlighter-rouge">beginning-elm</code> v terminálu. Poté ve svém prohlížeči přejděte na stránku <a href="http://localhost:8000/elm-examples/Playground.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/Playground.elm</code></a> a mělo by se na obrazovce objevit číslo <code class="highlighter-rouge">15</code>.</p>

<p>Jak jsme se dozvěděli v sekci <a href="let-expression.html" target="_blank">Let Expression</a>, je výraz <code class="highlighter-rouge">let</code> jedním ze způsobů vytvoření lokálního scopu v Elmu. Konstanta <code class="highlighter-rouge">multiplier</code> ve funkci <code class="highlighter-rouge">multiplyByFive</code> je vázána k číslu <code class="highlighter-rouge">5</code>. Dokud provádění programu neopustí prostor výrazu <code class="highlighter-rouge">let</code>, je konstanta <code class="highlighter-rouge">multiplier</code> stále aktivní. Pokusíme-li se o změnu hodnoty novým přiřazením uvnitř <code class="highlighter-rouge">let</code>, bude si Elm stěžovat. Nahraďte definici funkce <code class="highlighter-rouge">multiplyByFive</code> v souboru <code class="highlighter-rouge">Playground.elm</code> následujícím kódem.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">multiplyByFive</span> <span class="n">number</span> <span class="o">=</span>
    <span class="kr">let</span>
        <span class="n">multiplier</span> <span class="o">=</span>
            <span class="mi">5</span>

        <span class="n">multiplier</span> <span class="o">=</span>
            <span class="mi">6</span>
    <span class="kr">in</span>
        <span class="n">number</span> <span class="o">*</span> <span class="n">multiplier</span></code></pre></figure>

<p>Obnovíte-li stránku na <a href="http://localhost:8000/elm-examples/Playground.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/Playground.elm</code></a>, měli byste vidět následující chybovou zprávu.</p>

<p><img src="images/duplicate-assignment-error.png" alt="" /></p>

<p>Pokud však druhou definici konstanty <code class="highlighter-rouge">multiplier</code> přemístíme mimo funkci <code class="highlighter-rouge">multiplyByFive</code>, Elm již více neprotestuje, neboť konstanta je nyní definovaná v jiné oblasti, mimo oblast výrazu <code class="highlighter-rouge">let</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">multiplier</span> <span class="o">=</span>
    <span class="mi">6</span>


<span class="n">multiplyByFive</span> <span class="n">number</span> <span class="o">=</span>
    <span class="kr">let</span>
        <span class="n">multiplier</span> <span class="o">=</span>
            <span class="mi">5</span>
    <span class="kr">in</span>
        <span class="n">number</span> <span class="o">*</span> <span class="n">multiplier</span></code></pre></figure>

<p>Obnovíte-li stránku na <a href="http://localhost:8000/elm-examples/Playground.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/Playground.elm</code></a>, chybová zpráva my měla zmizet a měli byste opět vidět <code class="highlighter-rouge">15</code>. Odeberte z kódu deklaraci  <code class="highlighter-rouge">multiplier = 6</code>. Nyní si totéž vyzkoušíme v replu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="mi">5</span>
<span class="mi">5</span>

<span class="o">&gt;</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="mi">6</span>
<span class="mi">6</span></code></pre></figure>

<p>Hmm, proč nám repl dovoluje přiřadit odlišnou hodnotu konstantě <code class="highlighter-rouge">multiplier</code>? Je to proto, že repl pracuje poněkud odlišně. Kdykoli přiřadíme jinou hodnotu k existující konstantě, repl vpodstatě <em>přepojí</em> konstantu na jinou hodnotu. Přepojovací (rebinding) proces zničí konstantu a vrátí ji k životu, jakoby konstanta nikdy předtím na jinou hodnotu neukazovala. Bez tohoto přepojovacího procesu by bylo obtížné, zkoušet si věci v replu.</p>

<h3 id="immutable-collections">Neměnitelné kolekce</h3>

<p>V sekci <a href="tuple.html#modifying-tuples" target="_blank">Úprava entic</a>, když jsme se snažili pochopit, proč nemůžeme měnit entice, jsme objevili, že všechny kolekce Elmu jsou rovněž neměnitelné. Protože je těžké, vytvářet něco užitečného, pokud nemůžeme transformovat data z jedné formy do druhé, používá Elm chytrou techniku, která nám poskytuje zdání, že přidáváme či odebíráme hodnoty z kolekce.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">numbers</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">drop</span> <span class="mi">1</span> <span class="n">numbers</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span></code></pre></figure>

<p>V právě uvedeném příkladu jsme použili operátor <code class="highlighter-rouge">::</code> pro přidání <code class="highlighter-rouge">0</code> na začátek seznamu <code class="highlighter-rouge">numbers</code> a funkci <code class="highlighter-rouge">drop</code> pro odebrání prvního elementu z téhož seznamu. I když jsme byli schopni přidat a vypustit hodnoty ze seznamu, jeho původní obsah se nezměnil:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">numbers</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span></code></pre></figure>

<p>Elm vytvořil kopii původního seznamu, přidal k ní <code class="highlighter-rouge">0</code> a vrátil jako výsledek. Zatímco se toto odehrávalo, zůstal původní seznam nezměněný.</p>

<p class="info"><em>“V čistě funkcionálním programu se hodnota proměnné nikdy nemění a přesto se mění neustále! Paradox!” - Joel Spolsky</em></p>

<h3 id="performance-implications-of-immutability">Výkonostní implikace meněnitelnosti</h3>

<p>Vytváření nové kopie dat pokaždé, když je aktualizujeme, se zdá byt nákladnou operací z hlediska výkonu. To je oprávněná starost. Ovšem, Elm je chytrý a ví, že existující data jsou neměnitelná. Takže je opětovně používá částečně nebo vcelku pokaždé, když vytváří nová data. V důsledku toho nezpůsobuje neměnitelnost v Elmu žádnou výkonostní zátěž. Takto vypadá interní schema tvorby nového seznamu z příkladu nahoře:</p>

<p><img src="images/immutability-performance.png" alt="" /></p>

<h3 id="benefits-of-immutability">Výhody neměnitelnosti</h3>

<p>Hovořili jsme dost o neměnitelnosti konstant a hodnot v Elmu - ale jaké z toho máme výhody? Primární výhodou neměnitelnosti je to, že nám dovoluje psát programy, které se chovají podle našeho očekávání. To vede k vysoce "udržovatelnému" kódu. Abychom byli konkretní, porovnejme impementaci v Elmu  s jiným jazykem, například s JavaScriptem, který nemá neměnitelnost jako řídící princip.</p>

<p>V sekci <a href="list.html#sorting-a-list" target="_blank">Třídění seznamu</a> jsme se naučili třídit seznam, obsahující sedm historicky nejlepších výsledků (zobrazených níže) šampionátů NBA v různém uspořádání.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">[</span> <span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span> <span class="p">]</span></code></pre></figure>

<p>Řekněme, že se NBA rozhodla povolit nový přípravek s potenciálem až dvojnásobně zvýšit úspěšnost všech hráčů. To ztíží porovnávání současných hráčů s již nehrajícími hráči. Musíme tedy upravit všechny historické statistiky. Napišme funkci, která to zvládne. Nejprve ji napíšeme v JavaScriptu - v jazyce, který připouští mutaci - abychom zjistili, co se může pošpatnit.</p>

<p class="info">Nestrachujte se, že jste dosud nikdy JavaScript nepoužíval. Následující příklad je docela jednoduchý a budete schopni je bez obtíží s porozuměním sledovat.</p>

<p>Vytvořte nový soubor <code class="highlighter-rouge">experiment.js</code> v kořenovém adresáři <code class="highlighter-rouge">beginning-elm</code>.</p>

<p><img src="images/experiment-javascript-file.png" alt="" /></p>

<p>Nyní do něj vložte tento kód.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">multiplier</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">];</span>

<span class="kd">function</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">multiplier</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">scores</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">scores</code> - Proměnná, která ukazuje na seznam nejvyšších výsledků.</p>

<p><code class="highlighter-rouge">multiplier</code> - Proměnná, která ukazuje na číslo, které bude použito pro násobení každého elementu v seznamu <code class="highlighter-rouge">scores</code> list.</p>

<p><code class="highlighter-rouge">doubleScores</code> - Funkce, která přijímá seznam výsledků, iteruje jím pomocí smyčky <code class="highlighter-rouge">for</code>, přičemž každý element násobí hodnotou proměnné <code class="highlighter-rouge">multiplier</code>.</p>

<p>Next, load <code class="highlighter-rouge">experiment.js</code> in <code class="highlighter-rouge">index.html</code> located in the root project directory <code class="highlighter-rouge">beginning-elm</code> like this:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  .
  .
  <span class="nt">&lt;body&gt;</span>
    .
    .
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"elm.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"experiment.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    .
    .
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span></code></pre></figure>

<p class="info">Jak zmíněno v sekci <a href="elm-compiler.html" target="_blank">Kompilátor Elmu</a>, je perfektně možné použit kód Elmu a JavaScriptu vedle sebe.</p>

<p>Otevřte sooubor <code class="highlighter-rouge">index.html</code> v prohlížeči a v téže stránkce otevřte "konzolu prohlížeče".</p>

<dl>
  <dt>Otevření konzoly prohlížeče</dt>
  <dd>Instrukce pro otevření této konzoly závisí na používaném prohlížeči. Přečtěte si prosím <a href="https://www.wickedlysmart.com/hfjsconsole/" target="_blank">tento</a> pěkný tutoriál od WickedlySmart, který popisuje otevření konzoly v různých prohlížečích v různých OS.</dd>
</dl>

<p>Ověřte, zda je kód z <code class="highlighter-rouge">experiment.js</code> úspěšně načten vyvoláním těchto hodnot v konzoli.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">multiplier</span>
<span class="mi">2</span></code></pre></figure>

<p>Podívejme se na funkci <code class="highlighter-rouge">doubleScores</code> v akci. Aplikujte ji takto v konzole:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">624</span><span class="p">,</span> <span class="mi">740</span><span class="p">,</span> <span class="mi">674</span><span class="p">,</span> <span class="mi">636</span><span class="p">,</span> <span class="mi">628</span><span class="p">]</span></code></pre></figure>

<p>Zatím vypadá vše dobře. Pojďme dál a předefinujme proměnnou <code class="highlighter-rouge">multiplier</code> v souboru <code class="highlighter-rouge">experiment.js</code>, tak že ukazuje na hodnotu <code class="highlighter-rouge">3</code>.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">multiplier</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">];</span>

<span class="kd">var</span> <span class="nx">multiplier</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">multiplier</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">scores</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Všimněte si, že původní definice <code class="highlighter-rouge">var multiplier = 2;</code> zůstává na místě. Nyní obnovte (reload)  stránku <code class="highlighter-rouge">index.html</code> v prohlížeči aby se naše změny v souboru <code class="highlighter-rouge">experiment.js</code> mohly projevit. Potom aplikujte funkci <code class="highlighter-rouge">doubleScores</code> na seznam <code class="highlighter-rouge">scores</code> zápisem následujícího kódu do konzoly prohížeče.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">948</span><span class="p">,</span> <span class="mi">960</span><span class="p">,</span> <span class="mi">936</span><span class="p">,</span> <span class="mi">1110</span><span class="p">,</span> <span class="mi">1011</span><span class="p">,</span> <span class="mi">954</span><span class="p">,</span> <span class="mi">942</span><span class="p">]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">doubleScores</code> nyní ztrojnásobí hodnotu každého elementu v seznamu <code class="highlighter-rouge">scores</code>, což je problematické. Nové chování se neshoduje se jménem funkce. My chceme aby funkce pouze zdvojnásobila výsledky, bez ohledu na cokoli.</p>

<p>Žel, většina jazyků, které umožňují mutaci, trpí tímto problémem. Je zejména frustrující, když k redefinici dojde v odlehlé části kódu, což je obtížné detekovat. V našem příkladě snadno vidíme, že je proměnná <code class="highlighter-rouge">multiplier</code> redefinována, protože je blízko původní definice. V reálném světě má většína problémů, způsobených mutací, tendenci se projevit až po distribuci do produkčního prostředí.</p>

<p>Jak se s takovouto situací vyrovnává Elm? Abychom to zjistili, implementujme výše uvedený kód do Elmu. Přidejte následující kód hned nad  <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">multiplier</span> <span class="o">=</span>
    <span class="mi">2</span>


<span class="n">scores</span> <span class="o">=</span>
    <span class="p">[</span> <span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span> <span class="p">]</span>


<span class="n">multiplier</span> <span class="o">=</span>
    <span class="mi">3</span>


<span class="n">doubleScores</span> <span class="n">scores</span> <span class="o">=</span>
    <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">)</span> <span class="n">scores</span></code></pre></figure>

<p>Obnovíte-li stránku na <a href="http://localhost:8000/elm-examples/Playground.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/Playground.elm</code></a>, měli byste vidět následující chybovou zprávu.</p>

<p><img src="images/duplicate-assignment-error-2.png" alt="" /></p>

<p>Je to stejná chyba, jakou jsme dostali v odstavci <a href="immutability.html#immutable-constants" target="_blank">Neměnitelné konstanty</a> výše. Elm nám nedovolí předefinovat konstantu <code class="highlighter-rouge">multiplier</code> v téže oblasti (scope). Pokračujte a odeberte redefinici  <code class="highlighter-rouge">multiplier = 3</code>.</p>

<p>Kód v JavaScript nahoře má další problém: mění původní seznam  <code class="highlighter-rouge">scores</code>.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">624</span><span class="p">,</span> <span class="mi">740</span><span class="p">,</span> <span class="mi">674</span><span class="p">,</span> <span class="mi">636</span><span class="p">,</span> <span class="mi">628</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">624</span><span class="p">,</span> <span class="mi">740</span><span class="p">,</span> <span class="mi">674</span><span class="p">,</span> <span class="mi">636</span><span class="p">,</span> <span class="mi">628</span><span class="p">]</span></code></pre></figure>

<p>Jak vidno, hodnoty uvnitř seznamu <code class="highlighter-rouge">scores</code> se změnily. To je také problematické. Abychom pochopili proč, odeberme redefinici  <code class="highlighter-rouge">var multiplier = 3</code> ze soubooru <code class="highlighter-rouge">experiment.js</code> a přidejme dvě nové funkce pod funkci <code class="highlighter-rouge">doubleScores</code> takto:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">multiplier</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">];</span>

<span class="kd">function</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">multiplier</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">scores</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">scoresLessThan320</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isLessThan320</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isLessThan320</span><span class="p">(</span><span class="nx">score</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">score</span> <span class="o">&lt;</span> <span class="mi">320</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Jak jméno napovídá, funkce <code class="highlighter-rouge">scoresLessThan320</code> vrací všechny výsledky, které jsou menší než <code class="highlighter-rouge">320</code>. Prověřování, zda je výsledek menší nebo větší než <code class="highlighter-rouge">320</code>, deleguje funkce <code class="highlighter-rouge">scoresLessThan320</code> na funkci <code class="highlighter-rouge">isLessThan320</code>. Obnovte <code class="highlighter-rouge">index.html</code> v prohlížeči aby byl načten nový kód v souboru <code class="highlighter-rouge">experiment.js</code>. Poté aplikujte funkci <code class="highlighter-rouge">scoresLessThan320</code> v konzole prohlížece takto:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">scoresLessThan320</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">scoresLessThan320</code> vrací výsledek podle očekávání. Co se ale stane, když aplikujeme funkci <code class="highlighter-rouge">doubleScores</code> před funkcí <code class="highlighter-rouge">scoresLessThan320</code>? Abychom to zjistili, obnovte znovu stránku <code class="highlighter-rouge">index.html</code> v prohlížeči, abychom vyprázdnili konzolu prohlížeče. Poté v ní aplikujte níže uvedené funkce.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">624</span><span class="p">,</span> <span class="mi">740</span><span class="p">,</span> <span class="mi">674</span><span class="p">,</span> <span class="mi">636</span><span class="p">,</span> <span class="mi">628</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">scoresLessThan320</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">scoresLessThan320</code> hlásí, že neexistují výsledky menší než <code class="highlighter-rouge">320</code>, což není správné. Je to proto, že funkce <code class="highlighter-rouge">doubleScores</code> 
zdvojila hodnoty a uložila je zpět do původního seznamu, který jsme posléze zadali funkci <code class="highlighter-rouge">scoresLessThan320</code>, aniž bychom si význam této změny uvědomili.</p>

<p><img src="images/mutation-unexpected-result.png" alt="" /></p>

<p>Co jsme vlastně zamýšleli vyjadřuje toto:</p>

<p><img src="images/mutation-expected-result.png" alt="" /></p>

<p>Lze se tomuto problému v JavaScriptu vyhnout? Zajisté. Nahraďte stávající znění funkce <code class="highlighter-rouge">doubleScores</code> tímto:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">newScores</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">newScores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">multiplier</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">newScores</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">doubleScores</code> již existující seznam nemění. Místo toho vždy vrací nový seznam.
Obnovte stránku  <code class="highlighter-rouge">index.html</code> a v konzole prohlížeče aplikujte funkce <code class="highlighter-rouge">doubleScores</code> a <code class="highlighter-rouge">scoresLessThan320</code> ve stejném pořadí jako předtím.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">624</span><span class="p">,</span> <span class="mi">740</span><span class="p">,</span> <span class="mi">674</span><span class="p">,</span> <span class="mi">636</span><span class="p">,</span> <span class="mi">628</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">scoresLessThan320</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span></code></pre></figure>

<p>Nyní to chodí dle očekávání. Vyzkoušejme to v Elmu abychom viděli zda dostaneme rozdílné výsledky v závislosti na pořadí, ve kterém aplikujeme funkci <code class="highlighter-rouge">scoresLessThan320</code>. Přidejte následující definice funkcí hned nad <code class="highlighter-rouge">main</code> v  souboru<code class="highlighter-rouge">Playground.elm</code></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">scoresLessThan320</span> <span class="n">scores</span> <span class="o">=</span>
    <span class="kt">List</span><span class="o">.</span><span class="n">filter</span> <span class="n">isLessThan320</span> <span class="n">scores</span>


<span class="n">isLessThan320</span> <span class="n">score</span> <span class="o">=</span>
    <span class="n">score</span> <span class="o">&lt;</span> <span class="mi">320</span>


<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Abychom řádně porovnali výsledky experimentů, které jsme provedli s kódem JavaScript v konzole prohlížeče s kódem Elmu, potřebujeme načíst kód ze souboru <code class="highlighter-rouge">Playground.elm</code> do <code class="highlighter-rouge">elm-repl</code>. Aktuálně vyhledává Elm moduly jenom v adresáři <code class="highlighter-rouge">beginning-elm</code>, protože jsme v souboru <code class="highlighter-rouge">elm-package.json</code> určili <code class="highlighter-rouge">"."</code> jako jediný zdrojový adresář. Označení <code class="highlighter-rouge">"."</code> znamená, že soubor <code class="highlighter-rouge">elm-package.json</code> sám se aktuálně nachází v adresáři <code class="highlighter-rouge">beginning-elm</code>. Aby <code class="highlighter-rouge">elm-repl</code> nalezl soubor <code class="highlighter-rouge">Playground.elm</code>, potřebujeme do seznamu přidat rovněž adresář<code class="highlighter-rouge">elm-examples</code>.</p>

<figure class="highlight"><pre><code class="language-code" data-lang="code">{
    .
    .
    "source-directories": [
        ".",
        "elm-examples"
    ],
    .
    .
}</code></pre></figure>

<p>Nezapomeňte přidat čárku za <code class="highlighter-rouge">"."</code>. V replu načtěte modul <code class="highlighter-rouge">Playground</code> module.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Playground</span> <span class="n">exposing</span> <span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">doubleScores</span><span class="p">,</span> <span class="n">scoresLessThan320</span><span class="p">)</span></code></pre></figure>

<p>Ze souboru <code class="highlighter-rouge">Playground.elm</code> jsme imprtovali <code class="highlighter-rouge">scores</code>, <code class="highlighter-rouge">doubleScores</code> a <code class="highlighter-rouge">scoresLessThan320</code>, takže je při použití nemusíme doplňovat prefixem s názvem modulu. Bez prefixů bude naše porovnávání kódů přehlednější. Jak bylo zmíněno v sekci <a href="http://localhost:4000/string.html#calculating-length" target="_blank">Strings</a>, dejte si pozor abyste se při importu objektů z externích modulů nedostali do kolize jmen. Nyní aplikujme <code class="highlighter-rouge">scoresLessThan320</code> před <code class="highlighter-rouge">doubleScores</code> a uvidíme, co dostaneme.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span><span class="mi">320</span><span class="p">,</span><span class="mi">312</span><span class="p">,</span><span class="mi">370</span><span class="p">,</span><span class="mi">337</span><span class="p">,</span><span class="mi">318</span><span class="p">,</span><span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="n">scoresLessThan320</span> <span class="n">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span><span class="mi">312</span><span class="p">,</span><span class="mi">318</span><span class="p">,</span><span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="n">doubleScores</span> <span class="n">scores</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span><span class="mi">640</span><span class="p">,</span><span class="mi">624</span><span class="p">,</span><span class="mi">740</span><span class="p">,</span><span class="mi">674</span><span class="p">,</span><span class="mi">636</span><span class="p">,</span><span class="mi">628</span><span class="p">]</span></code></pre></figure>

<p>Dostali jsme, co jsme očekávali. Nyní aplikujme v replu <code class="highlighter-rouge">scoresLessThan320</code> až po <code class="highlighter-rouge">doubleScores</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span><span class="mi">320</span><span class="p">,</span><span class="mi">312</span><span class="p">,</span><span class="mi">370</span><span class="p">,</span><span class="mi">337</span><span class="p">,</span><span class="mi">318</span><span class="p">,</span><span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="n">doubleScores</span> <span class="n">scores</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span><span class="mi">640</span><span class="p">,</span><span class="mi">624</span><span class="p">,</span><span class="mi">740</span><span class="p">,</span><span class="mi">674</span><span class="p">,</span><span class="mi">636</span><span class="p">,</span><span class="mi">628</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="n">scoresLessThan320</span> <span class="n">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span><span class="mi">312</span><span class="p">,</span><span class="mi">318</span><span class="p">,</span><span class="mi">314</span><span class="p">]</span></code></pre></figure>

<p>Opět jsme dostali, co jsme očekávali. V Elmu nemusíme  implementovat funkci <code class="highlighter-rouge">scoresLessThan320</code> specielním způsobem, aby se chovala konzistentně.</p>

<p>I když jsme byli schopni vyřešit problém s mutací v JavaScriptu explicitním návratem nového seznamu, musíme si být vědomi skutečnosti, že neměnitelnost není integrální součástí JavaScriptu. Což nás má nutit ke zvýšené obezřetnosti. To se stává únavné při obsáhlejším kódu v JS. V Elmu ovšem vrací funkce <code class="highlighter-rouge">List.map</code> (a všechny ostatní funkce v modulu <code class="highlighter-rouge">List</code>) nový seznam automaticky. Neměnitelnost jako nedílná součást jazyka nás kompletně zbavuje podobných problémů.</p>
</article>

<nav class="pagination">
<a class="pagination-next" href="benefits-intro.html">
<em>&larr; Previous</em>
<strong>Záznamy</strong>
</a>
<a class="pagination-next" href="pure-functions.html">
<em>Next &rarr;</em><strong>Čisté funkce</strong>
</a>
<a class="elevator" href="aa-index.html"><i class="fa fa-angle-up"></i>
<span>Back to top</span>
</a>
</nav>

</div>
</div>



<footer id="footer" class="page-footer">
<footer class="container">
 <p>Copyright © 2016 Pawan Poudel. All Rights Reserved.</p>
</footer>
</footer>
    

  </body>
</html>
