<!DOCTYPE html>

<html lang="cs">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title> - Beginning Elm</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/main.css">
<!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">    deformuje zobrazení font awsome -->
</head>

<body>

<section class="heading">
<h1> 4.6 </h1>
<h2>Typový systém</h2>
</section>

<div class="page-content">
<div class="container">

<div class="breadcrumb-holder">
<header id="breadcrumb" class="breadcrumb">


<a class="breadcrumb-next" href="easier-code-organization.html">
<i class="fa fa-angle-right"></i><span>Next article</span></a>

<a href="aa-index.html" class="breadcrumb-toggle">
  <span></span>
  <span></span>
  <span></span>
</a>
<a class="breadcrumb-previous" href="easy-to-test.html">
<i class="fa fa-angle-left"></i><span>Previous article</span>
</a>

<!--<span class="breadcrumb-section">syntaxe</span>-->


<!--
<a class="breadcrumb-previous" href="easy-to-test.html">
<i class="fa fa-angle-left"></i><span>Previous article</span>
</a>-->
          
</header>
</div>
 


<article class="content">
<p>V sekci <a href="immutability.html#benefits-of-immutability" target="_blank">Neměnitelnost</a> jsme v JavaScriptu napsali funkci, která zdvojnásobila historicky nejvyšší výsledky z pravidelných šampionátů NBA.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">multiplier</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">];</span>

<span class="kd">function</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">newScores</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">newScores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">multiplier</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">newScores</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Když jsme ji jako vstup poskytli seznam čísel, vrátila očekávaný výsledek.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">scores</span>
<span class="p">[</span><span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">624</span><span class="p">,</span> <span class="mi">740</span><span class="p">,</span> <span class="mi">674</span><span class="p">,</span> <span class="mi">636</span><span class="p">,</span> <span class="mi">628</span><span class="p">]</span></code></pre></figure>

<p>Co se stane, když ji zadáme vstup jiného typu, jenž není seznamem čísel?</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">string</span> <span class="o">=</span> <span class="s2">"scores"</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span>
<span class="p">[</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">]</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">undefinedValue</span> <span class="o">=</span> <span class="kc">undefined</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">undefinedValue</span><span class="p">)</span>

<span class="nx">Uncaught</span> <span class="nx">TypeError</span><span class="err">:</span> <span class="nx">Cannot</span> <span class="nx">read</span> <span class="nx">property</span> <span class="s1">'length'</span> <span class="nx">of</span> <span class="kc">undefined</span>
    <span class="nx">at</span> <span class="nx">doubleScores</span> <span class="p">(</span><span class="nx">experiment</span><span class="p">.</span><span class="nx">js</span><span class="err">:</span><span class="mi">7</span><span class="p">)</span>
    <span class="nx">at</span> <span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span><span class="err">:</span><span class="mi">1</span><span class="err">:</span><span class="mi">1</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"key"</span> <span class="p">:</span> <span class="s2">"value"</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span>
<span class="p">[]</span></code></pre></figure>

<p>Vstup přijme bez ohledu na jeho typ a vrátí nečekaný výsledek. Je-li vstupem řetězec, generuje array hodnot <code class="highlighter-rouge">NaN</code> (Not-a-number). JavaScript nemá datový typ zvaný <code class="highlighter-rouge">List</code> (seznam.) Má pouze array, což je jako kombinace seznamu a arraye v Elmu.</p>

<p>Je-li vstupem nedefinovaná hodnota, vyvolá funkce <code class="highlighter-rouge">doubleScores</code> chybové hlášení. Je-li vstupem objekt, vrací prázdný seznam. Objekt v JavaScriptu je podobný entitě <a href="record.html" target="_blank">record</a> v Elmu. Je to kolekce párů key/values.</p>

<p>Chceme aby naše funkce byly spolehlivé. Chceme aby odmítaly vstupy, které nepatří do množin jejich vstupů. Můžeme kolem našich funkcí osadit nějaké ochranné mříže, které nepropustí neplatné vstupy? Pojďme to zjistit. Upravme funkci  <code class="highlighter-rouge">doubleScores</code> v souboru <code class="highlighter-rouge">experiment.js</code>, umístěném v adresáři <code class="highlighter-rouge">beginning-elm</code> takto:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// Reject non-list type inputs</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Input must be of type array"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">newScores</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">newScores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">multiplier</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">newScores</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Přidali jsme na samý počátek podmínku <code class="highlighter-rouge">if</code> abychom prověřili, že vstup je typu array. Není-li, vyvoláváme chybové hlášení. Nyní se podívejme, jak funkce <code class="highlighter-rouge">doubleScores</code> reaguje, když ji zadáme neplatný vstup. Otevřete v prohlížeči soubor <code class="highlighter-rouge">index.html</code> z adresáře <code class="highlighter-rouge">beginning-elm</code> a v otevřené stránce otevřete konzolu prohlížeče. Za prompt <code class="highlighter-rouge">&gt;</code> zadávejte postupně následující příkazy a zkoumejte výstupy.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">string</span> <span class="o">=</span> <span class="s2">"scores"</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span>

<span class="nx">Uncaught</span> <span class="nb">Error</span><span class="err">:</span> <span class="nx">Input</span> <span class="nx">must</span> <span class="nx">be</span> <span class="nx">of</span> <span class="nx">type</span> <span class="nx">array</span>
    <span class="nx">at</span> <span class="nx">doubleScores</span> <span class="p">(</span><span class="nx">experiment</span><span class="p">.</span><span class="nx">js</span><span class="err">:</span><span class="mi">18</span><span class="p">)</span>
    <span class="nx">at</span> <span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span><span class="err">:</span><span class="mi">1</span><span class="err">:</span><span class="mi">1</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">undefinedValue</span> <span class="o">=</span> <span class="kc">undefined</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">undefinedValue</span><span class="p">)</span>

<span class="nx">Uncaught</span> <span class="nb">Error</span><span class="err">:</span> <span class="nx">Input</span> <span class="nx">must</span> <span class="nx">be</span> <span class="nx">of</span> <span class="nx">type</span> <span class="nx">array</span>
    <span class="nx">at</span> <span class="nx">doubleScores</span> <span class="p">(</span><span class="nx">experiment</span><span class="p">.</span><span class="nx">js</span><span class="err">:</span><span class="mi">18</span><span class="p">)</span>
    <span class="nx">at</span> <span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span><span class="err">:</span><span class="mi">1</span><span class="err">:</span><span class="mi">1</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"key"</span> <span class="p">:</span> <span class="s2">"value"</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span>

<span class="nx">Uncaught</span> <span class="nb">Error</span><span class="err">:</span> <span class="nx">Input</span> <span class="nx">must</span> <span class="nx">be</span> <span class="nx">of</span> <span class="nx">type</span> <span class="nx">array</span>
    <span class="nx">at</span> <span class="nx">doubleScores</span> <span class="p">(</span><span class="nx">experiment</span><span class="p">.</span><span class="nx">js</span><span class="err">:</span><span class="mi">18</span><span class="p">)</span>
    <span class="nx">at</span> <span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span><span class="err">:</span><span class="mi">1</span><span class="err">:</span><span class="mi">1</span></code></pre></figure>

<p>Zadané vstupy jsou soustavně odmítány s nepředpovídatelnými odůvodněními. To je však mnohem lepší, než přijmout každý vstup a získávat nepředpovídatelný výstup. Následně se pokusíme zjistit, co se stane, zadáme-li array hodnot, jež nejsou čísly.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">undefinedArray</span> <span class="o">=</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">undefinedArray</span><span class="p">)</span>
<span class="p">[</span><span class="kc">NaN</span><span class="p">]</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">stringArray</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"scores"</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">stringArray</span><span class="p">)</span>
<span class="p">[</span><span class="kc">NaN</span><span class="p">]</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"key"</span> <span class="p">:</span> <span class="s2">"value"</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">([</span><span class="nx">object</span><span class="p">])</span>
<span class="p">[</span><span class="kc">NaN</span><span class="p">]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">doubleScores</code> 
připouští arraye s nečíselnými hodnotami, což je rovněž problematické. Mohli bychom instalovat nějaká svodidla, která by tomu zabránila? Zajisté. Upravte funkci <code class="highlighter-rouge">doubleScores</code> v souboru <code class="highlighter-rouge">experiment.js</code> takto:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// Reject non-list type inputs</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">scores</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Input must be of type array"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">newScores</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Reject arrays that contain values that are not numbers</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="s2">"number"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Input array must contain numbers only"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nx">newScores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">scores</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">multiplier</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">newScores</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Přidali jsme další podmínku <code class="highlighter-rouge">if</code> uvnitř smyčky <code class="highlighter-rouge">for</code> abychom ověřili, že každý prvek arraye je typu 'number'. 
Nyní si ověřme, jak funkce <code class="highlighter-rouge">doubleScores</code> reaguje, když ji zadáme nečíselné hodnoty. Obnovte zobrazení souboru <code class="highlighter-rouge">index.html</code> v prohlížeči aby se projevily změny souboru <code class="highlighter-rouge">experiment.js</code>.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">undefinedArray</span> <span class="o">=</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">undefinedArray</span><span class="p">)</span>

<span class="nx">Uncaught</span> <span class="nb">Error</span><span class="err">:</span> <span class="nx">Input</span> <span class="nx">array</span> <span class="nx">must</span> <span class="nx">contain</span> <span class="nx">numbers</span> <span class="nx">only</span>
    <span class="nx">at</span> <span class="nx">doubleScores</span> <span class="p">(</span><span class="nx">experiment</span><span class="p">.</span><span class="nx">js</span><span class="err">:</span><span class="mi">27</span><span class="p">)</span>
    <span class="nx">at</span> <span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span><span class="err">:</span><span class="mi">1</span><span class="err">:</span><span class="mi">1</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">stringArray</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"scores"</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">(</span><span class="nx">stringArray</span><span class="p">)</span>

<span class="nx">Uncaught</span> <span class="nb">Error</span><span class="err">:</span> <span class="nx">Input</span> <span class="nx">array</span> <span class="nx">must</span> <span class="nx">contain</span> <span class="nx">numbers</span> <span class="nx">only</span>
    <span class="nx">at</span> <span class="nx">doubleScores</span> <span class="p">(</span><span class="nx">experiment</span><span class="p">.</span><span class="nx">js</span><span class="err">:</span><span class="mi">27</span><span class="p">)</span>
    <span class="nx">at</span> <span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span><span class="err">:</span><span class="mi">1</span><span class="err">:</span><span class="mi">1</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"key"</span> <span class="p">:</span> <span class="s2">"value"</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="nx">doubleScores</span><span class="p">([</span><span class="nx">object</span><span class="p">])</span>

<span class="nx">Uncaught</span> <span class="nb">Error</span><span class="err">:</span> <span class="nx">Input</span> <span class="nx">array</span> <span class="nx">must</span> <span class="nx">contain</span> <span class="nx">numbers</span> <span class="nx">only</span>
    <span class="nx">at</span> <span class="nx">doubleScores</span> <span class="p">(</span><span class="nx">experiment</span><span class="p">.</span><span class="nx">js</span><span class="err">:</span><span class="mi">27</span><span class="p">)</span>
    <span class="nx">at</span> <span class="o">&lt;</span><span class="nx">anonymous</span><span class="o">&gt;</span><span class="err">:</span><span class="mi">1</span><span class="err">:</span><span class="mi">1</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">doubleScores</code>
opět soustavně odmítá arraye, které obsahují nečíselné hodnoty ale tentokrát vrací předvídatelné chyby. I když je nyní spolehlivější než dříve, musíme nejen identifikovat situace, kdy by funkce akceptovala špatné vstupy ale také přijímat  opatření, jež by tyto situace marginalizovala. To může být vyčerpávající, obsahuje-li náš kód stovky funkcí jako <code class="highlighter-rouge">doubleScores</code>.</p>

<p>Nyní zjistíme, jak funkce <code class="highlighter-rouge">doubleScores</code> reaguje na vstupy s neplatnými typy. V adresáři <code class="highlighter-rouge">beginning-elm/elm-examples</code> bychom měli mít soubor <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">multiplier</span> <span class="o">=</span>
    <span class="mi">2</span>


<span class="n">scores</span> <span class="o">=</span>
    <span class="p">[</span> <span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span> <span class="p">]</span>


<span class="n">doubleScores</span> <span class="n">scores</span> <span class="o">=</span>
    <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">)</span> <span class="n">scores</span></code></pre></figure>

<p>V tomto adresáři aktivujte elm-repl a zadejte následující příkazy:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Playground</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">doubleScores</span> <span class="s">"scores"</span>

<span class="c1">----------------------- TYPE MISMATCH ------------------------</span>
<span class="kt">The</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">function</span> <span class="p">`</span><span class="n">doubleScores</span><span class="p">`</span> <span class="n">is</span> <span class="n">causing</span> <span class="n">a</span> <span class="n">mismatch</span><span class="o">.</span>

<span class="mi">4</span><span class="o">|</span>   <span class="n">doubleScores</span> <span class="s">"scores"</span>
                  <span class="o">^^^^^^^^</span>
<span class="kt">Function</span> <span class="p">`</span><span class="n">doubleScores</span><span class="p">`</span> <span class="n">is</span> <span class="n">expecting</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">be</span><span class="o">:</span>

    <span class="kt">List</span> <span class="n">number</span>

<span class="kt">But</span> <span class="n">it</span> <span class="n">is</span><span class="o">:</span>

    <span class="kt">String</span></code></pre></figure>

<p class="info">Funkce <code class="highlighter-rouge">doubleScores</code> je definována v modulu <code class="highlighter-rouge">Playground</code>. Proto jej musíme v replu před vlastním voláním funkce importovat.</p>

<p>Dovídáme se, že jako argument je očekáván seznam s číselnými hodnotami. Co když zadáme seznam s nečíselnými hodnotami?</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">doubleScores</span> <span class="p">[</span> <span class="s">"scores"</span> <span class="p">]</span>

<span class="c1">----------------------- TYPE MISMATCH -------------------------</span>
<span class="kt">The</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">function</span> <span class="p">`</span><span class="n">doubleScores</span><span class="p">`</span> <span class="n">is</span> <span class="n">causing</span> <span class="n">a</span> <span class="n">mismatch</span><span class="o">.</span>

<span class="mi">4</span><span class="o">|</span>   <span class="n">doubleScores</span> <span class="p">[</span> <span class="s">"scores"</span> <span class="p">]</span>
                  <span class="o">^^^^^^^^^^^^</span>
<span class="kt">Function</span> <span class="p">`</span><span class="n">doubleScores</span><span class="p">`</span> <span class="n">is</span> <span class="n">expecting</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">be</span><span class="o">:</span>

    <span class="kt">List</span> <span class="n">number</span>

<span class="kt">But</span> <span class="n">it</span> <span class="n">is</span><span class="o">:</span>

    <span class="kt">List</span> <span class="kt">String</span></code></pre></figure>

<p>Budeme stále odmítáni, dokud nezadáme seznam s čísly.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">doubleScores</span> <span class="p">[</span> <span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span> <span class="p">]</span>
<span class="p">[</span><span class="mi">632</span><span class="p">,</span><span class="mi">640</span><span class="p">,</span><span class="mi">624</span><span class="p">,</span><span class="mi">740</span><span class="p">,</span><span class="mi">674</span><span class="p">,</span><span class="mi">636</span><span class="p">,</span><span class="mi">628</span><span class="p">]</span></code></pre></figure>

<p>Nakonec jsme žádná svodidla, jež by přiměla funkci <code class="highlighter-rouge">doubleScores</code> odmítat vstupy s neplatnými typy, instalovat nemuseli. To proto, že Elm disponuje účinným systémem typů, který automaticky vyvolá chybové hlášení, kdykoli se vstup neshoduje přesně s očekávaným typem vstupu funkce. Typový systém Elmu nám umožňuje soustředit se na řešení problému bez starostí o to, jak se náš kód zachová při zadání neplatného vstupu. Funkce v Elmu jsou také stručnější v důsledku nepřítomnosti kódu, ověřujícího typ vstupních hodnot.<br>
Zbytek této sekce se podrobně zabývá systémem typů v Elmu.</p>

<h3 id="type">Typy hodnot</h3>

<p>Typ je kolekce hodnot, majících podobné vlastnosti. Na příklad, typ <code class="highlighter-rouge">Int</code> reprezentuje celá čísla: <code class="highlighter-rouge">-1</code>, <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">2</code> etc. Typ <code class="highlighter-rouge">Bool</code> reprezentuje logické hodnoty <code class="highlighter-rouge">True</code> a <code class="highlighter-rouge">False</code>. 
Zadáme-li hodnotu v replu, dozvíme se její typ:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="o">:</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="mf">2.5</span>
<span class="mf">2.5</span> <span class="o">:</span> <span class="kt">Float</span>

<span class="o">&gt;</span> <span class="kt">True</span>
<span class="kt">True</span> <span class="o">:</span> <span class="kt">Bool</span>

<span class="o">&gt;</span> <span class="s">"dudeism"</span>
<span class="s">"dudeism"</span> <span class="o">:</span> <span class="kt">String</span></code></pre></figure>

<p><img src="images/types-and-values.png" alt="" /></p>

<p>Dvojtečka <code class="highlighter-rouge">:</code> zde odděluje hodnotu od jejího typu. Lze ji číst jako: "je typu". 
Když jsem zapsali číslo <code class="highlighter-rouge">1</code>, vytiskl repl jeho typ jako <code class="highlighter-rouge">number</code>, což je označení číselného typu. Konkretním typem může být typ  <code class="highlighter-rouge">Int</code> nebo <code class="highlighter-rouge">Float</code>, podle způsobu použití:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="o">:</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="mf">5.3</span> <span class="o">+</span> <span class="n">x</span>
<span class="mf">6.3</span> <span class="o">:</span> <span class="kt">Float</span>

<span class="o">&gt;</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">x</span>
<span class="mi">6</span> <span class="o">:</span> <span class="n">number</span></code></pre></figure>

<p>Přičteme-li <code class="highlighter-rouge">1</code> k <code class="highlighter-rouge">5.3</code> dostaneme <code class="highlighter-rouge">Float</code>. Přičteme-li  <code class="highlighter-rouge">1</code> k <code class="highlighter-rouge">5</code>, stále dostáváme  <code class="highlighter-rouge">number</code>, protože výsledek <code class="highlighter-rouge">6</code> může být považován buď za <code class="highlighter-rouge">Int</code> nebo za <code class="highlighter-rouge">Float</code> podle použití. Zde je příklad, kdy <code class="highlighter-rouge">x</code> skončí jako typ <code class="highlighter-rouge">Int</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="n">length</span> <span class="s">"Duder"</span><span class="p">)</span>
<span class="mi">6</span> <span class="o">:</span> <span class="kt">Int</span></code></pre></figure>

<p>Výraz <code class="highlighter-rouge">String.length "Duder"</code> vrací hodnotu typu <code class="highlighter-rouge">Int</code>. Sečteme-li tedy <code class="highlighter-rouge">x</code> s výsledkem tohoto výrazu, je výsledný součet rovněž typu <code class="highlighter-rouge">Int</code>.</p>

<h4 id="expressions-have-types-too">Výrazy jsou rovněž nositelé typu</h4>

<p>Protože se všechny výrazy v Elmu při vyhodnocení redukují na hodnoty, jsou rovněž nositeli typu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="s">"The church of "</span> <span class="o">++</span> <span class="s">"the latter-day dude"</span>
<span class="s">"The church of the latter-day dude"</span> <span class="o">:</span> <span class="kt">String</span></code></pre></figure>

<p>Výraz <code class="highlighter-rouge">"The church of " ++ "the latter-day dude"</code> spojuje dva řetězce. Jeho typ je dán typem výsledné hodnoty.</p>

<p class="info">Až dosud se v příkladech pro repl vynechávalo označení typu výrazů. Nyní, když víme, co typ znamená, se toto označení bude uvádět.</p>

<h3 id="list-type">Typ List.</h3>

<p>Ukažme si, co dostaneme, když zadáme seznam (list):</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="kt">Float</span>

<span class="o">&gt;</span> <span class="p">[</span> <span class="s">"Jackie"</span><span class="p">,</span> <span class="s">"Treehorn"</span><span class="p">,</span> <span class="s">"Bunny"</span><span class="p">]</span>
<span class="p">[</span><span class="s">"Jackie"</span><span class="p">,</span><span class="s">"Treehorn"</span><span class="p">,</span><span class="s">"Bunny"</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="kt">String</span></code></pre></figure>

<p>Dostáváme slovo <code class="highlighter-rouge">List</code> následované typem hodnot, které seznam obsahuje. A což prázdný seznam?</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">[]</span>
<span class="kt">[]</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">a</span></code></pre></figure>

<p>Místo konkretního typu dostáváme označení <code class="highlighter-rouge">a</code>, což znamená, že se typ může měnit v závislosti na použití prázdného seznamu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">::</span> <span class="kt">[]</span>
<span class="p">[</span><span class="mf">1.5</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="kt">Float</span>

<span class="o">&gt;</span> <span class="s">"Maude"</span> <span class="o">::</span> <span class="kt">[]</span>
<span class="p">[</span><span class="s">"Maude"</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="kt">String</span></code></pre></figure>

<p>Přidáme-li float, typ seznamu je <code class="highlighter-rouge">List Float</code>, přidáme-li řetězec, typ seznamu je <code class="highlighter-rouge">List String</code>. Všechny názvy konkretních typů začínají velkým písmenem. Písmeno <code class="highlighter-rouge">a</code> tudíž není považováno za název typu. Je to <em>typová proměnná</em>, což znamená, že může být jakéhokoli typu. Písmeno <code class="highlighter-rouge">a</code> samo o sobě nemá žádný význam. 
Jeho místo bude nahrazeno konkrétním typem po vyhodnocení výrazu.</p>

<p>Každé jméno, které začíná malým písmenem, může být proměnnou typu. Na příklad <code class="highlighter-rouge">value</code>, <code class="highlighter-rouge">placeholder</code>, <code class="highlighter-rouge">walter</code>, <code class="highlighter-rouge">uli</code> jsou všechno platné názvy proměnné typu. Elm používá písmeno <code class="highlighter-rouge">a</code> kvůli stručnosti. Když jsme v replu zapsali číslo <code class="highlighter-rouge">1</code>, 
vrátilo se označení <code class="highlighter-rouge">number</code>, což je specielní typ proměnné. Můžeme ji použít pro prezentaci buď typu  <code class="highlighter-rouge">Int</code> nebo <code class="highlighter-rouge">Float</code>. V Elmu je velice málo specielních proměnných typu jako je  <code class="highlighter-rouge">number</code>.</p>

<h3 id="array-type">Typ Array</h3>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Array</span>

<span class="o">&gt;</span> <span class="kt">Array</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
<span class="kt">Array</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="kt">Array</span><span class="o">.</span><span class="kt">Array</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="kt">Array</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span> <span class="s">"You"</span><span class="p">,</span> <span class="s">"Human"</span><span class="p">,</span> <span class="s">"Paraquat"</span> <span class="p">]</span>
<span class="kt">Array</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="s">"You"</span><span class="p">,</span><span class="s">"Human"</span><span class="p">,</span><span class="s">"Paraquat"</span><span class="p">]</span> <span class="o">:</span> <span class="kt">Array</span><span class="o">.</span><span class="kt">Array</span> <span class="kt">String</span></code></pre></figure>

<p>Podobně jako u typu <code class="highlighter-rouge">List</code> je typ arraye <code class="highlighter-rouge">Array.Array</code> následovaný typem hodnot, které array obsahuje. Typy, které nejsou automaticky načteny do replu, jsou předznamenány názvem modulu, ve kterém jsou tyto typy uloženy. Protože jsou typy <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Float</code>, <code class="highlighter-rouge">String</code>a <code class="highlighter-rouge">List</code> do replu automaticky načteny, nejsou prefixovány názvem modulu.</p>

<h3 id="tuple-type">Typ Tuple</h3>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">"sic"</span> <span class="p">)</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">"sic"</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="n">number</span><span class="p">,</span> <span class="n">String</span> <span class="p">)</span></code></pre></figure>

<p>Elm nemá pro entici (tuple) samostatné označení jako je <code class="highlighter-rouge">List</code> nebo <code class="highlighter-rouge">Array</code>. Proto repl vypisuje pouze typy jeho jednotlivých prvků <code class="highlighter-rouge">( number, String )</code>. Označení <code class="highlighter-rouge">number</code> je rovněž speciální proměnnou typu. Pokud proměnná typu začíná slovem <code class="highlighter-rouge">number</code> a končí konkretním číslem, má v Elmu speciální význam:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span> <span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
    <span class="o">:</span> <span class="p">(</span> <span class="n">number</span>
      <span class="p">,</span> <span class="n">number1</span>
      <span class="p">,</span> <span class="n">number2</span>
      <span class="p">,</span> <span class="n">number3</span>
      <span class="p">,</span> <span class="n">number4</span>
      <span class="p">,</span> <span class="n">number5</span>
      <span class="p">,</span> <span class="n">number6</span>
      <span class="p">,</span> <span class="n">number7</span>
      <span class="p">,</span> <span class="n">number8</span>
      <span class="p">)</span></code></pre></figure>

<p>Mimochodem, entice v Elmu mohou mít maximálně devět prvků. Při překročení tohoto počtu dostaneme chybové hlášení. Obecně vzato, pro uložení více než tří hodnot různého typu je lepší použít kolektor <a href="record.html" target="_blank">record</a>(záznam). Elm povoluje víc než tři hodnoty v entici, protože se vzácně mohou vyskytnout případy, kdy uložení více než tří různých hodnot je výhodnější v entici než v záznamu.</p>

<p>Mohli bychom se ptát, proč se typ pro <code class="highlighter-rouge">( 1, 2 )</code> zobrazí jako <code class="highlighter-rouge">(number, number1)</code> a ne <code class="highlighter-rouge">(number, number)</code>. Konec konců, číslice <code class="highlighter-rouge">1</code> a <code class="highlighter-rouge">2</code> jsou obě stejného typu: <code class="highlighter-rouge">number</code>.  Připomeňme si, že v Elmu jsou dva typy čísel: <code class="highlighter-rouge">Float</code> a <code class="highlighter-rouge">Int</code>. Protože typové označení <code class="highlighter-rouge">(number, number)</code> používá tutéž proměnnou, mohlo by to znamenat, že naše entice by musela mít dvě hodnoty téhož typu - buď dvakrát <code class="highlighter-rouge">Int</code> nebo dvakrát <code class="highlighter-rouge">Float</code>.  Označením typu pomocí dvou proměnných <code class="highlighter-rouge">(number, number1)</code> nám dává Elm možnost mít jednu hodnotu typu <code class="highlighter-rouge">Float</code> a jednu typu <code class="highlighter-rouge">Int</code>, pokud bychom si to přáli. Existují čtyři možné sady hodnot, které může entice s typovým označením <code class="highlighter-rouge">(number, number1)</code> obsahovat:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="n">number</span><span class="p">,</span> <span class="n">number1</span> <span class="p">)</span>

<span class="o">&gt;</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="n">number</span><span class="p">,</span> <span class="kt">Float</span> <span class="p">)</span>

<span class="o">&gt;</span> <span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="kt">Float</span><span class="p">,</span> <span class="n">number</span> <span class="p">)</span>

<span class="o">&gt;</span> <span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="kt">Float</span><span class="p">,</span> <span class="kt">Float</span> <span class="p">)</span></code></pre></figure>

<p>Připomeňme si, že číslice <code class="highlighter-rouge">1</code> a <code class="highlighter-rouge">2</code> mohou být považovány buď za <code class="highlighter-rouge">Int</code> nebo za <code class="highlighter-rouge">Float</code> v závislosti na jejich použití. Proto nevidíme typové označení číslic <code class="highlighter-rouge">(1, 2.0)</code> jako <code class="highlighter-rouge">(Int, Float)</code>. Použitím typů <code class="highlighter-rouge">(number, Float)</code> zachovává Elm možnost budoucího použítí čísla <code class="highlighter-rouge">1</code> buď jako <code class="highlighter-rouge">Int</code> nebo jako <code class="highlighter-rouge">Float</code>.<br> Takto vypadá typové označení entice, obsahující dva řetězce:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">(</span> <span class="s">"Bunny"</span><span class="p">,</span> <span class="s">"Uli"</span> <span class="p">)</span>
<span class="p">(</span><span class="s">"Bunny"</span><span class="p">,</span><span class="s">"Uli"</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">String</span> <span class="p">)</span></code></pre></figure>

<p>Aby byly entice Elmu stejného typu, musí obsahovat stejný počet hodnot stejného typu. Entice <code class="highlighter-rouge">( 1, 2 )</code> a <code class="highlighter-rouge">( 1, 2, 3 )</code> jsou různého typu. Stejně tak <code class="highlighter-rouge">( 1, 2 )</code> a <code class="highlighter-rouge">( "Bunny", "Uli" )</code>. 
Tudíž, pokusíme-li se vložit dvě entice různých délek se stejnými typy hodnot do seznamu, obdržíme chybové hlášení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">[</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">),</span> <span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">]</span>

<span class="c1">-------------------------- TYPE MISMATCH --------------------------</span>
<span class="kt">The</span> <span class="mi">1</span><span class="n">st</span> <span class="n">and</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">entries</span> <span class="kr">in</span> <span class="n">this</span> <span class="n">list</span> <span class="n">are</span> <span class="n">different</span> <span class="n">types</span> <span class="kr">of</span> <span class="n">values</span><span class="o">.</span>

<span class="mi">3</span><span class="o">|</span>   <span class="p">[</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">),</span> <span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">]</span>
                 <span class="o">^^^^^^^^^^^</span>
<span class="kt">The</span> <span class="mi">1</span><span class="n">st</span> <span class="n">entry</span> <span class="n">has</span> <span class="n">this</span> <span class="kr">type</span><span class="o">:</span>

    <span class="p">(</span> <span class="n">number</span><span class="p">,</span> <span class="n">number1</span> <span class="p">)</span>

<span class="kt">But</span> <span class="n">the</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">is</span><span class="o">:</span>

    <span class="p">(</span> <span class="n">number</span><span class="p">,</span> <span class="n">number1</span><span class="p">,</span> <span class="n">number2</span> <span class="p">)</span></code></pre></figure>

<h3 id="record-type">Typ Record</h3>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Big Lebowski"</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">=</span> <span class="mi">1998</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Big Lebowski"</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">=</span> <span class="mi">1998</span> <span class="p">}</span>
    <span class="o">:</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">:</span> <span class="n">number</span> <span class="p">}</span></code></pre></figure>

<p>Stejně jako u <code class="highlighter-rouge">entice</code>, nemá Elm rovněž typové jméno pro záznam (record). Proto jej repl opisuje výpisem <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">name</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">String,</span><span class="w"> </span><span class="err">releaseYear</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">number</span><span class="w"> </span><span class="p">}</span></code>, v němž se konstatuje, že hodnota u popisku <code class="highlighter-rouge">name</code> je typu <code class="highlighter-rouge">String</code> a hodnota u popisku <code class="highlighter-rouge">releaseYear</code> je typu <code class="highlighter-rouge">number</code>. Jak jsme si říkali v sekci <a href="record.html#creating-a-record" target="_blank">Record</a>, můžeme pro pojmenování existujícího záznamu použít <code class="highlighter-rouge">alias typu</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">type</span> <span class="n">alias</span> <span class="kt">Movie</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">:</span> <span class="kt">Int</span> <span class="p">}</span></code></pre></figure>

<p>Sousloví <code class="highlighter-rouge">type alias</code> přidává jméno existujícímu typu. <code class="highlighter-rouge">Movie</code> není nový typ. Je to nově přiřazené jméno (alias) k typovému opisu záznamu  <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">name</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">String,</span><span class="w"> </span><span class="err">releaseYear</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="p">}</span></code>. Později si ukážeme, jak definovat své vlastní typy. Sousloví <code class="highlighter-rouge">type alias</code> rovněž vytváří funkci pro tvorbu záznamů (records) za kulisami. Tuto konstruktorovou funkci můžeme použit k vytvoření záznamu takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Movie</span> <span class="s">"The Big Lebowski"</span> <span class="mi">1998</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Big Lebowski"</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">=</span> <span class="mi">1998</span> <span class="p">}</span> <span class="o">:</span> <span class="kt">Repl</span><span class="o">.</span><span class="kt">Movie</span></code></pre></figure>

<p class="info">Pokud si nepamatujete, jak konstruktorová funkce pracuje, v sekci <a href="record.html#record-constructor-function" target="_blank">Record</a> naleznete pěkné ilustrativní zobrazení.</p>

<p>Nyní má typ označení <code class="highlighter-rouge">Repl.Movie</code> místo popisu <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">name</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">String,</span><span class="w"> </span><span class="err">releaseYear</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="p">}</span></code>. Všechny aliasy typu a uživatelské typy, definované uvnitř replu, jsou prefixovány slovem <code class="highlighter-rouge">Repl</code> - což je název modulu, reprezentujícího repl samotný.</p>

<h3 id="function-type">Typ Function</h3>

<p>Funkce rovněž deklarují své typové vybavení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">addOne</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span></code></pre></figure>

<p>Definovali jsme funkci <code class="highlighter-rouge">addOne</code>, která přijímá jeden argument typu <code class="highlighter-rouge">number</code> a rovněž vrací hodnotu typu <code class="highlighter-rouge">number</code>. Její typ je tedy popsán jako <code class="highlighter-rouge">number -&gt; number</code>.</p>

<p><img src="/images/type-system/function-type.png" alt="" /></p>

<p>Zapisujeme-li definici funkce do souboru, je vhodné rovněž uvádět popis jejího typu. Přidejte následující definici funkce hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">addOne</span> <span class="o">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span>
<span class="n">addOne</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>


<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p><img src="/images/type-system/function-type-annotation.png" alt="" /></p>

<p>Typy parametru a výstupní hodnoty jsou odděleny šipkou <code class="highlighter-rouge">-&gt;</code>. Typovou anotaci jsme dosud u žádné funkce neprováděli. Jak mohl Elm správně určit typy parametrů a výstupních hodot bez anotace typu funkce? Proto, že umí odvozovat (infer) typy podle operací, které se uvnitř funkce provádějí. Ve funkci <code class="highlighter-rouge">addOne</code> jsme použili operátor <code class="highlighter-rouge">+</code>, který jako funkce má následující anotaci:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span></code></pre></figure>

<p>Přijímá dvě hodnoty typu number a vrací hodnotu typu number. Parametr <code class="highlighter-rouge">x</code> ve funkci <code class="highlighter-rouge">addOne</code> musí byt typu <code class="highlighter-rouge">number</code> aby byly uspokojeny typové požadavky operátoru<code class="highlighter-rouge">+</code>. Tato automatická dedukce typů je známa jako <em>inference typu</em>. Tuto inferenci Elm při vyhodnocování našeho kódu extenzivně používá, takže my nemusíme typ každičké hodnoty deklarovat. <br>
Podívejte se na několik příkladů inference typu v replu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">divideByTwo</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>

<span class="o">&gt;</span> <span class="n">divideByTwo</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">//</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<p>Když použijeme operátor prostého (floating-point) dělení (<code class="highlighter-rouge">/</code>), je typ funkce <code class="highlighter-rouge">divideByTwo</code> vydedukován jako <code class="highlighter-rouge">Float -&gt; Float</code>, když ale použijeme operátor celočíselného dělení (<code class="highlighter-rouge">//</code>), který odsekává vše za desetinnou čárkou, má inference tvar <code class="highlighter-rouge">Int -&gt; Int</code>.</p>

<p>Doposud jsme posuzovali funkce, které používají pouze jeden operátor. Napišme poněkud složitější funkci a pátrejme zda bude Elm rovněž schopen inferovat její typ. Přidejte následující definici funkce hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">guardiansWithShortNames</span> <span class="n">guardians</span> <span class="o">=</span>
    <span class="n">guardians</span>
        <span class="o">|&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="kt">String</span><span class="o">.</span><span class="n">length</span>
        <span class="o">|&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">length</span>


<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Anotaci typu funkce <code class="highlighter-rouge">guardiansWithShortNames</code> jsme neprovedli, protože chceme aby to za nás provedl Elm. Pohleďme, co nám ukáže repl:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">guardiansWithShortNames</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">List</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<p>První operace, kterou aplikujeme na parametr <code class="highlighter-rouge">guardians</code> pomáhá Elmu určit jeho typ. Aby mohla funkce <code class="highlighter-rouge">List.map</code> aplikovat funkci <code class="highlighter-rouge">String.length</code> na každý element v seznamu, musejí být tyto prvky typu <code class="highlighter-rouge">String</code>. Proto vidíme anotaci <code class="highlighter-rouge">List String</code> jako typ parametru  <code class="highlighter-rouge">guardians</code>. Podobným způsobem určí Elm typ vratné hodnoty funkce podle poslední provedené operace. V prezentovaném příkadě to je funkce <code class="highlighter-rouge">List.length</code>, která vrací hodnotu typu <code class="highlighter-rouge">Int</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">length</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<p>Proto Elm dedukuje, že funkce <code class="highlighter-rouge">guardiansWithShortNames</code> rovněž vrací hodnotu typu <code class="highlighter-rouge">Int</code>. Když Elm provádí automatickou inferenci typů, proč potřebujeme psát anotaci typu nad každou deklaraci funkce? Z těchto dobrých důvodů:</p>

<ul>
  <li>Anotace je zároveň dokumentací funkce</li>
  <li>Umožňuje ověření kódu</li>
  <li>Limituje typy hodnot, které může funkce přijmout</li>
</ul>

<h4 id="providing-documentation">Dokumentace funkce</h4>

<p>Pro člověka je často obtížné odvodit typy parametrů a vratné hodnoty pouze ze zápisu funkce. Tento problém lze také řešit přidáním komentáře nad každou funkci:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cm">{- Takes a list of strings and
   returns an integer value
-}</span>
<span class="n">guardiansWithShortNames</span> <span class="n">guardians</span> <span class="o">=</span>
    <span class="n">guardians</span>
        <span class="o">|&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="kt">String</span><span class="o">.</span><span class="n">length</span>
        <span class="o">|&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">length</span></code></pre></figure>

<p>Tyto statické komentáře jsou pouze tak dobré, jak dobrá je schopnost jejich autora dobře formulovat. Mohou také ztratit smysl, když se někdo rozhodne změnit funkci a zapomene změnit komentář. Lepší alternativou je použití anotace typu, která nikdy neztratí smysl, protože pokud se kód neshoduje s anotací typu, vyvolá kompilátor Elmu chybové hlášení.<br>
Přidejte následující anotaci hned nad definici funkce <code class="highlighter-rouge">guardiansWithShortNames</code> v souboru <code class="highlighter-rouge">Playground.elm</code></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">guardiansWithShortNames</span> <span class="o">:</span> <span class="kt">List</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<h4 id="enabling-code-validation">Ověření kódu</h4>

<p>Elm nám může pomoci při hledání chyb v našem kódu porovnáním anotace typu se skutečným kódem. Řekněme, že chceme napsat funkci,která sčítá dvě čísla. Po jistém experimentování jsme došli k závěru, že anotací typu funkce by mohl být zápis:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span></code></pre></figure>

<p>Přidejte následující definici funkce hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span>
<span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">++</span> <span class="n">y</span>


<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p class="info">Funkci s názvem <code class="highlighter-rouge">add</code> jsme definovali již v sekci <a href="function.html#backward-function-application" target="_blank">Functions</a>. Pokud tuto definici máte stále v souboru <code class="highlighter-rouge">Playground.elm</code>, směle ji smažte. Jinak dostaneme chybu duplikátní definice.</p>

<p>Když zkusíme evokovat funkci <code class="highlighter-rouge">add</code> v replu, dostaneme následující chybové sdělení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span>

<span class="o">======================</span> <span class="kt">ERRORS</span> <span class="o">========================</span>
<span class="c1">------------------- TYPE MISMATCH --------------------</span>
<span class="kt">The</span> <span class="n">left</span> <span class="n">argument</span> <span class="kr">of</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="n">is</span> <span class="n">causing</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">mismatch</span><span class="o">.</span>

<span class="mi">330</span><span class="o">|</span>     <span class="n">x</span> <span class="o">++</span> <span class="n">y</span>
         <span class="o">^</span>
<span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="n">is</span> <span class="n">expecting</span> <span class="n">the</span> <span class="n">left</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">be</span> <span class="n">a</span><span class="o">:</span>

    <span class="n">appendable</span>

<span class="kt">But</span> <span class="n">the</span> <span class="n">left</span> <span class="n">argument</span> <span class="n">is</span><span class="o">:</span>

    <span class="n">number</span>

<span class="kt">Hint</span><span class="o">:</span> <span class="kt">Only</span> <span class="n">strings</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">and</span> <span class="n">lists</span> <span class="n">are</span> <span class="n">appendable</span><span class="o">.</span></code></pre></figure>

<p>V anotaci typu jsme deklarovali, že funkce <code class="highlighter-rouge">add</code> přijímá dva číselné argumenty, ale náš kód očekává, že naše argumenty jsou <code class="highlighter-rouge">appendable</code> (připojítelné). Označení  <code class="highlighter-rouge">appendable</code> je proměnná typu, která může reprezentovat seznam, řetězec nebo text, což jsou jediné typy, které může Elm spojovat dohromady s použitím operátoru <code class="highlighter-rouge">++</code>. Omylem jsme zapsali <code class="highlighter-rouge">++</code> místo  <code class="highlighter-rouge">+</code>. Kdybychom nepřipojili anotaci typu, Elm by spokojeně akceptoval definici funkce <code class="highlighter-rouge">add</code> a odvodil by si její anotaci ve tvaru:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="n">appendable</span> <span class="o">-&gt;</span> <span class="n">appendable</span> <span class="o">-&gt;</span> <span class="n">appendable</span></code></pre></figure>

<p>Což není to, co chceme. Bez váhání zaměňte <code class="highlighter-rouge">++</code> za <code class="highlighter-rouge">+</code> v definici funkce <code class="highlighter-rouge">add</code> aby se její implementace shodovala s anotací jejího typu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span>
<span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span></code></pre></figure>

<h4 id="limiting-types-of-values-a-function-can-accept">Omezení akceptovaných typů hodnot </h4>

<p>Řekněme že chceme aby naše funkce <code class="highlighter-rouge">add</code> přijímala pouze celočíselné hodnoty. Upravte její anotaci v souboru <code class="highlighter-rouge">Playground.elm</code> takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<p>Když se nyní pokusíme sečíst dvě desetinná (float) čísla, vyvolá kompilátor chybové hlášení:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">add</span> <span class="mf">1.5</span> <span class="mf">2.3</span>

<span class="c1">-------------------- TYPE MISMATCH ----------------------</span>
<span class="kt">The</span> <span class="mi">1</span><span class="n">st</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">function</span> <span class="p">`</span><span class="n">add</span><span class="p">`</span> <span class="n">is</span> <span class="n">causing</span> <span class="n">a</span> <span class="n">mismatch</span><span class="o">.</span>

<span class="mi">4</span><span class="o">|</span>   <span class="n">add</span> <span class="mf">1.5</span> <span class="mf">2.3</span>
         <span class="o">^^^</span>
<span class="kt">Function</span> <span class="p">`</span><span class="n">add</span><span class="p">`</span> <span class="n">is</span> <span class="n">expecting</span> <span class="n">the</span> <span class="mi">1</span><span class="n">st</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">be</span><span class="o">:</span>

    <span class="kt">Int</span>

<span class="kt">But</span> <span class="n">it</span> <span class="n">is</span><span class="o">:</span>

    <span class="kt">Float</span>

<span class="kt">Hint</span><span class="o">:</span> <span class="kt">Elm</span> <span class="n">does</span> <span class="n">not</span> <span class="n">automatically</span> <span class="n">convert</span> <span class="n">between</span> <span class="kt">Ints</span> <span class="n">and</span>
<span class="kt">Floats</span><span class="o">.</span> <span class="kt">Use</span> <span class="p">`</span><span class="n">toFloat</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="n">round</span><span class="p">`</span> <span class="n">to</span> <span class="kr">do</span> <span class="n">specific</span> <span class="n">conversions</span><span class="o">.</span>
<span class="o">&lt;</span><span class="n">http</span><span class="o">://</span><span class="n">package</span><span class="o">.</span><span class="n">elm</span><span class="o">-</span><span class="n">lang</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">packages</span><span class="o">/</span><span class="n">elm</span><span class="o">-</span><span class="n">lang</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">latest</span><span class="o">/</span><span class="kt">Basics</span><span class="o">#</span><span class="n">toFloat</span><span class="o">&gt;</span></code></pre></figure>

<p>Bez anotace typu bychom nebyli schopni omezit argumenty na hodnoty typu <code class="highlighter-rouge">Int</code>.</p>

<h4 id="type-annotation-with-multiple-parameters">Anotace typu s více parametry</h4>

<p>Anotace typu pro funkci s více paramtery může být na první pohled matoucí.</p>

<p><img src="images/multiple-params-type-annotation.png" alt="" /></p>

<p>Typ návratové hodnoty je od parametrů oddělen šipkou <code class="highlighter-rouge">-&gt;</code>. Parametry samotné jsou rovněž oddělený šipkou <code class="highlighter-rouge">-&gt;</code>. Nemáme žádné vizuální vodítko pro určení, kde parametry končí a kde začíná typ návratové hodnoty. Abychom pochopili, proč anotace typu používá řadu šipek, potřebujeme nejprve pochopit princip práce funkce v Elmu.</p>

<p>V sekci <a href="function.html#partial-function-application" target="_blank"> Částečná aplikace funkce</a> jsme se dozvěděli, že když nedodáme normální fukci dostatečný počet argumentů, dostáváme místo chybového hlášení částečně aplikovanou funkci.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="o">:</span> <span class="kt">Int</span>

<span class="o">&gt;</span> <span class="n">add</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<p>Zadáme-li fukci <code class="highlighter-rouge">add</code> pouze první argument, vrací funkci, která za scénou vypadá nějak takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">addPartiallyApplied</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">addPartiallyApplied</span> <span class="n">y</span> <span class="o">=</span>
    <span class="mi">1</span> <span class="o">+</span> <span class="n">y</span></code></pre></figure>

<p>Parametr <code class="highlighter-rouge">x</code> byl nahrazen hodnotou <code class="highlighter-rouge">1</code> a nyní se očekává, že zadáme druhý argument. Přiřaďme nejprve částečně aplikovanou funkci konstantě:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">addPartiallyApplied</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<p>Nyní můžeme aplikovat <code class="highlighter-rouge">addPartiallyApplied</code> na hodnotu <code class="highlighter-rouge">2</code> a dostaneme konečný výsledek.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">addPartiallyApplied</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="o">:</span> <span class="kt">Int</span></code></pre></figure>

<p>Zpočátku vypadala funkce <code class="highlighter-rouge">add</code> jako funkce, která přijímá dva argumenty a vrací hodnotu typu <code class="highlighter-rouge">Int</code>, avšak po pečlivém zkoumání jsme zjistili, že funkce ve skutečnosti přijala pouze jeden argument a vracela částečně aplikovanou funkci. Všechny funkce v Elmu pracují tímto způsobem bez ohledu na to, kolik argumentů se zdají přijímat. S touto nově nalezenou znalostí můžeme přepsat anotaci funkce <code class="highlighter-rouge">add</code> takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span></code></pre></figure>

<p><img src="/images/type-system/curried-function.png" alt="" /></p>

<p>Protože závorky naznačují funkci, můžeme každou jednotlivou funkci vložit do vlastních závorek:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">))</span></code></pre></figure>

<p>Ovšem, všechny tyto závorky jsou v Elmu nepovinné, takže anotace typu lze zapsat mnohem čistěji. V našem případě takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span></code></pre></figure>

<p>Tento proces přeměny funkce s více argumenty na posloupnost funkcí s jedním argumentem se nazývá <em>currying</em>. To je ta technika, která nám umožňuje používat směrníkový operátor  <code class="highlighter-rouge">|&gt;</code>. Zde je příklad, který jsme viděli v sekci <a href="function.html#forward-function-application" target="_blank">Function</a>:</p>

<p><img src="images/pipe-operator.png" alt="" /></p>

<p class="info">Nyní když víme, co je anotace typu, budeme ji přidávat ke všem funkcím, které budeme při výkladu vkládat do zdrojového souboru.</p>

<h3 id="exercise-461">Cvičení 4.6.1</h3>

<p>Vraťte se k souboru <code class="highlighter-rouge">Playground.elm</code> a přidejte anotace typu ke všem funkcím. Potom je všechny prověřte v replu. Napříkad pro operátor ++:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">add</span> <span class="mi">2</span> <span class="mi">4</span></code></pre></figure>

<p>V replu můžete vidět obšírný výpis typových prohřešků. Můžete si také všimnout, že Elm očekává několik typů hodnot, o kterých jsme dosud nehovořili, jako <code class="highlighter-rouge">Order</code> a <code class="highlighter-rouge">Html.Html.msg</code>. Půvabné na Elmu je to, že i když vám říká jaký přesně typ hodnoty očekává, můžete dokončit cvičení i když nejste se všemi typy obeznámeni.</p>

<h3 id="creating-our-own-types">Vytvoření vlastního typu</h3>

<p>Dosud jsme používali pouze typy, poskytované Elmem ale někdy nejsou tyto typy pro námi zamýšlené účely postačující. V Elmu máme možnost si vytvořit typy vlastní. Viz příklad:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">type</span> <span class="kt">Greeting</span> <span class="o">=</span> <span class="kt">Howdy</span></code></pre></figure>

<p>Definovali jsme nový typ, nazvaný <code class="highlighter-rouge">Greeting</code>. Tento typ má jedinou možnou hodnotu: <code class="highlighter-rouge">Howdy</code>. 
Stejně jako u vestavěných typů, musí i jména uživatelských typů začínat velkým písmenem.</p>

<p><img src="images/custom-type-with-one-value.png" alt="" /></p>

<p>Podívejme se, co dostaneme, když v replu zapíšeme <code class="highlighter-rouge">Howdy</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Howdy</span>
<span class="kt">Howdy</span> <span class="o">:</span> <span class="kt">Repl</span><span class="o">.</span><span class="kt">Greeting</span></code></pre></figure>

<p>Dle očekávání, typ je veden jako <code class="highlighter-rouge">Greeting</code>. Co se stane, když zapíšeme slovo <code class="highlighter-rouge">Greeting</code> samotné?</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Greeting</span>

<span class="c1">-------- NAMING ERROR ---------</span>
<span class="kt">Cannot</span> <span class="n">find</span> <span class="n">variable</span> <span class="p">`</span><span class="kt">Greeting</span><span class="p">`</span>

<span class="mi">4</span><span class="o">|</span>   <span class="kt">Greeting</span>
     <span class="o">^^^^^^^^</span></code></pre></figure>

<p>Dostali jsme 'naming error' (chybu pojmenování). Stejnou chybu dostaneme při zápisu jiného typu z Elmu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">String</span>

<span class="c1">-------- NAMING ERROR -------</span>
<span class="kt">Cannot</span> <span class="n">find</span> <span class="n">variable</span> <span class="p">`</span><span class="kt">String</span><span class="p">`</span>

<span class="mi">4</span><span class="o">|</span>   <span class="kt">String</span>
     <span class="o">^^^^^^</span></code></pre></figure>

<p>Jak se ukazuje, nemá velký smysl zapisovat názvy typů do replu. Je to proto, že se od nás očekává zadání platného výrazu.
As it turns out, it doesn’t make sense to input a type into the repl. That’s because we’re supposed to enter a valid expression. <code class="highlighter-rouge">Howdy</code>, <code class="highlighter-rouge">1</code> a <code class="highlighter-rouge">"Walter"</code> jsou hodoty a všechny hodnoty jsou platnými výrazy. Proto se nám při jejich zápisu do replu nevrací chybové hlášení. Na druhé straně, slova jako <code class="highlighter-rouge">Greeting</code>, <code class="highlighter-rouge">Int</code> a <code class="highlighter-rouge">String</code> jsou jména, která reprezentují kategorie hodnot, nikoliv hodnoty samé.</p>

<p>Uživatelské typy nejsou omezeny pouze na jednu hodnotu. Můžeme jich zadat kolik chceme. Rozšiřme typ <code class="highlighter-rouge">Greeting</code> o další hodnotu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">type</span> <span class="kt">Greeting</span> <span class="o">=</span> <span class="kt">Howdy</span> <span class="o">|</span> <span class="kt">Hola</span></code></pre></figure>

<p><img src="/images/type-system/custom-type-with-two-values.png" alt="" /></p>

<p>Nyní má <code class="highlighter-rouge">Greeting</code> dvě možné hodnoty: <code class="highlighter-rouge">Howdy</code> a <code class="highlighter-rouge">Hola</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Howdy</span>
<span class="kt">Howdy</span> <span class="o">:</span> <span class="kt">Repl</span><span class="o">.</span><span class="kt">Greeting</span>

<span class="o">&gt;</span> <span class="kt">Hola</span>
<span class="kt">Hola</span> <span class="o">:</span> <span class="kt">Repl</span><span class="o">.</span><span class="kt">Greeting</span></code></pre></figure>

<p>Definice typu <code class="highlighter-rouge">Greeting</code>je podobná definici vestavěného typu <code class="highlighter-rouge">Bool</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span></code></pre></figure>

<h4 id="using-custom-types">Použítí uživatelských typů</h4>

<p>Pojďme se podívat, jak můžeme použít typ <code class="highlighter-rouge">Greeting</code> v našem kódu. Následující kód přidejte hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>, umístěném v adresáři <code class="highlighter-rouge">beginning-elm/elm-examples</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>


<span class="n">sayHello</span> <span class="o">:</span> <span class="kt">Greeting</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">sayHello</span> <span class="n">greeting</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">greeting</span> <span class="kr">of</span>
        <span class="kt">Howdy</span> <span class="o">-&gt;</span>
            <span class="s">"How y'all doin'?"</span>

        <span class="kt">Hola</span> <span class="o">-&gt;</span>
            <span class="s">"Hola amigo!"</span></code></pre></figure>

<p>Uživatelský typ se často užívá s výrazem case pro nalezení shody mezi vzorem (pattern match) a hodnotou typu. Při nalezení shody se vyhodnotí příslušný výraz. Na používání uživatelského typu není nic speciálního. Nativní typ Elmu <code class="highlighter-rouge">Bool</code> může být rovněž používán podobným způsobem.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">welcomeMessage</span> <span class="o">:</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">welcomeMessage</span> <span class="n">isLoggedIn</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">isLoggedIn</span> <span class="kr">of</span>
        <span class="kt">True</span> <span class="o">-&gt;</span>
            <span class="s">"Welcome to my awesome site!"</span>

        <span class="kt">False</span> <span class="o">-&gt;</span>
            <span class="s">"Please log in."</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">sayHello</code> přijímá jeden argument typu <code class="highlighter-rouge">Greeting</code>. Je-li hodnotou <code class="highlighter-rouge">Howdy</code>, dojde k opravdové Texanské interakci. Je-li hodnotou <code class="highlighter-rouge">Hola</code>, vrací funkce "Nazdar příteli!" španělsky. Importujme funkci <code class="highlighter-rouge">sayHello</code> do replu a použijme ji k pozdravení cizince:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Playground</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">sayHello</span> <span class="kt">Howdy</span>
<span class="s">"How y'all doin'?"</span> <span class="o">:</span> <span class="kt">String</span>

<span class="o">&gt;</span> <span class="n">sayHello</span> <span class="kt">Hola</span>
<span class="s">"Hola amigo!"</span> <span class="o">:</span> <span class="kt">String</span></code></pre></figure>

<p>Zobrazí-li se vám následující chyba, restartuje seanci <code class="highlighter-rouge">elm-repl</code>. Typ <code class="highlighter-rouge">Greeting</code> jsme definovali nejprve v replu. Později, když jsme jej definovali také v souboru <code class="highlighter-rouge">Playground.elm</code>, přijímá repl matoucí instrukce - odtud chybové hlášení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="c1">------------------- TYPE MISMATCH -------------------------</span>
<span class="kt">The</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">function</span> <span class="p">`</span><span class="n">sayHello</span><span class="p">`</span> <span class="n">is</span> <span class="n">causing</span> <span class="n">a</span> <span class="n">mismatch</span><span class="o">.</span>

<span class="mi">6</span><span class="o">|</span>   <span class="n">sayHello</span> <span class="kt">Howdy</span>
              <span class="o">^^^^^</span>
<span class="kt">Function</span> <span class="p">`</span><span class="n">sayHello</span><span class="p">`</span> <span class="n">is</span> <span class="n">expecting</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">be</span><span class="o">:</span>

    <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span>

<span class="kt">But</span> <span class="n">it</span> <span class="n">is</span><span class="o">:</span>

    <span class="kt">Repl</span><span class="o">.</span><span class="kt">Greeting</span></code></pre></figure>

<p>Při psaní kódu do souboru je vhodné zalamovat definici uživatelského typu tak, že každá hodnota je uvedena na vlastním řádku. Do této konfigurace si beztak <code class="highlighter-rouge">elm-format</code> přeformátuje náš zápis do souboru ve tvaru  <code class="highlighter-rouge">type Greeting = Howdy | Hola</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span></code></pre></figure>

<p>Naproti tomu při zapisování kódu do replu není zalamování textu do jednotlivých řádků až tak výhodné, protože se konec řádku musí explicitně označovat zpětným lomítkem, což je práce navíc.</p>

<h4 id="the-difference-between-type-and-type-alias">Rozdíl  mezi <code class="highlighter-rouge">type</code> a <code class="highlighter-rouge">type alias</code></h4>

<p>Je důležité zdůraznit, že <code class="highlighter-rouge">type</code> a <code class="highlighter-rouge">type alias</code> jsou dva různé koncepty. Procedura <code class="highlighter-rouge">type</code> vytváří <em>nový typ</em>, zatímco <code class="highlighter-rouge">type alias</code> dává jméno <em>existujícímu typu</em>. Příklad pro <code class="highlighter-rouge">type alias</code> jsme již viděli výše. Zde jej uvádíme znovu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">type</span> <span class="n">alias</span> <span class="kt">Movie</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">:</span> <span class="kt">Int</span> <span class="p">}</span></code></pre></figure>

<p>Přiřadili jsme <code class="highlighter-rouge">Movie</code> jako jméno k typu <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">name</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">String,</span><span class="w"> </span><span class="err">releaseYear</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="p">}</span></code> abychom mohli stručným způsobem vytvořit záznam o filmu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Movie</span> <span class="s">"The Big Lebowski"</span> <span class="mi">1998</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Big Lebowski"</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">=</span> <span class="mi">1998</span> <span class="p">}</span> <span class="o">:</span> <span class="kt">Repl</span><span class="o">.</span><span class="kt">Movie</span></code></pre></figure>

<p>Zde je jiný příklad z modulu <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Time" target="_blank">Time</a>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Time</span> <span class="o">=</span>
    <span class="kt">Float</span></code></pre></figure>

<p>Různé funkce v modulu <code class="highlighter-rouge">Time</code> akceptují čas jako desetinné číslo. Aby bylo jasnější, že tyto funkce přijímají časový údaj jako vstup, byl vytvořen alias <code class="highlighter-rouge">Time</code>. Aliasy typu nám usnadňují psaní stručných kódů.<br>
Řekněme, že chceme napsat funkci, která nám sdělí, zda byl nějaký film uveden do kin f roce <code class="highlighter-rouge">2016</code>, či nikoli:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">releasedIn2016</span> <span class="o">:</span> <span class="kt">Movie</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">releasedIn2016</span> <span class="n">movie</span> <span class="o">=</span>
    <span class="n">movie</span><span class="o">.</span><span class="n">releaseYear</span> <span class="o">==</span> <span class="mi">2016</span></code></pre></figure>

<p>Kdybychom nevytvořili alias typu <code class="highlighter-rouge">Movie</code>, anotace typu by vypadala takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">releasedIn2016</span> <span class="o">:</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">releaseYear</span> <span class="o">:</span> <span class="kt">Int</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">releasedIn2016</span> <span class="n">movie</span> <span class="o">=</span>
    <span class="n">movie</span><span class="o">.</span><span class="n">releaseYear</span> <span class="o">==</span> <span class="mi">2016</span></code></pre></figure>

<p>Je obtížné podle anotace typu poznat, jakou informaci funkce  <code class="highlighter-rouge">releasedIn2016</code> očekává. Použijeme-li však alias typu, umíme říci, že očekává záznam <code class="highlighter-rouge">Movie</code>. Jak se naše aplikace rozrůstá, mají naše datové struktury tendenci být stále složitější. S pojmenováním těchto datových struktur můžeme psát kód mnohem přehlednější, bez ztráty všech výhod, plynoucích z typového systému.</p>

<h4 id="custom-types-with-payload">Uživatelské typy s payloadem</h4>

<p>Elm usnadňuje popisování složitých datových stuktur také tím, že nám umožňuje přidávat užitný obsah (payload) k hodnotám v uživatelském typu. Abychom pochopili, co to je payload, přidáme nějaké další možnosti do našeho uživatelského typu. Upravte typ <code class="highlighter-rouge">Greeting</code> a funkci <code class="highlighter-rouge">sayHello</code> v souboru <code class="highlighter-rouge">Playground.elm</code> takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>
    <span class="o">|</span> <span class="kt">Namaste</span> <span class="kt">String</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span>


<span class="n">sayHello</span> <span class="o">:</span> <span class="kt">Greeting</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">sayHello</span> <span class="n">greeting</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">greeting</span> <span class="kr">of</span>
        <span class="kt">Howdy</span> <span class="o">-&gt;</span>
            <span class="s">"How y'all doin'?"</span>

        <span class="kt">Hola</span> <span class="o">-&gt;</span>
            <span class="s">"Hola amigo!"</span>

        <span class="kt">Namaste</span> <span class="n">message</span> <span class="o">-&gt;</span>
            <span class="n">message</span>

        <span class="kt">NumericalHi</span> <span class="n">value1</span> <span class="n">value2</span> <span class="o">-&gt;</span>
            <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span> <span class="o">|&gt;</span> <span class="n">toString</span></code></pre></figure>

<p>Přidali jsme dvě další možnosti pro vytvoření hodnoty typu <code class="highlighter-rouge">Greeting</code>. Položka <code class="highlighter-rouge">Namaste</code> nám umožňuje pozdravit <a href="https://en.wikipedia.org/wiki/Nepali_language" target="_blank">v nepálštině</a> a <code class="highlighter-rouge">NumericalHi</code> nám umožní pozdravit matematiky. Na rozdíl od <code class="highlighter-rouge">Howdy</code> a <code class="highlighter-rouge">Hola</code>, <code class="highlighter-rouge">Namaste</code> a <code class="highlighter-rouge">NumericalHi</code> nejsou hodnotami. Pouze poskytují možnost vytvoření hodnot (či dat). Proto se jim také říká <em>datové konstruktory</em>. Podívejme se co dostaneme, když je zapíšeme do replu:</p>
<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Namaste</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span>

<span class="o">&gt;</span> <span class="kt">NumericalHi</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span></code></pre></figure>

<p>Apropos, datové konstruktory jsou vlastně funkce za scénou. Přijímají payload jako argument a vytvářejí hodnoty typu <code class="highlighter-rouge">Greeting</code>. V případě <code class="highlighter-rouge">Namaste</code> je payload tvořen řetězcem ale payload pro <code class="highlighter-rouge">NumericalHi</code> zahrnuje dvě hodnoty typu <code class="highlighter-rouge">Int</code>. Počet dat a typů v payloadu není omezen.</p>

<p><code class="highlighter-rouge">Namaste</code> a <code class="highlighter-rouge">NumericalHi</code> jsou jako funkce tím, že musejí být aplikovány na argumenty uvnitř svých payloadů aby vytvořily konkretní hodnoty.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Namaste</span> <span class="s">"Tapailai kasto cha?"</span>
<span class="kt">Namaste</span> <span class="s">"Tapailai kasto cha?"</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span>

<span class="o">&gt;</span> <span class="kt">NumericalHi</span> <span class="mi">1</span> <span class="mi">4</span>
<span class="kt">NumericalHi</span> <span class="mi">1</span> <span class="mi">4</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span></code></pre></figure>

<p class="info"><em>"Tapailai kasto cha?"</em> znamená <em>"Jak se máš?"</em> v nepálštině.</p>

<p>Je důležité mít na vědomí, že se datové konstruktory nechovají jako normální funkce, pokud se týče provádění operací na datech. Jsou to spíše krabičky, do nichž data ukládáme. Proto také, když do replu napíšeme <code class="highlighter-rouge">NumericalHi 1 4</code>, vrátí nám totéž zpět. Celý tento výraz <code class="highlighter-rouge">NumericalHi 1 4</code> je považován za hodnotu typu <code class="highlighter-rouge">Greeting</code>.</p>

<p><img src="images/custom-type-payload.png" alt="" /></p>

<p>Protože <code class="highlighter-rouge">Howdy</code> a <code class="highlighter-rouge">Hola</code> žádný payload nepřijímají, nemusejí být jejich hodnoty konstruovány. Jejich hodnoty jsou již ustanoveny, což z nich vpodstatě činí konstanty. Proto nám je repl neprezentuje jako funkce.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Howdy</span>
<span class="kt">Howdy</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span>

<span class="o">&gt;</span> <span class="kt">Hola</span>
<span class="kt">Hola</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span></code></pre></figure>

<p>Způsob, kterým jsme použili <code class="highlighter-rouge">Namaste</code> a <code class="highlighter-rouge">NumericalHi</code> ve funkci <code class="highlighter-rouge">sayHello</code>, je velmi podobný  použití <code class="highlighter-rouge">Howdy</code> a <code class="highlighter-rouge">Hola</code>. Jediný rozdíl je ten, že jsme použili argumenty v payloadu k vytvoření příslušných odpovědí.</p>

<p>I když se <code class="highlighter-rouge">Howdy</code> a <code class="highlighter-rouge">Hola</code> chovají jako konstanty, jsou někdy označovány jako <em>nulární datové konstruktory</em>. Nulární konstruktor je konstruktor, který nepřijímá žádné argumenty.</p>

<h3 id="union-types">Sdružený typ</h3>

<p>Uživatelský typ <code class="highlighter-rouge">Greeting</code>, který jsme v předchozí části vytvořili, má v Elmu své označení, nazývá se <em>sdružený (union) typ</em>. Všechny uživatelské typy, vytvořené s použitím klíčového slova <code class="highlighter-rouge">type</code>, se nazývají sdružené typy. Také se jim někdy říká <em>tagged unions</em> nebo <em>algebraické datové typy (ADTs)</em>.</p>

<p>Termín <em>union</em> (sjednocení, sdružení) je odvozen z teorie množin - odvětví matematiky, zabývající se kolekcemi jasně odlišených objektů, neboli množin. Množina může obsahovat cokoliv si můžeme představit: čísla, lidi, auta, filmy, národy, barvy, atd.
Mějme dvě číselné množiny:</p>

<p><img src="images/sets-of-numbers.png" alt="" /></p>

<p>Sjednocení (union) těchto dvou množin vypadá nějak takto:</p>

<p><img src="images/set-union.png" alt="" /></p>

<p>Všimněte si, že sjednocení obsahuje pouze jednu <code class="highlighter-rouge">3</code> a nikoliv dvě. Každý prvek ve sjednocené množině musí být unikátní. Jiný způsob zobrazení sjednocení dvou množin je pomocí Vennova diagramu:</p>

<p><img src="images/set-union-venn-diagram.png" alt="" /></p>

<p>Nemají-li dvě množiny žádné prvky společné, nazývají se disjointní (nesouvisející) množiny a jejich spojení (union) se nazývá disjointní sjednocení (<em>disjoint union</em>).</p>

<p><img src="images/disjoint-set-union.png" alt="" /></p>

<p><img src="images/disjoint-union-venn-diagram.png" alt="" /></p>

<p>V disjointním sjednocení je vždy možné určit, odkud jednotlivý element pochází. Například můžeme říci, že <code class="highlighter-rouge">2</code> pochází z množiny <code class="highlighter-rouge">A</code> s <code class="highlighter-rouge">4</code> z množiny <code class="highlighter-rouge">B</code>. Mají-li dvě množiny některé elementy společné, je vždy možné z nich vytvořit disjointní sjednocení tím, že se elementy v obou množinách různě označí.</p>

<p><img src="images/tagged-disjoint-union-set.png" alt="" /></p>

<p>Množiny <code class="highlighter-rouge">X</code> a <code class="highlighter-rouge">Y</code> nejsou disjointní, protože mají společný prvek <code class="highlighter-rouge">3</code>. 
Abychom vytvořili disjointní sjednocení, musíme nejprve přeměnit množiny <code class="highlighter-rouge">X</code> a <code class="highlighter-rouge">Y</code> na disjointní množiny označením každého jejich prvku. Označení (tagging) z nich dělá množiny disjointní, protože písmeno <code class="highlighter-rouge">X</code> je odlišné od písmene <code class="highlighter-rouge">Y</code>, byť číslo <code class="highlighter-rouge">3</code> je v obou případech stejné. <!--
We can tag an element by creating a pair whose first element is the name of the set where the second element came from.--> X<sup>*</sup> a Y<sup>*</sup> jsou disjointní množiny, které obsahují označené (tagged) elementy množin <code class="highlighter-rouge">X</code> a <code class="highlighter-rouge">Y</code>.</p>

<p>Sdružený typ v Elmu se podobá disjointnímu sjednocení množin označených prvků. Napříkad, typ <code class="highlighter-rouge">Greeting</code> lze chápat jako disjointní sjednocení čtyř množin:</p>

<ul>
  <li>Množina, obsahující <code class="highlighter-rouge">Howdy</code> jako svůj jediný element.</li>
  <li>Množina, obsahující  <code class="highlighter-rouge">Hola</code> jako svůj jediný element.</li>
  <li>Množina, obsahujicí nekonečný počet řetězců, označených slovem <code class="highlighter-rouge">Namaste</code>.</li>
  <li>Množina, obsahující nekonečný počet dvojic typu <code class="highlighter-rouge">Int</code>, označených slovem <code class="highlighter-rouge">NumericalHi</code>.</li>
</ul>

<p><img src="images/type-as-disjoint-union-set.png" alt="" /></p>

<p>Třetí množina, obsahující elementy s označením <code class="highlighter-rouge">Namaste</code>, vypadá takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">{</span> <span class="p">(</span><span class="kt">Namaste</span> <span class="s">"a"</span><span class="p">),</span> <span class="p">(</span><span class="kt">Namaste</span> <span class="s">"b"</span><span class="p">),</span> <span class="p">(</span><span class="kt">Namaste</span> <span class="s">"aaramai?"</span><span class="p">),</span> <span class="o">...</span> <span class="p">}</span></code></pre></figure>

<p>Celkový počet elementů v této množině je roven celkovému počtu jedinečných řetězců, jež můžeme v Elmu vytvořit - jenž je nekonečný. Podobně vypadá čtvrtá množina, obsahující elementy, označené slovem <code class="highlighter-rouge">NumericalHi</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">{</span> <span class="p">(</span><span class="kt">NumericalHi</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="kt">NumericalHi</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="kt">Numerical</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">),</span> <span class="o">...</span> <span class="p">}</span></code></pre></figure>

<p>Celkový počet elementů v této množině je roven dvojnásobku počtu hodnot typu <code class="highlighter-rouge">Int</code>, jež můžeme vytvořit v Elmu, což je velmi velké číslo.  Typ <code class="highlighter-rouge">Greeting</code> reprezentuje každičký element ve všech čtyřech výše uvedených množinách. <br>
Nyní tedy již víte, proč se uživatelské typy v Elmu nazývají  <em>sdružené </em> typy.</p>

<h4 id="duplicate-tags">Duplikátní tagy</h4>

<p>Každé označení (tag) v typu musí být unikátní. Přidejte duplikátní tag k typu <code class="highlighter-rouge">Greeting</code> v souboru <code class="highlighter-rouge">Playground.elm</code> takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>
    <span class="o">|</span> <span class="kt">Namaste</span> <span class="kt">String</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kt">Int</span></code></pre></figure>

<p>Nyní zkuste zapsat <code class="highlighter-rouge">NumericalHi</code> v replu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">NumericalHi</span>

<span class="c1">------------------- DUPLICATE DEFINITION -------------------</span>
<span class="kt">Naming</span> <span class="n">multiple</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">values</span> <span class="p">`</span><span class="kt">NumericalHi</span><span class="p">`</span> <span class="n">makes</span> <span class="n">things</span>
<span class="n">ambiguous</span><span class="o">.</span> <span class="kt">When</span> <span class="n">you</span> <span class="n">say</span> <span class="p">`</span><span class="kt">NumericalHi</span><span class="p">`</span> <span class="n">which</span> <span class="n">one</span> <span class="kr">do</span> <span class="n">you</span> <span class="n">want</span><span class="o">?</span>

<span class="mi">228</span><span class="o">|&gt;</span><span class="kr">type</span> <span class="kt">Greeting</span>
<span class="mi">229</span><span class="o">|&gt;</span>    <span class="o">=</span> <span class="kt">Howdy</span>
<span class="mi">230</span><span class="o">|&gt;</span>    <span class="o">|</span> <span class="kt">Hola</span>
<span class="mi">231</span><span class="o">|&gt;</span>    <span class="o">|</span> <span class="kt">Namaste</span> <span class="kt">String</span>
<span class="mi">232</span><span class="o">|&gt;</span>    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span>
<span class="mi">233</span><span class="o">|&gt;</span>    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kt">Int</span>

<span class="kt">Find</span> <span class="n">all</span> <span class="n">the</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">values</span> <span class="n">named</span> <span class="p">`</span><span class="kt">NumericalHi</span><span class="p">`</span> <span class="n">and</span> <span class="kr">do</span> <span class="n">some</span>
<span class="n">renaming</span><span class="o">.</span> <span class="kt">Make</span> <span class="n">sure</span> <span class="n">the</span> <span class="n">names</span> <span class="n">are</span> <span class="n">distinct</span><span class="o">!</span></code></pre></figure>

<p>Jak můžete vidět, je Elm duplikátní definicí zmaten, protože označení <code class="highlighter-rouge">NumericalHi</code> je vlastně funkce za scénou a my nemůžeme mít dvě funkce stejného jména v témže jmenném prostoru (scope). Elm nám také brání vytvořit dvě různé hodnoty se stejným tagem v témže scopu. Odeberte duplikátní označení <code class="highlighter-rouge">NumericalHi</code> z typu <code class="highlighter-rouge">Greeting</code> a definujte nový typ, zvaný <code class="highlighter-rouge">Salutation</code> hned nad typem <code class="highlighter-rouge">Greeting</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Salutation</span>
    <span class="o">=</span> <span class="kt">Aloha</span>
    <span class="o">|</span> <span class="kt">Howdy</span></code></pre></figure>

<p>Nový typ <code class="highlighter-rouge">Salutation</code> rovněž obsahuje <code class="highlighter-rouge">Howdy</code> jako jednu ze svých označení. Zkusme zapsat <code class="highlighter-rouge">Howdy</code> do replu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Howdy</span>

<span class="c1">---------------- DUPLICATE DEFINITION -----------------</span>
<span class="kt">Naming</span> <span class="n">multiple</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">values</span> <span class="p">`</span><span class="kt">Howdy</span><span class="p">`</span> <span class="n">makes</span> <span class="n">things</span>
<span class="n">ambiguous</span><span class="o">.</span> <span class="kt">When</span> <span class="n">you</span> <span class="n">say</span> <span class="p">`</span><span class="kt">Howdy</span><span class="p">`</span> <span class="n">which</span> <span class="n">one</span> <span class="kr">do</span> <span class="n">you</span> <span class="n">want</span><span class="o">?</span>

<span class="mi">228</span><span class="o">|&gt;</span><span class="kr">type</span> <span class="kt">Salutation</span>
<span class="mi">229</span><span class="o">|&gt;</span>    <span class="o">=</span> <span class="kt">Aloha</span>
<span class="mi">230</span><span class="o">|&gt;</span>    <span class="o">|</span> <span class="kt">Howdy</span>

<span class="kt">Find</span> <span class="n">all</span> <span class="n">the</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">values</span> <span class="n">named</span> <span class="p">`</span><span class="kt">Howdy</span><span class="p">`</span> <span class="n">and</span> <span class="kr">do</span> <span class="n">some</span>
<span class="n">renaming</span><span class="o">.</span> <span class="kt">Make</span> <span class="n">sure</span> <span class="n">the</span> <span class="n">names</span> <span class="n">are</span> <span class="n">distinct</span><span class="o">!</span></code></pre></figure>

<p>Elm je opět zmaten. Odeberte definici typu <code class="highlighter-rouge">Salutation</code> ze souboru <code class="highlighter-rouge">Playground.elm</code>. Jednou z velkých výhod používání sdružených typů v Elmu je to, že nás kompilátor donutí zabývat se všemi případy procedury case. Například, když ve funkci <code class="highlighter-rouge">sayHello</code> vypustíme byť jen jeden případ z typu <code class="highlighter-rouge">Greeting</code>, kompilátor si bude stěžovat. Odeberte kód pro hodnotu <code class="highlighter-rouge">NumericalHi</code> z funkce <code class="highlighter-rouge">sayHello</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">sayHello</span> <span class="o">:</span> <span class="kt">Greeting</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">sayHello</span> <span class="n">greeting</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">greeting</span> <span class="kr">of</span>
        <span class="kt">Howdy</span> <span class="o">-&gt;</span>
            <span class="s">"How y'all doin'?"</span>

        <span class="kt">Hola</span> <span class="o">-&gt;</span>
            <span class="s">"Muy bien, gracias."</span>

        <span class="kt">Namaste</span> <span class="n">message</span> <span class="o">-&gt;</span>
            <span class="n">message</span></code></pre></figure>

<p>Když nyní v replu zadáme funkci <code class="highlighter-rouge">sayHello</code>, dostaneme následující chybové hlášení:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">sayHello</span>

<span class="o">=======================</span> <span class="kt">ERRORS</span> <span class="o">===========================</span>
<span class="c1">------------------ MISSING PATTERNS ----------------------</span>

<span class="kt">This</span> <span class="p">`</span><span class="kr">case</span><span class="p">`</span> <span class="n">does</span> <span class="n">not</span> <span class="n">have</span> <span class="n">branches</span> <span class="n">for</span> <span class="n">all</span> <span class="n">possibilities</span><span class="o">.</span>

<span class="mi">236</span><span class="o">|&gt;</span>    <span class="kr">case</span> <span class="n">greeting</span> <span class="kr">of</span>
<span class="mi">237</span><span class="o">|&gt;</span>        <span class="kt">Howdy</span> <span class="o">-&gt;</span>
<span class="mi">238</span><span class="o">|&gt;</span>            <span class="s">"How y'all doin'?"</span>
<span class="mi">239</span><span class="o">|&gt;</span>
<span class="mi">240</span><span class="o">|&gt;</span>        <span class="kt">Hola</span> <span class="o">-&gt;</span>
<span class="mi">241</span><span class="o">|&gt;</span>            <span class="s">"Muy bien, gracias."</span>
<span class="mi">242</span><span class="o">|&gt;</span>
<span class="mi">243</span><span class="o">|&gt;</span>        <span class="kt">Namaste</span> <span class="n">message</span> <span class="o">-&gt;</span>
<span class="mi">244</span><span class="o">|&gt;</span>            <span class="n">message</span>

<span class="kt">You</span> <span class="n">need</span> <span class="n">to</span> <span class="n">account</span> <span class="n">for</span> <span class="n">the</span> <span class="n">following</span> <span class="n">values</span><span class="o">:</span>

    <span class="kt">Playground</span><span class="o">.</span><span class="kt">NumericalHi</span> <span class="kr">_</span> <span class="kr">_</span>

<span class="kt">Add</span> <span class="n">a</span> <span class="n">branch</span> <span class="n">to</span> <span class="n">cover</span> <span class="n">this</span> <span class="n">pattern</span><span class="o">!</span></code></pre></figure>

<p>Kompilátor Elmu je jako přátelský pomocník, který nás jemně informuje, když uděláme chybu. Vděčíme za to mocnému typovému systému v Elmu, jenž činí jeho kompilátor tak bystrým. Vraťte se do zdrojového souboru a vraťte kód pro hodnotu <code class="highlighter-rouge">NumericalHi</code> zpět do funkce <code class="highlighter-rouge">sayHello</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kt">NumericalHi</span> <span class="n">value1</span> <span class="n">value2</span> <span class="o">-&gt;</span>
    <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span> <span class="o">|&gt;</span> <span class="n">toString</span></code></pre></figure>

<h3 id="type-constructor">Typový konstruktor</h3>

<p>V sekci <a href="function-composition.html#improving-inputs" target="_blank">Ripple-Carry Adder</a> jsme se setkai s touto definicí:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Maybe</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Just</span> <span class="n">a</span>
    <span class="o">|</span> <span class="kt">Nothing</span></code></pre></figure>

<p><code class="highlighter-rouge">Maybe</code> je vestavěný typ Elmu, který nám umožňuje vyjádřit koncept chybějící hodnoty. Často si nejsme jisti zda hodnota, po které se pídíme, skutečně existuje. Snažíme-li se například vyjmout desátý prvek z arraye, který má jenom pět elementů, dostaneme <code class="highlighter-rouge">Nothing</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Array</span>

<span class="o">&gt;</span> <span class="n">myArray</span> <span class="o">=</span> <span class="kt">Array</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">]</span>
<span class="kt">Array</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">:</span> <span class="kt">Array</span><span class="o">.</span><span class="kt">Array</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="kt">Array</span><span class="o">.</span><span class="n">get</span> <span class="mi">10</span> <span class="n">myArray</span>
<span class="kt">Nothing</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="n">number</span></code></pre></figure>

<p>Místo chybového hlášení nebo kolapsu programu vrací funkce <code class="highlighter-rouge">get</code> hodnotu typu <code class="highlighter-rouge">Maybe</code>. Takto vypadá anotace funkce <code class="highlighter-rouge">get</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">get</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Array</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span></code></pre></figure>

<p>Podobně jako <code class="highlighter-rouge">List</code> a <code class="highlighter-rouge">Array</code> je <code class="highlighter-rouge">Maybe</code> kontejner, který však může obsahovat nejvíc jednu hodnotu. Tato hodnota může být libovolného typu. Pro vytvoření hodnoty typu <code class="highlighter-rouge">Maybe</code> musíme použít buď datový konstruktor <code class="highlighter-rouge">Just</code> nebo konstantu <code class="highlighter-rouge">Nothing</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="n">a</span>

<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">5</span>
<span class="kt">Just</span> <span class="mi">5</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">"Andre the Giant"</span>
<span class="kt">Just</span> <span class="s">"Andre the Giant"</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="kt">String</span>

<span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">List</span> <span class="n">number</span><span class="p">)</span></code></pre></figure>

<p>Na rozdíl od našeho typu <code class="highlighter-rouge">Greeting</code>, není <code class="highlighter-rouge">Maybe</code> samo o sobě platným typem. Pouze nám poskytuje možnost vytvořit typ. Proto je označován jako  <em>konstruktor typu</em>. Aby generoval platný typ, musí být aplikován na jiný typový argument. <code class="highlighter-rouge">Maybe Int</code>, <code class="highlighter-rouge">Maybe String</code>, <code class="highlighter-rouge">Maybe (List number)</code> jsou všechno platné typy.</p>

<p><img src="images/type-constructor.png" alt="" /></p>

<p>Generické (neboli parametrizované) typy jako <code class="highlighter-rouge">Maybe a</code> mohou být neuvěřitelně účinné. Všechno, co potřebujeme pro vytváření vlastních generických typů, je zadat argument typovému konstruktoru. Námi vytvořený typ <code class="highlighter-rouge">Greeting</code> není generickým typem.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>
    <span class="o">|</span> <span class="kt">Namaste</span> <span class="kt">String</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span></code></pre></figure>

<p>Datové konstruktory, které vytvoří hodnotu typu <code class="highlighter-rouge">Greeting</code> očekávají, že jejich payloady jsou určitého typu. Položka <code class="highlighter-rouge">Namaste</code> vyžaduje aby její payload byl typu <code class="highlighter-rouge">String</code> a <code class="highlighter-rouge">NumericalHi</code> vyžaduje dvě hodnoty typu <code class="highlighter-rouge">Int</code>. Upravte definici typu <code class="highlighter-rouge">Greeting</code> v souboru <code class="highlighter-rouge">Playground.elm</code> tak aby přijímal typový argument.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>
    <span class="o">|</span> <span class="kt">Namaste</span> <span class="n">a</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span></code></pre></figure>

<p>Nyní, když můžeme zadávat typový argument do typu <code class="highlighter-rouge">Greeting</code>, není datový konstruktor <code class="highlighter-rouge">Namaste</code> omezen pouze na jeden typ. Přijímá payload libovolného typu.  Předtím, než vyzkoušíme následující příklady, změňte text funkce <code class="highlighter-rouge">sayHello</code> včetně anotace jejího typu na komentář (proveďte její odznačení). Jinak obdržíte chybová hlášení. Tuto funkci upravíme později.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Namaste</span> <span class="mi">5</span>
<span class="kt">Namaste</span> <span class="mi">5</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="kt">Namaste</span> <span class="s">"aaramai?"</span>
<span class="kt">Namaste</span> <span class="s">"aaramai?"</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span> <span class="kt">String</span>

<span class="o">&gt;</span> <span class="kt">Namaste</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
<span class="kt">Namaste</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span> <span class="p">(</span><span class="kt">List</span> <span class="n">number</span><span class="p">)</span></code></pre></figure>

<p>Signatura typu se rovněž změnila.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Namaste</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span> <span class="n">a</span></code></pre></figure>

<p>Před přidáním typového argumentu to bylo takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Namaste</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Greeting</span></code></pre></figure>

<p>Všimněte si, že jsme typový argument  <code class="highlighter-rouge">a</code> použili pouze u <code class="highlighter-rouge">Namaste</code>, nikoli u <code class="highlighter-rouge">NumericalHi</code>. Nechce se od nás, abychom zadávali typový argument všem datovým konstruktorům. Ve skutečnosti je dokonce nemusíme zadávat žádnému datovému konstruktoru. Následující definice typu je v Elmu zcela platná. Upravte definici typu <code class="highlighter-rouge">Greeting</code> následovně:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>
    <span class="o">|</span> <span class="kt">Namaste</span> <span class="kt">String</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span></code></pre></figure>

<p>Typový argument, který není použit v žádnem z datových konstruktorů, je znám jako <em>fantomový typový argument</em>. 
Pro existenci fantomových typových argumentů jsou legitimní důvody ale jejich vysvětlení je mimo rámec této knihy.</p>

<p>Protože jsou <code class="highlighter-rouge">Greeting</code> a <code class="highlighter-rouge">Greeting a</code> dva rozdílné typy, potřebujeme upravit anotaci typu u funkce <code class="highlighter-rouge">sayHello</code>. Zrušte odznačení funkce <code class="highlighter-rouge">sayHello</code> a upravte anotaci jejího typu takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">sayHello</span> <span class="o">:</span> <span class="kt">Greeting</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">String</span></code></pre></figure>

<p>V definici funkce potřebujeme změnit pouze anotaci typu, nikoliv část <code class="highlighter-rouge">sayHello greeting =</code>, protože parametr <code class="highlighter-rouge">greeting</code> funkce jednoduše zahrnuje jakoukoli hodnotu typu <code class="highlighter-rouge">Greeting a</code>.<br>

 Jiný úhel pohledu dostaneme, změníme-li naši definici typu na <code class="highlighter-rouge">type Welcome a</code>. Potom musíme změnit anotaci typu na <code class="highlighter-rouge">sayHello : Welcome a -&gt; String</code>, 
 ale můžeme přitom ponechat naši definici funkce ve tvaru <code class="highlighter-rouge">sayHello greeting =</code>. Anotace typu je agent, který spojuje hodnotu, uloženou v parametru funkce se správným typem, nikoliv se jménem parametru funkce, jímž může být cokoliv si přejeme. Než se posuneme dále, vraťme definici typu <code class="highlighter-rouge">Greeting</code> zpět na:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>
    <span class="o">|</span> <span class="kt">Namaste</span> <span class="n">a</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span></code></pre></figure>

<p>Jediná věc která se změnila, je to že datový konstruktor <code class="highlighter-rouge">Namaste</code> vyžaduje aby jeho payload byl typu <code class="highlighter-rouge">a</code> místo <code class="highlighter-rouge">String</code>. Když nyní v replu zkusíme zadat <code class="highlighter-rouge">sayHello</code>, dostaneme následující chybové hlášení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">sayHello</span>

<span class="o">====================================</span> <span class="kt">ERRORS</span> <span class="o">====================================</span>
<span class="c1">-------------------------------- TYPE MISMATCH ---------------------------------</span>

<span class="kt">The</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">and</span> <span class="mi">3</span><span class="n">rd</span> <span class="n">branches</span> <span class="kr">of</span> <span class="n">this</span> <span class="p">`</span><span class="kr">case</span><span class="p">`</span> <span class="n">produce</span> <span class="n">different</span> <span class="n">types</span> <span class="kr">of</span> <span class="n">values</span><span class="o">.</span>

<span class="mi">233</span><span class="o">|</span>     <span class="kr">case</span> <span class="n">greeting</span> <span class="kr">of</span>
<span class="mi">234</span><span class="o">|</span>         <span class="kt">Howdy</span> <span class="o">-&gt;</span>
<span class="mi">235</span><span class="o">|</span>             <span class="s">"How y'all doin'?"</span>
<span class="mi">236</span><span class="o">|</span>
<span class="mi">237</span><span class="o">|</span>         <span class="kt">Hola</span> <span class="o">-&gt;</span>
<span class="mi">238</span><span class="o">|</span>             <span class="s">"Muy bien, gracias."</span>
<span class="mi">239</span><span class="o">|</span>
<span class="mi">240</span><span class="o">|</span>         <span class="kt">Namaste</span> <span class="n">message</span> <span class="o">-&gt;</span>
<span class="mi">241</span><span class="o">|&gt;</span>            <span class="n">message</span>
<span class="mi">242</span><span class="o">|</span>
<span class="mi">243</span><span class="o">|</span>         <span class="kt">NumericalHi</span> <span class="n">value1</span> <span class="n">value2</span> <span class="o">-&gt;</span>
<span class="mi">244</span><span class="o">|</span>             <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span> <span class="o">|&gt;</span> <span class="n">toString</span>

<span class="kt">The</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">branch</span> <span class="n">has</span> <span class="n">this</span> <span class="kr">type</span><span class="o">:</span>

    <span class="kt">String</span>

<span class="kt">But</span> <span class="n">the</span> <span class="mi">3</span><span class="n">rd</span> <span class="n">is</span><span class="o">:</span>

    <span class="n">a</span>

<span class="kt">Hint</span><span class="o">:</span> <span class="kt">Your</span> <span class="kr">type</span> <span class="n">annotation</span> <span class="n">uses</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a</span><span class="p">`</span> <span class="n">which</span> <span class="n">means</span> <span class="n">any</span> <span class="kr">type</span> <span class="kr">of</span> <span class="n">value</span>
<span class="n">can</span> <span class="n">flow</span> <span class="n">through</span><span class="o">.</span> <span class="kt">Your</span> <span class="n">code</span> <span class="n">is</span> <span class="n">saying</span> <span class="n">it</span> <span class="kt">CANNOT</span> <span class="n">be</span> <span class="n">anything</span> <span class="n">though</span><span class="o">!</span> <span class="kt">Maybe</span> <span class="n">change</span>
<span class="n">your</span> <span class="kr">type</span> <span class="n">annotation</span> <span class="n">to</span> <span class="n">be</span> <span class="n">more</span> <span class="n">specific</span><span class="o">?</span> <span class="kt">Maybe</span> <span class="n">the</span> <span class="n">code</span> <span class="n">has</span> <span class="n">a</span> <span class="n">problem</span><span class="o">?</span> <span class="kt">More</span> <span class="n">at</span><span class="o">:</span>
<span class="o">&lt;</span><span class="n">https</span><span class="o">://</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">elm</span><span class="o">-</span><span class="n">lang</span><span class="o">/</span><span class="n">elm</span><span class="o">-</span><span class="n">compiler</span><span class="o">/</span><span class="n">blob</span><span class="o">/</span><span class="mf">0.18</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="n">hints</span><span class="o">/</span><span class="kr">type</span><span class="o">-</span><span class="n">annotations</span><span class="o">.</span><span class="n">md</span><span class="o">&gt;</span>

<span class="kt">Hint</span><span class="o">:</span> <span class="kt">All</span> <span class="n">branches</span> <span class="kr">in</span> <span class="n">a</span> <span class="p">`</span><span class="kr">case</span><span class="p">`</span> <span class="n">must</span> <span class="n">have</span> <span class="n">the</span> <span class="n">same</span> <span class="kr">type</span><span class="o">.</span> <span class="kt">So</span> <span class="n">no</span> <span class="n">matter</span> <span class="n">which</span> <span class="n">one</span>
<span class="n">we</span> <span class="n">take</span><span class="p">,</span> <span class="n">we</span> <span class="n">always</span> <span class="n">get</span> <span class="n">back</span> <span class="n">the</span> <span class="n">same</span> <span class="kr">type</span> <span class="kr">of</span> <span class="n">value</span><span class="o">.</span></code></pre></figure>

<p>Podle této chybové zprávy musí všechny větve vyrazu <code class="highlighter-rouge">case</code> vracet hodnotu stejného typu, my se však tímto pravidlem neřídíme. Vrací se nám hodnota typu <code class="highlighter-rouge">String</code> pro <code class="highlighter-rouge">Howdy</code>, <code class="highlighter-rouge">Hola</code> a <code class="highlighter-rouge">NumericalHi</code> a hodnota libovolného typu (reprezentovaná členem <code class="highlighter-rouge">a</code>) pro <code class="highlighter-rouge">Namaste</code>. Funkce v Elmu musejí vracet hodnotu pouze jednoho typu. Proto potřebujeme aby všechny větve vracely buď hodnotu typu <code class="highlighter-rouge">a</code> nebo <code class="highlighter-rouge">String</code>. Vraťme ještě jednou definici funkce do předchozího tvaru abychom se zbavili chyby:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Greeting</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Howdy</span>
    <span class="o">|</span> <span class="kt">Hola</span>
    <span class="o">|</span> <span class="kt">Namaste</span> <span class="kt">String</span>
    <span class="o">|</span> <span class="kt">NumericalHi</span> <span class="kt">Int</span> <span class="kt">Int</span></code></pre></figure>

<p>V této poslední podobě nepotřebuje typ <code class="highlighter-rouge">Greeting</code> žádný typový argument ale ponecháme jej tak, jak je. Pokud se vám nelíbí fantomové typové argumenty, směle jej smažte. Potom ale nezapomeňte také změnit anotaci typu pro funkci <code class="highlighter-rouge">sayHello</code>.</p>

<h4 id="multiple-type-arguments">Víceré typové argumenty</h4>

<p>Elm nám umožňuje míti víceré argumenty v definici typu. Zde je příklad:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Result</span> <span class="ne">error</span> <span class="n">value</span>
    <span class="o">=</span> <span class="kt">Ok</span> <span class="n">value</span>
    <span class="o">|</span> <span class="kt">Err</span> <span class="ne">error</span></code></pre></figure>

<p>Sejně jako <code class="highlighter-rouge">Maybe</code>, je <code class="highlighter-rouge">Result</code> další vestavěný typ v Elmu. Přijímá dva typové argumenty: <code class="highlighter-rouge">error</code> a <code class="highlighter-rouge">value</code>. Typ <code class="highlighter-rouge">Result</code> přijde vhod, když selže operace a my potřebujeme získat popis selhání v chybovém hlášení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">String</span><span class="o">.</span><span class="n">toInt</span> <span class="s">"1"</span>
<span class="kt">Ok</span> <span class="mi">1</span> <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="kt">String</span> <span class="kt">Int</span>

<span class="o">&gt;</span> <span class="kt">String</span><span class="o">.</span><span class="n">toInt</span> <span class="s">"a"</span>
<span class="kt">Err</span> <span class="s">"could not convert string 'a' to an Int"</span> <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="kt">String</span> <span class="kt">Int</span></code></pre></figure>

<p>Místo aby se náš program zhroutil, vrací funkce  <code class="highlighter-rouge">toInt</code> hodnotu z typu <code class="highlighter-rouge">Result</code> když ji zadáme neplatný vstup. Takto vypadá signatura typu funkce <code class="highlighter-rouge">toInt</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">toInt</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Result</span> <span class="kt">String</span> <span class="kt">Int</span></code></pre></figure>

<p>Abychom vytvořili hodnotu typu <code class="highlighter-rouge">Result</code>, musíme použít jeden z těchto datových konstruktorů: <code class="highlighter-rouge">Ok</code> a <code class="highlighter-rouge">Err</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Ok</span> <span class="mi">5</span>
<span class="kt">Ok</span> <span class="mi">5</span> <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="ne">error</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="kt">Ok</span> <span class="s">"Inigo Montoya"</span>
<span class="kt">Ok</span> <span class="s">"Inigo Montoya"</span> <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="ne">error</span> <span class="kt">String</span>

<span class="o">&gt;</span> <span class="kt">Ok</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
<span class="kt">Ok</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="ne">error</span> <span class="p">(</span><span class="kt">List</span> <span class="n">number</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="kt">Err</span> <span class="s">"Operation failed because you entered invalid data."</span>
<span class="kt">Err</span> <span class="s">"Operation failed because you entered invalid data."</span>
    <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="kt">String</span> <span class="n">value</span></code></pre></figure>

<p>Typ<code class="highlighter-rouge">Result</code> je poněkud expresivnější než <code class="highlighter-rouge">Maybe</code>. Místo získání pouhého <code class="highlighter-rouge">Nothing</code> můžeme vytvořit popisnou zprávu, která vysvětluje proč operace neuspěla. Přidejte následující funkci hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">signUp</span> <span class="o">:</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Result</span> <span class="kt">String</span> <span class="kt">String</span>
<span class="n">signUp</span> <span class="n">email</span> <span class="n">age</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="kt">String</span><span class="o">.</span><span class="n">toInt</span> <span class="n">age</span> <span class="kr">of</span>
        <span class="kt">Err</span> <span class="n">message</span> <span class="o">-&gt;</span>
            <span class="kt">Err</span> <span class="n">message</span>

        <span class="kt">Ok</span> <span class="n">age</span> <span class="o">-&gt;</span>
            <span class="kr">let</span>
                <span class="n">emailPattern</span> <span class="o">=</span>
                    <span class="kt">Regex</span><span class="o">.</span><span class="n">regex</span> <span class="s">"</span><span class="se">\\</span><span class="s">b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+</span><span class="se">\\</span><span class="s">.[A-Za-z]{2,}</span><span class="se">\\</span><span class="s">b"</span>

                <span class="n">isValidEmail</span> <span class="o">=</span>
                    <span class="kt">Regex</span><span class="o">.</span><span class="n">contains</span> <span class="n">emailPattern</span> <span class="n">email</span>
            <span class="kr">in</span>
                <span class="kr">if</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="mi">13</span> <span class="kr">then</span>
                    <span class="kt">Err</span> <span class="s">"You need to be at least 13 years old to sign up."</span>
                <span class="kr">else</span> <span class="kr">if</span> <span class="n">isValidEmail</span> <span class="kr">then</span>
                    <span class="kt">Ok</span> <span class="s">"Your account has been created successfully!"</span>
                <span class="kr">else</span>
                    <span class="kt">Err</span> <span class="s">"You entered an invalid email."</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">signUp</code> demonstruje, jak vytvořit a zacházet s hodnotami typu <code class="highlighter-rouge">Result</code> type. Přijímá jako vstup emailovou adresu a věk. Nejprve se pokouší konvertovat uživatelem zadaný věk z typu <code class="highlighter-rouge">String</code> na typ <code class="highlighter-rouge">Int</code>. Protože funkce <code class="highlighter-rouge">String.toInt</code> vrací hodnotu typu <code class="highlighter-rouge">Result</code>, potřebujeme použít výraz <code class="highlighter-rouge">case</code>, abychom podchytili scénář jak úspěchu, tak selhání. Je-li uživatel alespoň 13 roků stár a jeho emailová adresa je rovněž platná, vrátí se nám zpráva o úspěchu s označením  <code class="highlighter-rouge">Ok</code>, 
v opačném případě se vrátí příslušná chybová zpráva s označením <code class="highlighter-rouge">Err</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">signUp</span> <span class="s">"thedude@rubix.com"</span> <span class="s">"48"</span>
<span class="kt">Ok</span> <span class="s">"Your account has been created successfully!"</span>
    <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="kt">String</span> <span class="kt">String</span>

<span class="o">&gt;</span> <span class="n">signUp</span> <span class="s">"@sobchaksecurity.com"</span> <span class="s">"51"</span>
<span class="kt">Err</span> <span class="s">"You entered an invalid email."</span>
    <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="kt">String</span> <span class="kt">String</span>

<span class="o">&gt;</span> <span class="n">signUp</span> <span class="s">"walter@sobchaksecurity.com"</span> <span class="s">"11"</span>
<span class="kt">Err</span> <span class="s">"You need to be at least 13 years old to sign up."</span>
    <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="kt">String</span> <span class="kt">String</span>

<span class="o">&gt;</span> <span class="n">signUp</span> <span class="s">"bunny@jackietreehorn.com"</span> <span class="s">"aa"</span>
<span class="kt">Err</span> <span class="s">"could not convert string 'aa' to an Int"</span>
    <span class="o">:</span> <span class="kt">Result</span><span class="o">.</span><span class="kt">Result</span> <span class="kt">String</span> <span class="kt">String</span></code></pre></figure>

<p>Typy <code class="highlighter-rouge">Maybe</code> a <code class="highlighter-rouge">Result</code> spolu s typem <code class="highlighter-rouge">Task</code> (o kterém pohovoříme v <a href="tasks.html" target="_blank">kapitole 5</a>) poskytují robustní mechanizmus pro podchycení chyb při kompilaci. Z toho důvodu je velice vzácný výskyt chyby při běhu programu (runtime).</p>

<h3 id="type-vs-data-constructor">Typový vs datový konstruktor</h3>

<p>V této chvíli se můžete ptát, kde přesně se typové a datové konstruktory používají. Typové konstruktory se používají hlavně v deklaracích nebo anotacích typu, zatímco datové konstruktory se používají uvnitř těla funkce nebo když definujeme konstantu nejvyšší úrovně. <br> 
Řekněme, že chceme zjistit, který ze sourozenců Starka ze seriálu <a href="https://en.wikipedia.org/wiki/Game_of_Thrones" target="_blank">Game of Thrones</a> dosáhl dospělosti. Přidejte následující kód hned nad funkci  <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Character</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">String</span>
    <span class="p">,</span> <span class="n">age</span> <span class="o">:</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
    <span class="p">}</span>


<span class="n">sansa</span> <span class="o">:</span> <span class="kt">Character</span>
<span class="n">sansa</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Sansa"</span>
    <span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="kt">Just</span> <span class="mi">19</span>
    <span class="p">}</span>


<span class="n">arya</span> <span class="o">:</span> <span class="kt">Character</span>
<span class="n">arya</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Arya"</span>
    <span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="p">}</span>


<span class="n">getAdultAge</span> <span class="o">:</span> <span class="kt">Character</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="n">getAdultAge</span> <span class="n">character</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">character</span><span class="o">.</span><span class="n">age</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="o">-&gt;</span>
            <span class="kt">Nothing</span>

        <span class="kt">Just</span> <span class="n">age</span> <span class="o">-&gt;</span>
            <span class="kr">if</span> <span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">18</span> <span class="kr">then</span>
                <span class="kt">Just</span> <span class="n">age</span>
            <span class="kr">else</span>
                <span class="kt">Nothing</span></code></pre></figure>

<p>Definovali jsme záznam (record) zvaný <code class="highlighter-rouge">Character</code>, který obsahuje jméno a věk postavy.
that contains a character’s name and age. Konkretní typ <code class="highlighter-rouge">Maybe Int</code> je přiřazen k označení <code class="highlighter-rouge">age</code>, naznačující možnost, že postava nemusí prozradit svůj věk. Potom jsme vytvořili postavu <code class="highlighter-rouge">sansa</code> a postavu <code class="highlighter-rouge">arya</code>. Věk postavy <code class="highlighter-rouge">sansa</code> je v záznamu uveden jako <code class="highlighter-rouge">Just 19</code> ale věk postavy <code class="highlighter-rouge">arya</code> je veden jako <code class="highlighter-rouge">Nothing</code>, což znamená, že její věk není znám.</p>

<p>V probíraném příkladu jsme tedy narazili na jeden typový konstruktor (<code class="highlighter-rouge">Maybe</code>) a dva datové konstruktory (<code class="highlighter-rouge">Just</code> a <code class="highlighter-rouge">Nothing</code>). Konstruktor <code class="highlighter-rouge">Nothing</code> je víceméně konstanta ale my jej zde považujeme za nulární datový konstruktor. Protože je <code class="highlighter-rouge">Character</code> alias typu, není považován za skutečný typ. Jak vidíme, je typový konstruktor <code class="highlighter-rouge">Maybe</code> v záznamu použit jako deklarace typu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Character</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">String</span>
    <span class="p">,</span> <span class="n">age</span> <span class="o">:</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
    <span class="p">}</span></code></pre></figure>

<p>I když <code class="highlighter-rouge">Character</code> není skutečný typ, záznam <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">name</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">String,</span><span class="w"> </span><span class="err">age</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="err">Maybe</span><span class="w"> </span><span class="err">Int</span><span class="w"> </span><span class="p">}</span></code> jím je. Alias typu se obvykle vyskytuje spolu s typovým konstruktorem. Při vytváření skutečného záznamu, potřebujeme místo typového konstruktoru <code class="highlighter-rouge">Maybe</code> použít datový konstruktor <code class="highlighter-rouge">Just</code> nebo <code class="highlighter-rouge">Nothing</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">sansa</span> <span class="o">:</span> <span class="kt">Character</span>
<span class="n">sansa</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Sansa"</span>
    <span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="kt">Just</span> <span class="mi">19</span>
    <span class="p">}</span>


<span class="n">arya</span> <span class="o">:</span> <span class="kt">Character</span>
<span class="n">arya</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Arya"</span>
    <span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="p">}</span></code></pre></figure>

<p>Typový konstruktor <code class="highlighter-rouge">Maybe</code> se také vyskytuje v anotaci typu funkce <code class="highlighter-rouge">getAdultAge</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">getAdultAge</span> <span class="o">:</span> <span class="kt">Character</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span></code></pre></figure>

<p>Datové konstruktory <code class="highlighter-rouge">Just</code> a <code class="highlighter-rouge">Nothing</code> jsou použity uvnitř těla funkce pro vytvoření skutečných hodot typu <code class="highlighter-rouge">Maybe Int</code>. Jsou rovněž použity ve výrazu 'case' ke hledání shody vzoru s hodnotami uvnitř parametru <code class="highlighter-rouge">character.age</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">getAdultAge</span> <span class="n">character</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">character</span><span class="o">.</span><span class="n">age</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="o">-&gt;</span>
            <span class="kt">Nothing</span>

        <span class="kt">Just</span> <span class="n">age</span> <span class="o">-&gt;</span>
            <span class="kr">if</span> <span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">18</span> <span class="kr">then</span>
                <span class="kt">Just</span> <span class="n">age</span>
            <span class="kr">else</span>
                <span class="kt">Nothing</span></code></pre></figure>

<p>Popatřme, jak se zachová funkce <code class="highlighter-rouge">getAdultAge</code>, zadáme-li ji postavu s deklarovaným věkem.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">getAdultAge</span> <span class="n">sansa</span>
<span class="kt">Just</span> <span class="mi">19</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="kt">Int</span></code></pre></figure>

<p>V replu se nám datový konstruktor zobrazuje v obasti hodnoty, zatímco typový konstruktor se vyskytuje v oblasti anotace typu.</p>

<p><img src="images/value-and-type-annotation-areas.png" alt="" /></p>

<p>A což postava bez určeného věku?</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">getAdultAge</span> <span class="n">arya</span>
<span class="kt">Nothing</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="kt">Int</span></code></pre></figure>

<p>Podle očekávání jsme dostali <code class="highlighter-rouge">Nothing</code>. Vytvořme v replu tři další postavy, abychom více prozkoumali chování funkce  <code class="highlighter-rouge">getAdultAge</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">jonSnow</span> <span class="o">=</span> <span class="kt">Character</span> <span class="s">"Jon Snow"</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">21</span><span class="p">)</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Jon Snow"</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="kt">Just</span> <span class="mi">21</span> <span class="p">}</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Character</span>

<span class="o">&gt;</span> <span class="n">rickon</span> <span class="o">=</span> <span class="kt">Character</span> <span class="s">"Rickon"</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">11</span><span class="p">)</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Rickon"</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="kt">Just</span> <span class="mi">11</span> <span class="p">}</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Character</span>

<span class="o">&gt;</span> <span class="n">robb</span> <span class="o">=</span> <span class="kt">Character</span> <span class="s">"Robb"</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">18</span><span class="p">)</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Robb"</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="kt">Just</span> <span class="mi">18</span> <span class="p">}</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">Character</span></code></pre></figure>

<p>Co se stane, když funkci <code class="highlighter-rouge">getAdultAge</code> zadáme postavu s věkem menším než<code class="highlighter-rouge">18</code>?</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">getAdultAge</span> <span class="n">rickon</span>
<span class="kt">Nothing</span> <span class="o">:</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="kt">Int</span></code></pre></figure>

<p>Místo skutečného věku vrací funkce <code class="highlighter-rouge">getAdultAge</code> hodnotu <code class="highlighter-rouge">Nothing</code>, protože je navržena aby ignorovala věk nedospělých postav. Můžeme to využít k husarskému kousku: vytisknout věk pouze dospělých postav.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">filterMap</span> <span class="n">getAdultAge</span> <span class="p">[</span> <span class="n">sansa</span><span class="p">,</span> <span class="n">arya</span><span class="p">,</span> <span class="n">jonSnow</span><span class="p">,</span> <span class="n">rickon</span><span class="p">,</span> <span class="n">robb</span> <span class="p">]</span>
<span class="p">[</span><span class="mi">19</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="kt">Int</span></code></pre></figure>

<p>V Elmu můžeme usoudit chování funkce podle její anotace typu. Vyzkoušejme si to. Zadáme v replu <code class="highlighter-rouge">List.filterMap</code> a hle co dostáváme:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">filterMap</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span><span class="o">.</span><span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="n">b</span></code></pre></figure>

<p>Anotace typu nám říká, že funkce <code class="highlighter-rouge">filterMap</code> příjímá dva argumenty:</p>

<ul>
  <li>
    <p>Funkci, která indikuje, zda je či není určitá operace úspěšná pro daný vstup. Je-li úspěšná, vrací hodnotu zabalenou v <code class="highlighter-rouge">Just</code>, jinak vrací <code class="highlighter-rouge">Nothing</code>.</p>
  </li>
  <li>
    <p>Seznam hodnot typu <code class="highlighter-rouge">a</code>.</p>
  </li>
</ul>

<p>Konečně, funkce <code class="highlighter-rouge">filterMap</code> vrací seznam hodnot typu <code class="highlighter-rouge">b</code>. Ve většině případů však anotace typu nestačí pro představu o práci funkce. Na příklad, jedním z projevů funkce <code class="highlighter-rouge">filterMap</code>, nikoliv zřejmých z anotace typu je to, že funkce zavrhne všechy prvky původního seznamu, u kterých funkce <code class="highlighter-rouge">getAdultAge</code> vrací hodnoty <code class="highlighter-rouge">Nothing</code>. Vybírá potom hodnoty ze zbylých prvků <code class="highlighter-rouge">Just</code> a vkládá je do nového seznamu.</p>

<p><img src="images/filter-map-list.png" alt="" /></p>

<h3 id="recursive-types">Rekurzivní typy</h3>

<p>V sekci <a href="list.html#how-list-is-implemented" target="_blank">Jak je seznam implementován</a> jsme si říkali, že typ <code class="highlighter-rouge">List</code>je definován jako <em>rekurzivní typ</em>. V oné chvíli jsme toho o typech mnoho nevěděli, abychom byli schopni plně pochopit ideu rekurzivních typů. Nyní, když víme, co typy jsou, jsme v jiné situaci. Mějme seznam čísel <code class="highlighter-rouge">[ 16, 5, 31, 9 ]</code>. Za scénou je tento seznam (list) konstruován takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">[]</span>
<span class="kt">[]</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">a</span>

<span class="o">&gt;</span> <span class="mi">9</span> <span class="o">::</span> <span class="kt">[]</span>
<span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="mi">31</span> <span class="o">::</span> <span class="p">[</span> <span class="mi">9</span> <span class="p">]</span>
<span class="p">[</span><span class="mi">31</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="mi">5</span> <span class="o">::</span> <span class="p">[</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">9</span> <span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="mi">16</span> <span class="o">::</span> <span class="p">[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">9</span> <span class="p">]</span>
<span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="o">:</span> <span class="kt">List</span> <span class="n">number</span></code></pre></figure>

<p>Začali jsme prázdným seznamem a přidali jsme k němu <code class="highlighter-rouge">9</code> s použitím operátoru cons (<code class="highlighter-rouge">::</code>). Poté jsme pokračovali v postupném přidávání zbývajících elementů. V takovéto konstrukci můžeme vidět rekurzivní strukturu, vlastní všem seznamům:</p>

<p><img src="images/recursive-list-example.png" alt="" /></p>

<p>Z obrázku je patrné, že se seznam skládá z nodů, které samy o sobě jsou seznamy. To je to, co činí typ <code class="highlighter-rouge">List</code> typem rekurzivním. Vytvořme vlastní datovou strukturu, velice podobnou typu <code class="highlighter-rouge">List</code>, abychom lépe porozuměli, jak rekurzivní datové struktury pracují. Přidejte následující definici typu hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">MyList</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Empty</span>
    <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">MyList</span> <span class="n">a</span><span class="p">)</span>


 <span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Výše uvedená definice znamená, že seznam typu <code class="highlighter-rouge">MyList</code> může být buď <code class="highlighter-rouge">Empty</code> (prázdný) nebo obsahovat <code class="highlighter-rouge">Node a</code>, následovaný dalším seznamem <code class="highlighter-rouge">(MyList a)</code>. Seznam se žádnými elementy lze reprezentovat takto: <code class="highlighter-rouge">Empty</code>. Seznam s jediným elementem je prezentován takto: <code class="highlighter-rouge">Node a Empty</code>. Podobně seznam se dvěma elementy je representován takto: <code class="highlighter-rouge">(Node a (Node a Empty))</code>, a tak dále. Nyní s pomocí naší definice vytvořme seznam <code class="highlighter-rouge">[ 16, 5, 31, 9 ]</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Empty</span>
<span class="kt">Empty</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">MyList</span> <span class="n">a</span>

<span class="o">&gt;</span> <span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span>
<span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">MyList</span> <span class="n">number</span></code></pre></figure>

<p>Začínáme prázdným seznamem a potom přidáváme číslo 9 podobně, jako když jsme tvořili seznam pomocí operátoru cons (<code class="highlighter-rouge">::</code>): <code class="highlighter-rouge">9 :: []</code>. Dále pokračujeme v přidávání zbývajících prvků do čela stávajícího seznamu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Node</span> <span class="mi">31</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span><span class="p">)</span>
<span class="kt">Node</span> <span class="mi">31</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span><span class="p">)</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">MyList</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">31</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span><span class="p">))</span>
<span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">31</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span><span class="p">))</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">MyList</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="kt">Node</span> <span class="mi">16</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">31</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span><span class="p">)))</span>
<span class="kt">Node</span> <span class="mi">16</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">31</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span> <span class="kt">Empty</span><span class="p">)))</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">MyList</span> <span class="n">number</span></code></pre></figure>

<p><img src="/images/elm-intro/recursive-list-definition.png" alt="" /></p>

<p>Náš seznam zajisté není tak úhledný jako ten, který poskytuje Elm ale koncepčně jsou stejné. I když se náš typ <code class="highlighter-rouge">MyList</code> chová podobně jako typ <code class="highlighter-rouge">List</code>, nemůžeme použít žádnou z funkcí, definovaných v modulu <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/List" target="_blank">List</a>. <code class="highlighter-rouge">MyList</code> a <code class="highlighter-rouge">List</code> jsou dva zcela odlišné typy. V sekci <a href="easier-code-organization.html" target="_blank">Snadnější organizace kódu</a> použijeme jednu z funkcí z modulu <code class="highlighter-rouge">List</code> tak, aby pracovala rovněž s typem<code class="highlighter-rouge">MyList</code>.</p>

<p>Je důležité poznamenat, že pokud rekurzivní typ neposkytuje alespoň jeden nulární datový konstruktor, potom skončíme s hodnotou, která nikdy nekončí. Odstraníme-li datový konstruktor <code class="highlighter-rouge">Empty</code> z typu <code class="highlighter-rouge">MyList</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">MyList</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">MyList</span> <span class="n">a</span><span class="p">)</span></code></pre></figure>

<p>skončíme s takovouto hodnotou:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kt">Node</span> <span class="mi">16</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">31</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">18</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">7</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">26</span> <span class="p">(</span><span class="o">...</span><span class="p">)))))))</span></code></pre></figure>

<p><code class="highlighter-rouge">...</code> reprezentuje nekonečnou iteraci hodnoty <code class="highlighter-rouge">Node a</code>.</p>

<h4 id="working-with-recursive-types">Práce s rekurzivními typy</h4>

<p>Rekurzivní typy můžeme používat stejným způsobem jako každý jiný sdružený (unit) typ. Výraz <code class="highlighter-rouge">case</code> se používá k vyhledání shody (pattern match) s každým jednotlivým datovým konstruktorem, v typu definovaném. Přidejte následující definici funkce nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Playground.elm</code></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">sum</span> <span class="o">:</span> <span class="kt">MyList</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">sum</span> <span class="n">myList</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">myList</span> <span class="kr">of</span>
        <span class="kt">Empty</span> <span class="o">-&gt;</span>
            <span class="mi">0</span>

        <span class="kt">Node</span> <span class="n">intValue</span> <span class="n">remainingNodes</span> <span class="o">-&gt;</span>
            <span class="n">intValue</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">remainingNodes</span></code></pre></figure>

<p><code class="highlighter-rouge">sum</code> je funkce, která počítá součet celočíselných hodnot, obsažených v typu <code class="highlighter-rouge">MyList</code>. Potřebujeme řešit jenom dva případy (<code class="highlighter-rouge">Empty</code> a <code class="highlighter-rouge">Node</code>), protože to jsou jediné datové konstrukory, které typ <code class="highlighter-rouge">MyList</code> nabízí. Není-li seznam prázdný, odebereme celé číslo z čela a <a href="function-composition.html#recursion" target="_blank">rekurzivně</a> aplikujeme funkci <code class="highlighter-rouge">sum</code> na zbytek seznamu. Použití funce <code class="highlighter-rouge">sum</code> v replu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Playground</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">myList</span> <span class="o">=</span> <span class="kt">Node</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">Empty</span><span class="p">)))</span>
<span class="kt">Node</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">Empty</span><span class="p">)))</span> <span class="o">:</span> <span class="kt">Playground</span><span class="o">.</span><span class="kt">MyList</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="n">sum</span> <span class="n">myList</span>
<span class="mi">10</span> <span class="o">:</span> <span class="kt">Int</span></code></pre></figure>

<p>Obrázek dole ukazuje každý jednotlivý krok při vyhodnocení výrazu <code class="highlighter-rouge">sum myList</code>.</p>

<p><img src="images/my-list-recursive-sum.png" alt="" /></p>

<p>Rekrzivní typy jsou velmi účinné. Dovolují nám stručně definovat složité datové struktury. S pomocí rekurzivního typu zaveďme další datovou strukturu, zvanou <em>binární strom</em>. Vysvětlení vnitřního uspořádání binárního stromu je mimo rámec této knihy. Takže se omezíme na jeho definici a vizuální zobrazení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Tree</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Empty</span>
    <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span></code></pre></figure>

<p>Jméno <code class="highlighter-rouge">Tree</code> reprezentuje <a href="https://en.wikipedia.org/wiki/Binary_tree" target="_blank">binární strom</a> - hierarchickou stromovou strukturu, ve které každý node může mít nejvíce dvě děti. V programování má mnohé upotřebení.</p>

<p><img src="images/binary-tree.png" alt="" /></p>

<p>Strom z obrázku nahoře může být programově vyjádřen takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">exampleTree</span> <span class="o">:</span> <span class="kt">Tree</span> <span class="kt">Int</span>
<span class="n">exampleTree</span> <span class="o">=</span>
    <span class="kt">Node</span> <span class="sc">'1'</span>
        <span class="p">(</span><span class="kt">Node</span> <span class="sc">'2'</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="sc">'4'</span>
                <span class="kt">Empty</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="sc">'8'</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="sc">'5'</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="kt">Node</span> <span class="sc">'3'</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="sc">'6'</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="sc">'7'</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="sc">'9'</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
                <span class="kt">Empty</span>
            <span class="p">)</span>
        <span class="p">)</span></code></pre></figure>

<p>Přidáte-li funkci <code class="highlighter-rouge">exampleTree</code> definici typu <code class="highlighter-rouge">Tree</code> do souboru <code class="highlighter-rouge">Playground.elm</code>, dostanete chybu duplikátní definice, protože datový konstruktor <code class="highlighter-rouge">Node</code> je použit v typech <code class="highlighter-rouge">MyList</code> a <code class="highlighter-rouge">Tree</code>, což není dovoleno. Výše uvedený příklad je zamýšlen jako ukázka vytvoření stromu s použitím definice rekurzivního typu. Nemusíte jej tedy realizovat.</p>

<h3 id="how-powerful-is-elms-type-system-exactly">Jak účinný je vlastně typový systém Elmu?</h3>

<p>Jak účinný je typový systém Elmu v porovnání s jinými jazyky? Existuje mnoho velkých jazyků ale my se v našem srovnávání omezíme jenom tyto tři: <a href="http://www.idris-lang.org/" target="_blank">Idris</a>, <a href="https://www.haskell.org/" target="_blank">Haskell</a> a <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>. Typové systémy těchto jazyků mají několik zajímavých vlastností výrazně odlišných od Elmu. Pro tuto ukázku použijeme jednoduchou funkci, která sčítá dvě hodnoty.</p>

<p class="info">Ve zbytku této sekce si prezentovaný kód zkoušet nemusíte. Pohodlně se usaďte a pozorně čtěte.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">add</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span></code></pre></figure>

<p>Výše uvedená funkce je napsaná v JavaScriptu. Při pohledu na definici nedokážeme říci, jaké typy hodnot funkce <code class="highlighter-rouge">add</code> akceptuje. Po jistém zkoušení zjistíme, že akceptuje skoro každý typ hodnoty:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>

<span class="o">&gt;</span> <span class="nx">add</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">4.3</span><span class="p">)</span>
<span class="mf">6.8</span>

<span class="o">&gt;</span> <span class="nx">add</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">)</span>
<span class="s2">"ab"</span>

<span class="o">&gt;</span> <span class="nx">add</span><span class="p">(</span><span class="s2">"romeo"</span><span class="p">,</span> <span class="s2">"juliet"</span><span class="p">)</span>
<span class="s2">"romeojuliet"</span></code></pre></figure>

<p>JavaScript je <em>dynamicky</em> typovaný jazyk, což znamená, že neprověřuje typy hodnot před během programu. Typy parametrů <code class="highlighter-rouge">x</code> a <code class="highlighter-rouge">y</code> nejsou známé, dokud nezadáme konkrétní hodnoty funkci <code class="highlighter-rouge">add</code> při její exekucí. Jak vidno z ukázek, umí sečíst dvě celá čísla, desetinná čísla, znaky a dokonce řetězce.</p>

<p>Napišme funkce <code class="highlighter-rouge">add</code> v Elmu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">add</span> <span class="o">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span>
<span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span></code></pre></figure>

<p>Typový systém Elmu nám umožńuje přesně určit typy vstupních i výstupních hodnot. V anotaci typu nahoře říkáme, že funkce <code class="highlighter-rouge">add</code> přijímá dvě hodnoty typu number a vrací hodnotu stejného typu. Jak jsme si již dříve říkali, typová proměnná 'number' zastupuje typy <code class="highlighter-rouge">Int</code> a <code class="highlighter-rouge">Float</code>. Zadáme-li hodnoty jakéhokoli jiného typu, neprojde náš program ani kompilací. Elm je <em>staticky</em> typovaný jazyk, což znamená, že při kompilaci ověřuje typy hodnot.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="o">:</span> <span class="n">number</span>

<span class="o">&gt;</span> <span class="n">add</span> <span class="mf">2.5</span> <span class="mf">4.3</span>
<span class="mf">6.8</span> <span class="o">:</span> <span class="kt">Float</span></code></pre></figure>

<p>Nyní napíšeme funkci <code class="highlighter-rouge">add</code> v Haskellu.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">add</span> <span class="o">::</span> <span class="no">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span></code></pre></figure>

<p>Tělo funkce <code class="highlighter-rouge">add</code> v Haskellu i Elmu je úplně stejné, protože syntaxe Elmu je úzce odvozená z Haskellu. Typový systém Haskellu nám rovněž umožňuje přesně určit typy hodnot pro naše funkce ale je diferencovanější než v Elmu. V Haskellu můžeme formálně říci, že funkce <code class="highlighter-rouge">add</code> akceptuje <em>jakýkoli</em> typ čísel, nejenom <code class="highlighter-rouge">Int</code> a <code class="highlighter-rouge">Float</code>. Tato "bezbřehost" je ovšem jenom zdánlivá.</p>

<p>Jedním z důvodů, proč je typový systém v Haskellu expresivnější, jsou jeho <em>typové třídy</em>, které umožňují seskupovat typy podle společných vlastností. 
 <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Integral</code>, <code class="highlighter-rouge">Float</code>, a <code class="highlighter-rouge">Double</code> jsou v Haskellu různé typy, mající společné vlastnosti, jež z nich činí jeden skupinový typ (třídu) <code class="highlighter-rouge">Num</code>. Podporované operace třídy <code class="highlighter-rouge">Num</code> zjistíme dotazem:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;</span> <span class="ss">:info</span> <span class="no">Num</span>
<span class="k">class</span> <span class="nc">Num</span> <span class="n">a</span> <span class="n">where</span>
  <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">negate</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">abs</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">signum</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">fromInteger</span> <span class="o">::</span> <span class="no">Integer</span> <span class="o">-&gt;</span> <span class="n">a</span></code></pre></figure>

<p>Zdvojená dvojtečka <code class="highlighter-rouge">::</code> je totéž jako dvojtečka <code class="highlighter-rouge">:</code> v Elmu. Znamená "je typu". Jak vidno, operátor <code class="highlighter-rouge">+</code> přináleží ke třídě <code class="highlighter-rouge">Num</code>. To znamená, že naše funkce <code class="highlighter-rouge">add</code> může pracovat s každým typem, který je členem třídy <code class="highlighter-rouge">Num</code>. Proto se v anotaci typu funkce <code class="highlighter-rouge">add</code> uvádí <code class="highlighter-rouge">Num</code>.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">add</span> <span class="o">::</span> <span class="no">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span></code></pre></figure>

<p>Text mezi zdvojenou dvojtečkou <code class="highlighter-rouge">::</code> a zdvojenou šipkou <code class="highlighter-rouge">=&gt;</code> je vymezení typové třídy. <code class="highlighter-rouge">Num</code> je typová třída a <code class="highlighter-rouge">Num a</code> je vymezení této třídy pro typovou proměnnou <code class="highlighter-rouge">a</code>. Porovnejme anotaci typu v Haskellu s anotací v Elmu:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">add</span> <span class="p">:</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span></code></pre></figure>

<p>Anotace typu v Elmu je mnohem restriktivnější, než v Haskellu. Nyní vás může napadnout, že <code class="highlighter-rouge">number</code> v Elmu je jako typová třída v Haskellu - umožňuje nám říci, že funkce <code class="highlighter-rouge">add</code> přijímá hodnoty typu <code class="highlighter-rouge">number</code>, neboli hodnoty typu <code class="highlighter-rouge">Int</code> a <code class="highlighter-rouge">Float</code>. Jde však o podobnost čistě náhodnou. Termín <code class="highlighter-rouge">number</code> je v Elmu veden jako specielní typová proměnná, jež může zastupovat typy<code class="highlighter-rouge">Int</code> a <code class="highlighter-rouge">Float</code>.</p>

<p class="info">Návrháři Elmu se rozhodli nezahrnout typové třídy do jazyka z různých důvodů - viz tato stránka na <a href="https://github.com/elm-lang/elm-compiler/issues/38" target="_blank">Github</a>.</p>

<p>Na závěr napíšeme funkci <code class="highlighter-rouge">add</code> v Idrisu.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">add</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="no">Nat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">y</span> <span class="p">:</span> <span class="no">Nat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">auto</span> <span class="n">smaller</span> <span class="p">:</span> <span class="no">LT</span> <span class="n">x</span> <span class="n">y</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="no">Nat</span>
<span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span></code></pre></figure>

<p>Tělo funkce <code class="highlighter-rouge">add</code> je v Idrisu rovněž stejné jako v Elmu a Haskellu. To proto, že syntaxe Idrisu je rovněž úzce odvozena z Haskellu. Anotace typu je však zcela odlišná. Říká, že funkce <code class="highlighter-rouge">add</code> akceptuje dvě celá čísla a vrací celé číslo ale že navíc první argument musí být menší než druhý argument.</p>

<p><img src="images/idris-type-annotation.png" alt="" /></p>

<p>Kompilátor Idrisu zajistí, že funkce <code class="highlighter-rouge">add</code> není nikdy aplikována na dva argumenty, z nichž první je větší než druhý. Toto vymezení je možné proto, že Idris podporuje <a href="https://en.wikipedia.org/wiki/Dependent_type" target="_blank">dependent types</a>, což jsou typy, jejichž definice je závislá na jejich hodnotě. Toto omezení prostřednictvím typů umožňuje jen velmi málo jazyků. Ani Haskell tuto schopnost nemá. V Haskellu lze tuto podmínku ověřit pouze při běhu programu takto:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span>
        <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">else</span>
        <span class="n">error</span> <span class="s2">"First argument must be smaller than the second argument."</span></code></pre></figure>

<p>Abychom to shrnuli, typový systém Elmu nám umožňuje určit více omezujících podmínek než typový systém v JavaScriptu a typový systém v Haskellu umožňuje určít více typových vymezení než typový systém Elmu. Typový systém Idrisu umožňuje určít ještě více omezujících podmínek než dtto Haskellu. Čím více podmínek můžeme určit pro kompilaci, tím je menší možnost, že se vyskytne chyba při běhu programu.</p>

<p><img src="images/type-system-spectrum.png" alt="" /></p>

<p>Z toho plyne otázka - je-li Idris nejefektivnější v prevenci chyb, proč návrháři Elmu rovněž nepoužili tento systém? Důvodem je složitost. Čím je typový systém mocnější, tím je náročnější jej zavést. Také se obtížněji osvojuje. Jedním z typických znaků Elmu je to, že je snadný na učení. K tomu příspívá i to, že nemá příliš složitý typový systém. <!--
 That said, Elm’s type system is still powerful enough to make those runtime errors extremely rare. -->
 </p>
</article>

 <nav class="pagination">
<a class="pagination-next" href="easy-to-test.html">
<em>&larr; Previous</em>
<strong>Snadné testování</strong>
</a>
<a class="pagination-next" href="easier-code-organization.html">
<em>Next &rarr;</em><strong>Organizace kódu</strong>
</a>
<a class="elevator" href="aa-index.html"><i class="fa fa-angle-up"></i>
<span>Back to top</span>
</a>
</nav>

</div>
</div>



<footer id="footer" class="page-footer">
<footer class="container">
 <p>Copyright © 2016 Pawan Poudel. All Rights Reserved.</p>
</footer>
</footer>

  </body>
</html>

