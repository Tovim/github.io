<!DOCTYPE html>

<html lang="cs">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title> - Beginning Elm</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/main.css">
<!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">    deformuje zobrazení font awsome -->
</head>

<body>

<section class="heading">
<h1> 5.2 </h1>
<h2>Skladba EA - 1</h2>
</section>

<div class="page-content">
<div class="container">

<div class="breadcrumb-holder">
<header id="breadcrumb" class="breadcrumb">
<a href="aa-index.html" class="breadcrumb-toggle">
  <span></span>
  <span></span>
  <span></span>
</a>

<span class="breadcrumb-section">syntaxe</span>

<a class="breadcrumb-next" href="virtual-dom.html">
<i class="fa fa-angle-right"></i><span>Next article</span>
</a>
<a class="breadcrumb-previous" href="elm-architecture.html">
<i class="fa fa-angle-left"></i><span>Previous article</span>
</a>
          
</header>
</div>

<article class="content">
Webové aplikace se mohou principiáně skládat ze dvou částí: z uspořádání, zvaného "stav" a z uživatelského rozhraní (user interface, UI). Každá aplikace začíná nějakým počátečním stavem a tento stav je uživateli prezentován prostřednictvím UI. Uživatel může prostřednictím tohoto UI provést nějakou akci, která mění počáteční stav aplikace. Změněný stav se rovněž v UI projeví. Obrázek dole ukazuje interakci mezi stavem a UI v hypotetické aplikaci, která umožňuje přihlášeným (lodded in) uživatelům vytvářet blogové příspěvky.</p>

<p><img src="images/state-ui.png" alt="" /></p>

<p>V každém časovém okamžiku potřebuje aplikace ukládat do paměti různé typy informací. Například potřebuje vědět, zda je uživatel přihlášen nebo kolik příspěvků již poslal. Entita <strong>state</strong> je něco jako repozitář pro ukládání všech těchto informací. Tento stav je dostupný různým datovým strukturám v aplikaci. Funkce s tímto stavem provádějí různé operace, ústící v novém stavu.</p>

<p>V sekci <a href="pure-functions.html#what-is-a-state" target="_blank">Čisté funkce</a> jsme definovali stav jako něco, co reprezentuje všechny informace, k nímž má <em>funkce</em> v daném okamžiku přístup. Koncepčně pracuje <em>stav aplikace</em> stejným způsobem, jenom obsahuje mnohem víc informací.</p>

<h3 id="model">Model</h3>

<p>Stav aplikace reprezentujeme v Elmu něčím, co označujeme jako <em>model</em>. Model je jenom datová struktura, která obsahuje důležité informace o aplikaci. Představte si jednoduchou aplikaci, která umí zvětšovat čí zmenšovat stav počítadla o 1. Jediný stav, který pro tuto aplikaci potřebujeme sledovat, je aktuální hodnota počítadla. Takto vypadá definice modelu popsané aplikace:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Model</span>
    <span class="o">=</span> <span class="kt">Int</span></code></pre></figure>

<p>Je to pouhé označení typu <code class="highlighter-rouge">Int</code>. Model nemusí nezbytně být složitý. Všechno závisí na složitosti aplikace a na tom, kolik různých věcí je zapotřebí sledovat. U jednoduché aplikace počítadla, jediné co potřebujeme, je číslo, které nám říká, jaká je aktuální hodnota počítadla. Model je obecně definován jako alias typu.</p>

<p>Přidáme výše uvedenou definici modelu do souboru a počneme budovat aplikaci počítadla. Vytvořte nový soubor s názvem <code class="highlighter-rouge">Counter.elm</code> v adresáři <code class="highlighter-rouge">beginning-elm/elm-examples</code>.</p>

<p><img src="images/create-counter-file.png" alt="" /></p>

<p>Nyní vložte následující kód do <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">Counter</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>


<span class="kr">type</span> <span class="n">alias</span> <span class="kt">Model</span> <span class="o">=</span>
    <span class="kt">Int</span></code></pre></figure>

<p>Výše uvedená definice ještě nevytváří model. Pouze Elmu říká, jak náš model vypadá. Přidejte následující kód na spodek souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">initialModel</span> <span class="o">:</span> <span class="kt">Model</span>
<span class="n">initialModel</span> <span class="o">=</span>
    <span class="mi">0</span></code></pre></figure>

<p>Výše uvedená konstanta 0 je to, co z naší definice vytváří počáteční model.</p>

<h3 id="view">View</h3>
<!--
<p>Poznámka překladatele: převod "view -- &gt; zobrazení" je  jenom podmíněně vhodný - bude v případě potřeby použit v popisném textu jako náhrada za netečné "view".</p>--> 

<p>Dále potřebujeme prezentovat náš počáteční model uživateli. Přidejte následující kód na spodek souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">view</span> <span class="o">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span> <span class="n">msg</span>
<span class="n">view</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">div</span> <span class="kt">[]</span>
        <span class="p">[</span> <span class="n">button</span> <span class="p">[</span> <span class="n">onClick</span> <span class="kt">Decrement</span> <span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"-"</span> <span class="p">]</span>
        <span class="p">,</span> <span class="n">text</span> <span class="p">(</span><span class="n">toString</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">button</span> <span class="p">[</span> <span class="n">onClick</span> <span class="kt">Increment</span> <span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"+"</span> <span class="p">]</span>
        <span class="p">]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">view</code> přijímá model a vrací kód HTML. Za scénou vytváří funkce <code class="highlighter-rouge">div</code> element HTML <code class="highlighter-rouge">&lt;div&gt;</code> a funkce <code class="highlighter-rouge">button</code> vytváří element <code class="highlighter-rouge">&lt;button&gt;</code>. Funkce <code class="highlighter-rouge">text</code> nepředstavuje žádný element HTML. Pouze zobrazí prostý text potlačením (escaping) speciálních znaků, takže jej vidíme přesně tak, jak jsme jej zadali v našem kódu.</p>

<p>První argument funkce <code class="highlighter-rouge">div</code> a <code class="highlighter-rouge">button</code> představuje seznam atributů. Druhý argument představuje seznam vnořených elementů. Kód Elmu ve funkci <code class="highlighter-rouge">view</code> je ekvivalentní následujícímu kódu HTML.</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div&gt;</span>
    <span class="nt">&lt;button&gt;</span> + <span class="nt">&lt;/button&gt;</span>
    String representation of our model
    <span class="nt">&lt;button&gt;</span> - <span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/div&gt;</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">div</code>, <code class="highlighter-rouge">button</code> a <code class="highlighter-rouge">text</code> jsou všechny definovány v modulu <a href="http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html" target="_blank"><code class="highlighter-rouge">Html</code></a>, který je součástí paketu <a href="http://package.elm-lang.org/packages/elm-lang/html/2.0.0" target="_blank"><code class="highlighter-rouge">elm-lang/html</code></a>, jenž nám poskytuje úplný přístup k HTML prostřednictvím normálních funkcí Elmu. Potřebujeme tedy importovat modul <code class="highlighter-rouge">Html</code> do souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">Counter</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Html</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="o">.</span>
<span class="o">.</span></code></pre></figure>

<p>Protože můžeme s elementy HTML zacházet jako s obyčejnými funkcemi, můžeme použít všechny pěkné věci, které Elm nabízí, rovněž na funkci <code class="highlighter-rouge">view</code>. Můžeme například vložit duplikátní kód do samostatných funkcí a opětovně je použít na různých místech naší aplikace. Můžeme napsat automatizované testy pro funkci <code class="highlighter-rouge">view</code> s použitím stejných nástrojů, které jsme použili při testování jiného kódu Elm. Kompilátor Elmu nás dokonce upozorní, uděláme-li v kódu <code class="highlighter-rouge">view</code> nějakou chybu. </p>

<p>Funkce <code class="highlighter-rouge">view</code> není zodpovědná za zobrazení HTML na obrazovce. Vše co dělá, je že přijme model a vrací porci HTML. Je to čistá funkce, která pro tentýž model vrací tentýž kód HTML. Pro vlastní zobrazení HTML na obrazovce používá Elm za scénou paket <a href="http://package.elm-lang.org/packages/elm-lang/virtual-dom/latest" target="_blank"><code class="highlighter-rouge">elm-lang/virtual-dom</code></a>. O to, jak tento paket pracuje, se zatím nestarejte. Prozkoumáme jej podrobně v sekci <a href="virtual-dom.html" target="_blank">Virtuální DOM</a> později.</p>

<p>Adresář <code class="highlighter-rouge">elm-lang/virtual-dom</code> je dependence pro paket <code class="highlighter-rouge">elm-lang/html</code>, takže byl automaticky instalován, když jsme žádali <code class="highlighter-rouge">elm-package</code> aby instaloval <code class="highlighter-rouge">elm-lang/html</code> již v odstavci <a href="getting-started.html#2.2" target="_blank">Vytvoření webové stránky</a> sekce Začínáme.</p>

<p><img src="images/virtual-dom-package-location.png" alt="" /></p>

<p>Nepotřebujeme importovat do našeho kódu žádný z modulů, obsažených v paketu <code class="highlighter-rouge">elm-lang/virtual-dom</code>, protože bychom jej v našem kódu přímo použít neměli. Existují pouze jako podpora modulu, definovaného v paketu <code class="highlighter-rouge">elm-lang/html</code>.</p>

<p>Anotace typu pro funkci <code class="highlighter-rouge">view</code> naznačuje, že vrací hodnotu typu <code class="highlighter-rouge">Html msg</code>, což znamená, že kód HTML, generovaný funkcí<code class="highlighter-rouge">view</code> je schopen produkovat zprávy typu <code class="highlighter-rouge">msg</code>. Nestarejte se zatím, co to všechno znamená, vrátíme se k tomu záhy.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">view</span> <span class="o">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span> <span class="n">msg</span></code></pre></figure>

<h4 id="application-entry-point">Vstupní bod aplikace</h4>

<p>Abychom mohli zobrazit "view", potřebujeme definovat vstupní bod naší aplikace. Přidejte následující kód na spodek souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">main</span> <span class="o">=</span>
    <span class="n">beginnerProgram</span>
        <span class="p">{</span> <span class="n">model</span> <span class="o">=</span> <span class="n">initialModel</span>
        <span class="p">,</span> <span class="n">view</span> <span class="o">=</span> <span class="n">view</span>
        <span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="n">update</span>
        <span class="p">}</span></code></pre></figure>

<p>Jako obvykle, funkce <code class="highlighter-rouge">main</code> slouží jako vstupní bod k naší aplikaci. Používá funkci <code class="highlighter-rouge">beginnerProgram</code>, definovanou v modulu <code class="highlighter-rouge">Html</code> aby poskytla nezbytné informace, potřebné pro runtime Elmu k zobrazení naší procedury "view" v prohlížeči. Již jsme definovali <code class="highlighter-rouge">initialModel</code> a funkci <code class="highlighter-rouge">view</code>. Definujme rovněž funkci <code class="highlighter-rouge">update</code>. Přidejte následující kód hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">update</span> <span class="o">:</span> <span class="n">msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Model</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">initialModel</span>


<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">update</code> vrací počáteční model. Později jej trošku rozšíříme do větší smysluplnosti.</p><!--
 Nyní jsme konečně připraveni zobrazit naše "view". Spusťte v terminálu <code class="highlighter-rouge">elm-reactor</code> z adresáře <code class="highlighter-rouge">beginning-elm</code> a přejděte na stránku <a href="http://localhost:8000/elm-examples/Counter.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/Counter.elm</code></a>. V levém horním rohu obrazovky byste měl vidět toto zobrazení:

<p><img src="images/counter-app-1.png" alt="" /></p>

<span class="highlight">
<p class="o">Ve Windows se mi obrázek neukazuje! Musím do zdrojového textu doplnit kódy z dalšího popisu abych dostal alespoň 2x button a stav uprostřed!</p>
</span>-->

<h3 id="update">Update</h3>

<p>Naše aplikace je v této chvíli zcela nezajímavá. Tlačítka nic nedělají. Je to proto, že jsme neurčili, co se má stát při jejich stisknutí. Hned to napravíme.<br>
Nejprve definujeme <em>sdělení</em>, která představují možné akce uživatele. Přidejte následující definici typu hned nad funkci <code class="highlighter-rouge">update</code> v souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Msg</span>
    <span class="o">=</span> <span class="kt">Increment</span>
    <span class="o">|</span> <span class="kt">Decrement</span>


<span class="n">update</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Nový typ <code class="highlighter-rouge">Msg</code>  reprezentuje sdělení, na něž naše aplikace může reagovat. Je to jednoduchý <a href="/type-system.html#creating-our-own-types" target="_blank">sdružený</a> (union) typ se dvěmi konstantami. Při stisku tlačítka <code class="highlighter-rouge">+</code> obdrží naše aplikace sdělení, zvané <code class="highlighter-rouge">Increment</code>; stisk tlačítka <code class="highlighter-rouge">-</code> generuje sdělení <code class="highlighter-rouge">Decrement</code>.</p>

<p class="info">Termín "sdělení" (message) nemá v Elmu žádný specifický význam. Není to datový typ ani datová struktura. Mohli jsme docela snadno použít termín "akce" nebo "událost". Oficiální dokumentace Elmu ovšem preferuje termín "message".</p>

<p>Na rozdíl od datové struktury <code class="highlighter-rouge">Model</code> jsme nedefinovali <code class="highlighter-rouge">Msg</code> jako alias typu, protože není v Elmu žádný vestavěný typ, který by korektně představoval naše "sdělení". Datová struktura <code class="highlighter-rouge">Model</code> je pouhá celočíselná hodnota. Takže jsme vytvořili alias typu, který redefinuje existující typ <code class="highlighter-rouge">Int</code>. Mohl byste chtít vědět, proč jsme vůbec potřebovali definovat <code class="highlighter-rouge">Model</code>. Mohli jsme jednoduše v definici objektu <code class="highlighter-rouge">initialModel</code> nahradit <code class="highlighter-rouge">Model</code> přímo typem <code class="highlighter-rouge">Int</code> a <code class="highlighter-rouge">"aktualizovat"</code> anotaci typu funkce takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">initialModel</span> <span class="o">:</span> <span class="kt">Int</span>
<span class="n">initialModel</span> <span class="o">=</span>
    <span class="mi">0</span>


<span class="n">update</span> <span class="o">:</span> <span class="n">msg</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">initialModel</span></code></pre></figure>

<p>Všechno by mohlo pracovat jako předtím. Což je pravda. Ovšem, označení hodnoty názvem <code class="highlighter-rouge">Model</code> činí náš kód mnohem přehlednější. V jednoduché aplikaci, jako je počítadlo, nejsou výhody pojmenovaných entit příliš zřejmé ale ve velkých aplikacích může být koncept dobře pojmenovaných domén, jako je <code class="highlighter-rouge">Model</code>, velkým přínosem z hlediska udržovatelnosti kódu.</p>

<p>Upravme funkci <code class="highlighter-rouge">update</code> aby zvětšovala nebo zmenšovala hodnotu modelu v závislosti na přijatém sdělení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">update</span> <span class="o">:</span> <span class="kt">Msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Model</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="kt">Increment</span> <span class="o">-&gt;</span>
            <span class="n">model</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="kt">Decrement</span> <span class="o">-&gt;</span>
            <span class="n">model</span> <span class="o">-</span> <span class="mi">1</span></code></pre></figure>

<p>Provedli jsme malou změnu v anotaci typu funkce <code class="highlighter-rouge">update</code>. Sdělení je nyní reprezentováno označením <code class="highlighter-rouge">Msg</code> místo <code class="highlighter-rouge">msg</code>, jež je pouze proměnnou typu. Na rozdíl od slova <code class="highlighter-rouge">number</code> nemá <code class="highlighter-rouge">msg</code> v Elmu žádný určitý význam. Mohli jsme v předchozí verzi použít jakékoli náhodné jméno k reprezentaci generického sdělení, třeba takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">update</span> <span class="o">:</span> <span class="n">someMessage</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Model</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">initialModel</span></code></pre></figure>

<p>Náhradou <code class="highlighter-rouge">msg</code> tvarem <code class="highlighter-rouge">Msg</code> jsme učinili funkci <code class="highlighter-rouge">update</code> mnohem restriktivnější. Nyní příjímá pouze dvě sdělení: <code class="highlighter-rouge">Increment</code> a <code class="highlighter-rouge">Decrement</code>. Předtím mohla přijmout <em>jakékoli</em> sdělení.</p>

<p>Vytvořili jsme mechanizmus pro ošetření sdělení ale stále nemáme nástroj, který je vytváří. Upravte funkci <code class="highlighter-rouge">view</code> tak aby generovala sdělení při stisku tlačítka <code class="highlighter-rouge">+</code> a <code class="highlighter-rouge">-</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">view</span> <span class="o">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span> <span class="kt">Msg</span>
<span class="n">view</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">div</span> <span class="kt">[]</span>
        <span class="p">[</span> <span class="n">button</span> <span class="p">[</span> <span class="n">onClick</span> <span class="kt">Decrement</span> <span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"-"</span> <span class="p">]</span>
        <span class="p">,</span> <span class="n">text</span> <span class="p">(</span><span class="n">toString</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">button</span> <span class="p">[</span> <span class="n">onClick</span> <span class="kt">Increment</span> <span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"+"</span> <span class="p">]</span>
        <span class="p">]</span></code></pre></figure>

<p>Typ sdělení se ve funkci <code class="highlighter-rouge">view</code> rovněž změnil z <code class="highlighter-rouge">msg</code> na <code class="highlighter-rouge">Msg</code>. V předchozí verzi nevytvářelo HTML, vracené funkcí <code class="highlighter-rouge">view</code>, žádné sdělení a to v důsledku použití <code class="highlighter-rouge">msg</code>. Nyní tato funkce používá funkci <code class="highlighter-rouge">onClick</code> z modulu <a href="http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Events" target="_blank"><code class="highlighter-rouge">Html.Events</code></a> ke generování sdělení typu <code class="highlighter-rouge">Msg</code>. <br> Importujte modul <code class="highlighter-rouge">Html.Events</code> v souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">Counter</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Html</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Html.Events</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="o">.</span>
<span class="o">.</span></code></pre></figure>

<p>Obnovte stránku na <a href="http://localhost:8000/elm-examples/Counter.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/Counter.elm</code></a> a měl byste mít možnost zvětšovat (increment) a zmenšovat (decrement) stav počítadla. Na platformě Windows ovšem s mnohem menší parádou - zobrazí se pouze tlačítka a stav počítadla.</p>

<p><img src="images/counter-app-1.png" alt="" /></p>

<h3 id="main-functions-type-annotation"> Závěr</h3>

<p>Elm Architecture se v podstatě redukuje na tyto tří části: Model, View, a Update. Na celou aplikaci lze pohlížet jako na motorek, který přijímá počáteční model, prezentuje jej uživatelům, umožňuje jim vytvářet sdělení, podle nichž je model aktualizován a obratem prezentován zpět uživateli.</p>

<p><img src="images/model-view-update.png" alt="" /></p>

<p>Obrázek dole ilustruje interakci mezi runtime Elmu a různými komponentami v naší aplikaci.</p>

<p><img src="images/model-view-update-interaction-1.png" alt="" /></p>

<h3 id="main-functions-type-annotation">Anotace funkce <code class="highlighter-rouge">main</code></h3>

<p>Nevím, zda jste si všimnuli, že jsme definici funkce <code class="highlighter-rouge">main</code> nedoplnili anotací jejího typu. Zeptejme se Elmu, jaký by to měl být. Smažte adresář <code class="highlighter-rouge">build-artifacts</code> uvnitř adresáře  <code class="highlighter-rouge">beginning-elm/elm-stuff</code> a v adresáři <code class="highlighter-rouge">beginning-elm</code> zadejte tento příkaz v terminálu:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">elm-make elm-examples/Counter.elm --output counter.js --warn</code></pre></figure>

<p>Jak bylo již zmíněno v sekci <a href="elm-make.html" target="_blank"><code class="highlighter-rouge">elm-make</code></a>, flag <code class="highlighter-rouge">warn</code> aplikaci <code class="highlighter-rouge">elm-make</code> říká aby chybová hlášení doplňovala varováními. V příkazu nesmí chybět název výstupního souboru v JavaScriptu (<code class="highlighter-rouge">counter.js</code>). Jinak by <code class="highlighter-rouge">elm-make</code> přepsal soubor <code class="highlighter-rouge">beginning-elm/index.html</code>.</p>

<p class="info">Pokud se v našem kódu od poslední kompilace nic nezměnilo, <code class="highlighter-rouge">elm-make</code> žádnou rekompilaci neprovádí. Smazáním adresáře <code class="highlighter-rouge">build-artifacts</code> jej k rekompilaci donutíme. Bez rekompilace se varování nezobrazí.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">=========================</span> <span class="kt">WARNINGS</span> <span class="o">==============================</span>
<span class="c1">---------------- missing type annotation ------------------------</span>

<span class="kt">Top</span><span class="o">-</span><span class="n">level</span> <span class="n">value</span> <span class="p">`</span><span class="n">main</span><span class="p">`</span> <span class="n">does</span> <span class="n">not</span> <span class="n">have</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">annotation</span><span class="o">.</span>

<span class="mi">29</span><span class="o">|</span> <span class="n">main</span> <span class="o">=</span>
    <span class="o">^^^^</span>
<span class="kt">I</span> <span class="n">inferred</span> <span class="n">the</span> <span class="kr">type</span> <span class="n">annotation</span> <span class="n">so</span> <span class="n">you</span> <span class="n">can</span> <span class="n">copy</span> <span class="n">it</span> <span class="n">into</span> <span class="n">your</span> <span class="n">code</span><span class="o">:</span>

<span class="n">main</span> <span class="o">:</span> <span class="kt">Program</span> <span class="kt">Never</span> <span class="kt">Model</span> <span class="kt">Msg</span></code></pre></figure>

<p>Zkopírujte anotaci typu z varování hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">Counter.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">main</span> <span class="o">:</span> <span class="kt">Program</span> <span class="kt">Never</span> <span class="kt">Model</span> <span class="kt">Msg</span>
<span class="n">main</span> <span class="o">=</span>
    <span class="n">beginnerProgram</span>
    <span class="o">.</span>
    <span class="o">.</span></code></pre></figure>

<p>Tento trik můžete použít i příště, když nebudete umět určit anotaci funkce z její implementace. Funkce <code class="highlighter-rouge">main</code> nemá pouze jeden určitý typ. V sekci <a href="easier-code-organization.html#importing-a-module" target="_blank">Organizace kódu</a> měla funkce <code class="highlighter-rouge">main</code> typ <code class="highlighter-rouge">Html.Html msg</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">main</span> <span class="o">:</span> <span class="kt">Html</span><span class="o">.</span><span class="kt">Html</span> <span class="n">msg</span>
<span class="n">main</span> <span class="o">=</span>
    <span class="kt">MyList</span><span class="o">.</span><span class="n">isEmpty</span> <span class="n">list1</span>
        <span class="o">|&gt;</span> <span class="n">toString</span>
        <span class="o">|&gt;</span> <span class="kt">Html</span><span class="o">.</span><span class="n">text</span></code></pre></figure>

<p>V sekci <a href="fuzz-testing.html#running-a-fuzz-test-in-browser" target="_blank">Fuzz Testing</a> měla typ <code class="highlighter-rouge">TestProgram</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">main</span> <span class="o">:</span> <span class="kt">TestProgram</span>
<span class="n">main</span> <span class="o">=</span>
    <span class="n">run</span> <span class="o">&lt;|</span>
        <span class="n">describe</span> <span class="s">"Test suite"</span>
            <span class="p">[</span> <span class="kt">RippleCarryAdderTests</span><span class="o">.</span><span class="n">allTests</span>
            <span class="p">,</span> <span class="kt">FuzzTests</span><span class="o">.</span><span class="n">allTests</span>
            <span class="p">]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">main</code> v podstatě přebírá typ výrazu, který vrací. Již víme, co <code class="highlighter-rouge">Html.Html msg</code> a <code class="highlighter-rouge">TestProgram</code> znamenají. <code class="highlighter-rouge">Program Never Model Msg</code> znamená program Elmu, který má model typu <code class="highlighter-rouge">Model</code> a přijímá sdělení typu <code class="highlighter-rouge">Msg</code>. Typ <code class="highlighter-rouge">Never</code> sděluje, že při spuštění programu nejsou zadány žádné hodnoty. V sekci <a href="ports.html" target="_blank">Ports</a> uvidíme příklad, který nám ukáže jak zadávat hodnoty při inicializaci programu.</p>

<h3 id="summary">Shrnutí</h3>

<p>V této sekci jsme se dozvěděli, že se Elm Architecture redukuje na tři základní koncepty:  Model, View a Update. V následující sekci si povíme, jak používat paket "virtual dom" a čím nám může být užitečný. Zde je pro kontrolu celý kód aplikace "counter":</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">Counter</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Html</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Html.Events</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>


<span class="c1">-- Model</span>


<span class="kr">type</span> <span class="n">alias</span> <span class="kt">Model</span> <span class="o">=</span>
    <span class="kt">Int</span>


<span class="n">initialModel</span> <span class="o">:</span> <span class="kt">Model</span>
<span class="n">initialModel</span> <span class="o">=</span>
    <span class="mi">0</span>



<span class="c1">-- View</span>


<span class="n">view</span> <span class="o">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span> <span class="kt">Msg</span>
<span class="n">view</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">div</span> <span class="kt">[]</span>
        <span class="p">[</span> <span class="n">button</span> <span class="p">[</span> <span class="n">onClick</span> <span class="kt">Decrement</span> <span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"-"</span> <span class="p">]</span>
        <span class="p">,</span> <span class="n">text</span> <span class="p">(</span><span class="n">toString</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">button</span> <span class="p">[</span> <span class="n">onClick</span> <span class="kt">Increment</span> <span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"-"</span> <span class="p">]</span>
        <span class="p">]</span>



<span class="c1">-- Update</span>


<span class="kr">type</span> <span class="kt">Msg</span>
    <span class="o">=</span> <span class="kt">Increment</span>
    <span class="o">|</span> <span class="kt">Decrement</span>


<span class="n">update</span> <span class="o">:</span> <span class="kt">Msg</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="kt">Increment</span> <span class="o">-&gt;</span>
            <span class="n">model</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="kt">Decrement</span> <span class="o">-&gt;</span>
            <span class="n">model</span> <span class="o">-</span> <span class="mi">1</span>



<span class="c1">-- Entry point</span>


<span class="n">main</span> <span class="o">:</span> <span class="kt">Program</span> <span class="kt">Never</span> <span class="kt">Model</span> <span class="kt">Msg</span>
<span class="n">main</span> <span class="o">=</span>
    <span class="n">beginnerProgram</span>
        <span class="p">{</span> <span class="n">model</span> <span class="o">=</span> <span class="n">initialModel</span>
        <span class="p">,</span> <span class="n">view</span> <span class="o">=</span> <span class="n">view</span>
        <span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="n">update</span>
        <span class="p">}</span></code></pre></figure>
</article>

<nav class="pagination">
<a class="pagination-next" href="elm-architecture-intro.html">
<em>&larr; Previous</em>
<strong>Architektura Elmu 2</strong>
</a>
<a class="pagination-next" href="virtual-dom.html">
<em>Next &rarr;</em><strong>Virtuální DOM</strong>
</a>
<a class="elevator" href="aa-index.html"><i class="fa fa-angle-up"></i>
<span>Back to top</span>
</a>
</nav>

</div>
</div>



<footer id="footer" class="page-footer">
<footer class="container">
 <p>Copyright © 2016 Pawan Poudel. All Rights Reserved.</p>
</footer>
</footer>

  </body>
</html>
