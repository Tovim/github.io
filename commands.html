<!DOCTYPE html>

<html lang="cs">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title> - Beginning Elm</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/main.css">
<!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">    deformuje zobrazení font awsome -->
</head>

<body>

<section class="heading">
<h1> 5.6 </h1>
<h2>Příkazy</h2>
</section>

<div class="page-content">
<div class="container">

<div class="breadcrumb-holder">
<header id="breadcrumb" class="breadcrumb">
<a href="aa-index.html" class="breadcrumb-toggle">
  <span></span>
  <span></span>
  <span></span>
</a>

<span class="breadcrumb-section">syntaxe</span>

<a class="breadcrumb-next" href="http-requests.html">
<i class="fa fa-angle-right"></i><span>Next article</span>
</a>
<a class="breadcrumb-previous" href="side-effects.html">
<i class="fa fa-angle-left"></i><span>Previous article</span>
</a>
          
</header>
</div>

<article class="content">
<p>Příkazy používáme k provádění operací, které mají vedlejší účinky. Stejně jako sdělení (messages), jsou příkazy rovněž reprezentovány jako data. Můžete si je představit jako datové struktury, které spolu s potřebnými daty ukládájí, co se má stát. Příkaz potom předáváme runtime Elmu. Runtime provede potřebné a zpraví naši aplikaci o výsledku. Věru, zní to poněkud vágně. Lépe si to ukážeme na příkladu, který generuje náhodná čísla.</p>

<h3 id="generating-random-numbers">Generování náhodných čísel</h3>

<p>Ke generování náhodných čísel existují dva přístupy:  <em>True Random Number Generators (TRNGs)</em> a <em>Pseudo-Random Number Generators (PRNGs)</em>. TRNGs generuje čísla ze skutečně náhodného fyzikálního fenoménu, jakým jsou například malé variace v pohybech něčí myši nebo časový okamžik, ve kterém se rozpadá radioaktivní materiál nebo atmosférický hluk, zachycený radiem.</p>

<p>Vzhledem ke své závislosti na fyzikálním fenoménu potřebuje TRNG mnohem více času ke generování náhodných čísel. Proto většina počítačových programů, které potřebují náhodná čísla rychle, vychází z PRNG, které je rychlejší. Přes tuto svoji pružnost nejsou PRNG vhodné pro aplikace, které potřebují skutečně nepředvídatelná náhodná čísla - jako jsou generátory šifrovacích klíčů.</p>

<p>PRNG používají počáteční hodnotu (zvanou seed), na níž aplikují algoritmus pro generování zdánlivě náhodných čísel. Moderní algoritmy, používané PRNG jsou tak dobré, že generovaná čísla vypadají jako zcela náhodná.</p>

<p><img src="images/random-number-generation-algorithm-1.png" alt="" /></p>

<p>Ovšem, použijeme-li tentýž počáteční seed vícekrát za sebou, dostaneme pokaždé přesně stejná čísla.</p>

<p><img src="images/random-number-generation-algorithm-2.png" alt="" /></p>

<h4 id="generating-random-numbers-without-side-effects">Generování náhodných čísel bez vedlejších účinků</h4>

<p>Prozkoumejme toto chování PRNG podrobněji krátkým kódem v <code class="highlighter-rouge">elm-repl</code>. Začneme generováním počátečního seedu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Random</span>

<span class="o">&gt;</span> <span class="n">seed0</span> <span class="o">=</span> <span class="kt">Random</span><span class="o">.</span><span class="n">initialSeed</span> <span class="mi">31415</span>
<span class="kt">Seed</span> <span class="p">{</span> <span class="n">state</span> <span class="o">=</span> <span class="kt">State</span> <span class="mi">31416</span> <span class="mi">1</span><span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">range</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="p">}</span>
    <span class="o">:</span> <span class="kt">Random</span><span class="o">.</span><span class="kt">Seed</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">initialSeed</code> z modulu <code class="highlighter-rouge">Random</code> přijímá celé číslo a vrací seed. Náhodně jsme jako vstup vybrali číslo <code class="highlighter-rouge">31415</code>. Signatura typu funkce <code class="highlighter-rouge">initialSeed</code> vypadá takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">initialSeed</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Seed</span></code></pre></figure>

<p>Typ <code class="highlighter-rouge">Seed</code> je v modulu <code class="highlighter-rouge">Random</code> definová takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Seed</span>
    <span class="o">=</span> <span class="kt">Seed</span>
        <span class="p">{</span> <span class="n">state</span> <span class="o">:</span> <span class="kt">State</span>
        <span class="p">,</span> <span class="n">next</span> <span class="o">:</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">State</span> <span class="p">)</span>
        <span class="p">,</span> <span class="n">split</span> <span class="o">:</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="kt">State</span><span class="p">,</span> <span class="kt">State</span> <span class="p">)</span>
        <span class="p">,</span> <span class="n">range</span> <span class="o">:</span> <span class="kt">State</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span> <span class="p">)</span>
        <span class="p">}</span>


<span class="kr">type</span> <span class="kt">State</span>
    <span class="o">=</span> <span class="kt">State</span> <span class="kt">Int</span> <span class="kt">Int</span></code></pre></figure>

<p>Takto složitý <a href="type-system.html#union-types" target="_blank">sdružený (union) typ</a> jsme dosud neměli. Typ <code class="highlighter-rouge">Seed</code> používá stejné jméno pro <a href="type-system.html#type-constructor" target="_blank">typový i datový konstruktor</a>, což je v Elmu zcela přípustné. Chceme-li vytvořit seed přímo bez použití funkce <code class="highlighter-rouge">initialSeed</code>, potřebujeme zadat záznam, který obsahuje hodnoty pro vlastnosti <code class="highlighter-rouge">state</code>, <code class="highlighter-rouge">next</code>, <code class="highlighter-rouge">split</code> a <code class="highlighter-rouge">range</code>. Takovéto vytváření nového seedu je docela složité. Proto modul <code class="highlighter-rouge">Random</code> poskytuje funkci <code class="highlighter-rouge">initialSeed</code>, která před námi veškeré složitosti ukrývá.</p>

<p>Dobrou zprávou je, že nemusíme vytvářet seed přímo bez funkce <code class="highlighter-rouge">initialSeed</code> nebo rozumět tomu, jak typ <code class="highlighter-rouge">Seed</code> pracuje, abychom byli schopni generovat náhodná čísla v Elmu. Nicméně jsem se chtěl tady o tom krátce zmínit, aby vám výstup, generovaný funkcí <code class="highlighter-rouge">initialSeed</code> dával smysl.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kt">Seed</span>
    <span class="p">{</span> <span class="n">state</span> <span class="o">=</span> <span class="kt">State</span> <span class="mi">31416</span> <span class="mi">1</span>
    <span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
    <span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
    <span class="p">,</span> <span class="n">range</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
    <span class="p">}</span> <span class="o">:</span> <span class="kt">Random</span><span class="o">.</span><span class="kt">Seed</span></code></pre></figure>

<p>Nyní, když máme počáteční seed, můžeme použít funkci <code class="highlighter-rouge">Random.step</code> ke generování náhodné hodnoty.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Random</span><span class="o">.</span><span class="n">step</span> <span class="p">(</span><span class="kt">Random</span><span class="o">.</span><span class="n">int</span> <span class="mi">0</span> <span class="mi">100</span><span class="p">)</span> <span class="n">seed0</span></code></pre></figure>

<p>Výstup z tohoto výrazu se těžko čte. Takto ale vypadá po menším formátování:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span> <span class="mi">48</span><span class="p">,</span>
  <span class="kt">Seed</span>
     <span class="p">{</span> <span class="n">state</span> <span class="o">=</span> <span class="kt">State</span> <span class="mi">1257079824</span> <span class="mi">40692</span>
     <span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
     <span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
     <span class="p">,</span> <span class="n">range</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
     <span class="p">}</span>
<span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Random</span><span class="o">.</span><span class="kt">Seed</span> <span class="p">)</span></code></pre></figure>

<p>Výše uvedený výstup je entice. První element je náhodné číslo a druhý element je seed, který můžeme použít ke generování dalšího náhodného čísla. Jak již dříve zmíněno, potřebujeme funkci <code class="highlighter-rouge">step</code> zadat jiný seed pokaždé, když chceme generovat nové náhodné číslo. Jinak bychom dostávali stále stejné číslo. Proto funkce <code class="highlighter-rouge">step</code> vrací s náhodným číslem i nový seed.</p>

<p><img src="images/random-step-function-syntax.png" alt="" /></p>

<p>Funkce <code class="highlighter-rouge">step</code> přijímá jako vstup generátor náhodného čísla a seed. Takto vypadá její signatura typu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">step</span> <span class="o">:</span> <span class="kt">Generator</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Seed</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Seed</span><span class="p">)</span></code></pre></figure>

<p>Výraz <code class="highlighter-rouge">Random.int 0 100</code>, který jsme zadali do replu, vytváří generátor, který produkuje náhodná čísla 32-bitová celá čísla mezi <code class="highlighter-rouge">0</code> a <code class="highlighter-rouge">100</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Random</span><span class="o">.</span><span class="n">int</span> <span class="mi">0</span> <span class="mi">100</span>
<span class="kt">Generator</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">Random</span><span class="o">.</span><span class="kt">Generator</span> <span class="kt">Int</span></code></pre></figure>

<p>Je důležité si uvědomit, že samotná fukce <code class="highlighter-rouge">Random.int</code> negeneruje náhodné číslo. Vrací <em>generátor</em>, který může být zadán jiné funkci, jako je <code class="highlighter-rouge">step</code>, která teprve požádá tento generátor aby produkoval náhodná čísla. Nazírejte na generátor jako na předpis pro generování určitých typů náhodných čísel. Takto výraz <code class="highlighter-rouge">Random.int 0 100</code> popisuje jak vytvořit předpis pro generování celých čísel mezi <code class="highlighter-rouge">0</code> a <code class="highlighter-rouge">100</code>. Podobně, výraz <code class="highlighter-rouge">Random.float 0 1</code> předepisuje jak vytvořit předpis pro generování desetinných náhodných čísel mezi <code class="highlighter-rouge">0</code> a <code class="highlighter-rouge">1</code>.</p>

<p>V dalším kroku podchytíme nový seed, vrácený funkcí <code class="highlighter-rouge">step</code>, abychom jej mohli použít ke generování jiného náhodného čísla.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="kt">Random</span><span class="o">.</span><span class="n">step</span> <span class="p">(</span><span class="kt">Random</span><span class="o">.</span><span class="n">int</span> <span class="mi">0</span> <span class="mi">100</span><span class="p">)</span> <span class="n">seed0</span>
<span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="kt">Seed</span> <span class="p">{</span> <span class="n">state</span> <span class="o">=</span> <span class="kt">State</span> <span class="mi">1257079824</span> <span class="mi">40692</span><span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">range</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="p">})</span>
    <span class="o">:</span> <span class="p">(</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Random</span><span class="o">.</span><span class="kt">Seed</span> <span class="p">)</span>

<span class="o">&gt;</span> <span class="n">randomNumber</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="o">.</span><span class="n">first</span> <span class="n">result</span>
<span class="mi">48</span> <span class="o">:</span> <span class="kt">Int</span>

<span class="o">&gt;</span> <span class="n">newSeed</span> <span class="o">=</span> <span class="kt">Tuple</span><span class="o">.</span><span class="n">second</span> <span class="n">result</span>
<span class="kt">Seed</span> <span class="p">{</span> <span class="n">state</span> <span class="o">=</span> <span class="kt">State</span> <span class="mi">1257079824</span> <span class="mi">40692</span><span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">range</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="p">}</span>
    <span class="o">:</span> <span class="kt">Random</span><span class="o">.</span><span class="kt">Seed</span></code></pre></figure>

<p>Nyní jsme připraveni generovat nové náhodné číslo.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Random</span><span class="o">.</span><span class="n">step</span> <span class="p">(</span><span class="kt">Random</span><span class="o">.</span><span class="n">int</span> <span class="mi">0</span> <span class="mi">100</span><span class="p">)</span> <span class="n">newSeed</span></code></pre></figure>

<p>Zde je výstup po jistém formátování:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span> <span class="mi">26</span><span class="p">,</span>
  <span class="kt">Seed</span>
     <span class="p">{</span> <span class="n">state</span> <span class="o">=</span> <span class="kt">State</span> <span class="mi">284581387</span> <span class="mi">1655838864</span>
     <span class="p">,</span> <span class="n">next</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
     <span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
     <span class="p">,</span> <span class="n">range</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
     <span class="p">}</span>
<span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Random</span><span class="o">.</span><span class="kt">Seed</span> <span class="p">)</span></code></pre></figure>

<p>Tentokrát jsme dostali <code class="highlighter-rouge">26</code> jako nové číslo. Předtím to bylo <code class="highlighter-rouge">48</code>. Čísla uvnitř vlastnosti <code class="highlighter-rouge">state</code> se také změnila. Kdyby se neměnila, dostávali bychom znovu a znovu stejné číslo. Z toho plyne, že <code class="highlighter-rouge">Random.step</code> je <em>čistá funkce</em> a nevytváří žádné vedlejší účinky. Pro tentýž vstup vždy vrací stejný výstup.</p>

<h4 id="generating-random-numbers-with-side-effects">Generování náhodných čísel s vedlejšími účinky</h4>

<p>Postup s ručním zadáváním počátečních hodnot má tu nevýhodu, že činí posloupnost náhodných čísel předvídatelnou. Elm nabízí způsob, jímž se lze této nevýhody zbavit volbou nepředvídatelné počáteční hodnoty. Činí tak s použitím reálného času, generovaného <a href="https://en.wikipedia.org/wiki/Real-time_clock" target="_blank">počítačem</a> pro vytvoření hodnoty seed.</p>

<p>Jakmile však předáme Elmu zodpovědnost za výběr počáteční hodnoty, vytváří generování náhodného čísla vedlejší účinky. Pro získání počáteční hodnoty musí komunikovat s reálným časem počítače, což je součást reálného světa. To je chvíle, kdy přicházejí ke slovu příkazy.</p>

<p><img src="images/get-current-time.png" alt="" /></p>

<p>Abychom generovali náhodná čísla s vedlejšími účinky, musíme využít Elm Architecture. Napsat plně vybavený program v replu je obtížné, proto vytvoříme nový soubor <code class="highlighter-rouge">RandomNumber.elm</code> v adresáři <code class="highlighter-rouge">beginning-elm/elm-examples</code>.</p>

<p><img src="images/create-random-number-elm.png" alt="" /></p>

<h3 id="model">Model</h3>

<p>První věc, kterou potřebujeme definovat, je náš model. Přidejte následující kód so souboru <code class="highlighter-rouge">RandomNumber.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">RandomNumber</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>


<span class="kr">type</span> <span class="n">alias</span> <span class="kt">Model</span> <span class="o">=</span>
    <span class="kt">Int</span></code></pre></figure>

<p>Vše, co zde potřebujeme sledovat, je číslo. Výše uvedený model vypadá stejně jako ten, který jsme definovali pro aplikaci počítadla v sekci <a href="model-view-update-part-1.html#model" target="_blank">Skladba EA - část 1</a>. Dále potřebujeme vytvořit počáteční model. Přidejte následující kód na spodek souboru <code class="highlighter-rouge">RandomNumber.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">init</span> <span class="o">:</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="n">msg</span> <span class="p">)</span>
<span class="n">init</span> <span class="o">=</span>
    <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">Cmd</span><span class="o">.</span><span class="n">none</span> <span class="p">)</span></code></pre></figure>

<p>Jsou-li zahtnuty příkazy 'comnands', stává se kód pro inicializaci našeho  modelu poněkud složitější. Vše co jsme v aplikaci "counter" museli udělat, bylo vrátit celé číslo, jak ukázáno níže.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">initialModel</span> <span class="o">:</span> <span class="kt">Model</span>
<span class="n">initialModel</span> <span class="o">=</span>
    <span class="mi">0</span></code></pre></figure>

<p>Projděme si  změnu za zněmou.</p>

<p><strong>Změna #1:</strong> Název funkce se změnil z <code class="highlighter-rouge">initialModel</code> na <code class="highlighter-rouge">init</code>, protože provádíme víc, než pouhou inicializaci modelu.</p>

<p><strong>Změna #2:</strong> Funkce <code class="highlighter-rouge">init</code> nyní vrací entici. První element reprezentuje model a druhý element reprezentuje příkazy. Kromě poskytnutí počáteční hodnoty našemu modelu, potřebujeme runtime Elmu říci, které příkazy má spustit při načtení naší aplikace. Protože na začátku nechceme spustit žádné příkazy, vracíme jednoduše <code class="highlighter-rouge">Cmd.none</code>. Typ <code class="highlighter-rouge">Cmd</code> je definován v modulu <a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Platform-Cmd" target="_blank"><code class="highlighter-rouge">Platform.Cmd</code></a> a reprezentuje příkazy v Elmu. Entita <code class="highlighter-rouge">none</code> je konstanta, rovněž definovaná v modulu <code class="highlighter-rouge">Platform.Cmd</code>. Vrazí prázdný seznam příkazů.</p>

<p>Řekněme, že chceme obnovit stav naší aplikace při jejím spuštění. Stav předchozího spuštění mohl být uložen v lokálním uložišti nebo na vzdáleném serveru. Obě tato uložiště leží mimo hranice naší aplikace. Proto se musíme spolehnout na runtime Elmu, že si potřebnou hodnotu stavu vyzvedne vrácením příkazu z funkce  <code class="highlighter-rouge">init</code>.</p>

<p><img src="images/reload-state.png" alt="" /></p>

<p><strong>Změna #3:</strong> Anotace typu se také změnila na <code class="highlighter-rouge">init : ( Model, Cmd msg )</code>. Již víme, co to <code class="highlighter-rouge">Model</code> je. Evokace <code class="highlighter-rouge">Cmd msg</code> je příkaz, který seznámí naši aplikaci s výsledky zasláním sdělení typu <code class="highlighter-rouge">msg</code>. Označení <code class="highlighter-rouge">msg</code> je pouze proměnná typu, takže nepředstavuje konkretní typ. Později v této sekci budeme definovat typ, zvaný <code class="highlighter-rouge">Msg</code> aby bylo zřjemé, které sdělení má být posláno naši aplikaci.</p>

<h3 id="view">View</h3>

<p>Dále potřebujeme prezentovat náš počáteční model uživateli. Přidejte následující kód na spodek souboru <code class="highlighter-rouge">RandomNumber.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">view</span> <span class="o">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span> <span class="n">msg</span>
<span class="n">view</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">div</span> <span class="kt">[]</span>
        <span class="p">[</span> <span class="n">button</span> <span class="kt">[]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"Generate Random Number"</span> <span class="p">]</span>
        <span class="p">,</span> <span class="n">text</span> <span class="p">(</span><span class="n">toString</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">]</span></code></pre></figure>

<p>Naše zobrazení (view) je velmi prosté. Vše, co zjevujeme, je tlačítko a řetězcová prezentace náhodného čísla. Potřebujeme také importovat modul <code class="highlighter-rouge">Html</code> v souboru <code class="highlighter-rouge">RandomNumber.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">RandomNumber</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Html</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="o">.</span>
<span class="o">.</span></code></pre></figure>

<h3 id="application-entry-point">Vstupní bod aplikace</h3>

<p>Abychom mohli zobrazit view, potřebujeme pro naši aplikace definovat vstupní bod. Přidejte následující kód na spodek souboru <code class="highlighter-rouge">RandomNumber.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">main</span> <span class="o">:</span> <span class="kt">Program</span> <span class="kt">Never</span> <span class="kt">Model</span> <span class="n">msg</span>
<span class="n">main</span> <span class="o">=</span>
    <span class="n">program</span>
        <span class="p">{</span> <span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
        <span class="p">,</span> <span class="n">view</span> <span class="o">=</span> <span class="n">view</span>
        <span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="n">update</span>
        <span class="p">,</span> <span class="n">subscriptions</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Sub</span><span class="o">.</span><span class="n">none</span><span class="p">)</span>
        <span class="p">}</span></code></pre></figure>

<p>Se zavedením příkazů se funkce <code class="highlighter-rouge">main</code> stala také lehce složitější. Takto funkce <code class="highlighter-rouge">main</code> vypadala v aplikaci počítadla:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">main</span> <span class="o">:</span> <span class="kt">Program</span> <span class="kt">Never</span> <span class="kt">Model</span> <span class="n">msg</span>
<span class="n">main</span> <span class="o">=</span>
    <span class="n">beginnerProgram</span>
        <span class="p">{</span> <span class="n">model</span> <span class="o">=</span> <span class="n">initialModel</span>
        <span class="p">,</span> <span class="n">view</span> <span class="o">=</span> <span class="n">view</span>
        <span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="n">update</span>
        <span class="p">}</span></code></pre></figure>

<p>Nyní používáme funkci <code class="highlighter-rouge">program</code>, definovanou v modulu  <code class="highlighter-rouge">Html</code>, místo v modulu <code class="highlighter-rouge">beginnerProgram</code> abychom všechno propojili. Funkce <code class="highlighter-rouge">program</code> přijímá záznam se čtyřmi vlastnostmi. Jsme již obeznámeni s funkcemi <code class="highlighter-rouge">view</code> a <code class="highlighter-rouge">update</code>. Vlastnost <code class="highlighter-rouge">init</code> reprezentuje počáteční model a seznam příkazů, které mají být spuštěny při spuštění aplikace.</p>

<p><code class="highlighter-rouge">Subskripce</code> reprezentuje věci, kterým chceme naslouchat, například sdělení webového soketu a změny lokace. Přiřazením <code class="highlighter-rouge">(\_ -&gt; Sub.none)</code> dáváme runtime Elmu na vědomí, že nás žádné naslouchání aktuálně nezajímá.  
<a href="subscriptions.html" target="_blank">Subskripce</a> probereme podrobně později v této kapitole.</p>

<p>Jediná věc, kterou zbývá definovat, je funkce <code class="highlighter-rouge">update</code>. Přidejte následující kód hned nad funkci <code class="highlighter-rouge">main</code> v souboru <code class="highlighter-rouge">RandomNumber.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">update</span> <span class="o">:</span> <span class="n">msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="n">msg</span> <span class="p">)</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">init</span>


<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">update</code> jednoduše vrací výstup z funkce <code class="highlighter-rouge">init</code>. Poněkud ji rozšíříme do větší významnosti. Konečně jsme připraveni zobrazit naše view. Spusťte  <code class="highlighter-rouge">elm-reactor</code> z adresáře <code class="highlighter-rouge">beginning-elm</code> v terminálu a přejděte na stránku <a href="http://localhost:8000/elm-examples/RandomNumber.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/RandomNumber.elm</code></a>. Měl byste vidět "view", které (v počítači Mac) vypadá takto:</p>

<p><img src="images/generate-random-number-page.png" alt="" /></p>

<h3 id="update">Update</h3>

<p>Právě nyní nevykonává tlačítko <em>Generate Random Number</em> žádnou aktivitu. Definujme sdělení, které bude spuštěno při stisku tlačítka. Přidejte následující definici typu hned nad funkci  <code class="highlighter-rouge">update</code> v souboru <code class="highlighter-rouge">RandomNumber.elm</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Msg</span>
    <span class="o">=</span> <span class="kt">GenerateRandomNumber</span>


<span class="n">update</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Dále potřebujeme upravit funkci <code class="highlighter-rouge">update</code>, aby mohla reagovat na sdělení <code class="highlighter-rouge">GenerateRandomNumber</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">update</span> <span class="o">:</span> <span class="kt">Msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span> <span class="p">)</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="kt">GenerateRandomNumber</span> <span class="o">-&gt;</span>
            <span class="p">(</span> <span class="n">model</span><span class="p">,</span> <span class="kt">Random</span><span class="o">.</span><span class="n">generate</span> <span class="kt">NewRandomNumber</span> <span class="p">(</span><span class="kt">Random</span><span class="o">.</span><span class="n">int</span> <span class="mi">0</span> <span class="mi">100</span><span class="p">)</span> <span class="p">)</span></code></pre></figure>

<p>Anotace typu pro funkci <code class="highlighter-rouge">update</code> nyní používá typ <code class="highlighter-rouge">Msg</code> místo proměnné <code class="highlighter-rouge">msg</code>, takže nezapomeňte provést i tuto změnu. Pokud už nevíte, jaký je rozdíl mezi proměnnou typu<code class="highlighter-rouge">msg</code> a  sdruženým (union) typem <code class="highlighter-rouge">Msg</code> měl byste si opět přečíst odstavec <a href="model-view-update-part-1.html#update" target="_blank">Update</a> sekce "Skladba EA - část 1".</p>

<p>Funkce <code class="highlighter-rouge">update</code> nyní vrací entici, obsahující model a příkazy místo pouhého modelu. Všimněte si, že funkce <code class="highlighter-rouge">update</code> a <code class="highlighter-rouge">init</code> (nebo <code class="highlighter-rouge">initialModel</code> v předchozích sekcích) mají tendenci mít stejné typy výstupů. Zde je pro srovnání funkce <code class="highlighter-rouge">update</code> z aplikace počítadla:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">update</span> <span class="o">:</span> <span class="kt">Msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Model</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="kt">Increment</span> <span class="o">-&gt;</span>
            <span class="n">model</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="kt">Decrement</span> <span class="o">-&gt;</span>
            <span class="n">model</span> <span class="o">-</span> <span class="mi">1</span></code></pre></figure>

<p>Zkusme rozumět tomu, co se děje v těle nové funkce <code class="highlighter-rouge">update</code>. Po přijetí sdělení <code class="highlighter-rouge">GenerateRandomNumber</code> vracíme nezměněný model a příkaz pro generování náhodného čísla. Příkaz je generován s použitím funkce <code class="highlighter-rouge">generate</code>, definované v modulu <code class="highlighter-rouge">Random</code>.</p>

<p class="info">V Elmu se nesnažíme vytvářet příkazy přímo prostřednictvím konstruktorových funkcí. Místo toho se spoléháme na funkce jako <code class="highlighter-rouge">generate</code>. Zde je další příklad: řekněme, že chceme vytvořit příkaz, který posílá HTML požadavek na vzdálený server. Můžeme pro generování tohoto příkazu použít funkci <a href="http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http#send" target="_blank"><code class="highlighter-rouge">Http.send</code></a> 
. Pouze vyhledáme v modulu vhodnou funkci a použijeme ji k vytvoření příkazu.</p>

<p>Funkce <code class="highlighter-rouge">generate</code> se pokouší dosáhnout stejného cíle jako funkce <code class="highlighter-rouge">step</code> — generovat náhodné číslo. Způsob, kterým tohoto cíle dosahuje, je velmi odlišný. Funkce <code class="highlighter-rouge">step</code> používá generátor a seed zároveň.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Random</span><span class="o">.</span><span class="n">step</span> <span class="p">(</span><span class="kt">Random</span><span class="o">.</span><span class="n">int</span> <span class="mi">0</span> <span class="mi">100</span><span class="p">)</span> <span class="n">seed0</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">generate</code> na druhé straně, přijímá generátor a říká runtime Elmu aby ten generátor spustil. Také předává Elmu jméno sdělení, které by runtime mělo poslat, když je číslo hotové. Sdělení <code class="highlighter-rouge">NewRandomNumber</code> jsme dosud nedefinovali, učiníme tak záhy.</p>

<p><img src="images/random-generate-function-syntax.png" alt="" /></p>

<p>Proč musíme funkci <code class="highlighter-rouge">generate</code> poskytovat sdělení? Proč tato funkce nemůže vrátit náhodné číslo hned, stejně jako funkce <code class="highlighter-rouge">step</code>? Je to v důsledku toho, že již neposkytujeme počáteční hodnotu seedu. Seed musíme generovat s použitím hodin počítače, což produkuje vedlejší účinky.</p>

<p>Abychom mohli spouštět věci, které vytvářejí vedlejší účinky, Elm od nás požaduje, abychom vytvořili příkaz s patřičnou informací. Tento příkaz potom předáme runtime Elmu. Runtime provede příkaz a uvědomí naši aplikaci o výsledku zasláním sdělení, přiložené k příkazu.</p>

<p><img src="images/elm-runtime-interaction-command.png" alt="" /></p>

<p>Takto vypadá signatura typu funkce <code class="highlighter-rouge">generate</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">generate</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Generator</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Cmd</span> <span class="n">msg</span></code></pre></figure>

<p>První argument je funkce, která přijímá hodnotu a zabalí ji do sdělení. V našem případě to je <code class="highlighter-rouge">NewRandomNumber</code>. Vzpomeňte si, že sdělení, která přijímají argumenty, jsou vpodstatě funkce. Prověříte-li funkci <code class="highlighter-rouge">NewRandomNumber</code> v replu, uvidíte, že přijímá celé číslo a vrací sdělení typu <code class="highlighter-rouge">Msg</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">type</span> <span class="kt">Msg</span> <span class="o">=</span> <span class="kt">NewRandomNumber</span> <span class="kt">Int</span>

<span class="o">&gt;</span> <span class="kt">NewRandomNumber</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Repl</span><span class="o">.</span><span class="kt">Msg</span></code></pre></figure>

<p>Druhým argumentem pro funkci <code class="highlighter-rouge">generate</code> je generátor náhodného čísla. V našem případě to je <code class="highlighter-rouge">Random.int</code>, která jako vstup příjímá rozsah (tj., <code class="highlighter-rouge">0 100</code>). Posléze vrací funkce <code class="highlighter-rouge">generate</code> 
příkaz, který zapouzdří sdělení a generátor. Dalším krokem je přidat funkci <code class="highlighter-rouge">NewRandomNumber</code> k typu <code class="highlighter-rouge">Msg</code> a ošetřit to ve funkci <code class="highlighter-rouge">update</code>, jak ukázáno níže.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">Msg</span>
    <span class="o">=</span> <span class="kt">GenerateRandomNumber</span>
    <span class="o">|</span> <span class="kt">NewRandomNumber</span> <span class="kt">Int</span>


<span class="n">update</span> <span class="o">:</span> <span class="kt">Msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span> <span class="p">)</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="kt">GenerateRandomNumber</span> <span class="o">-&gt;</span>
            <span class="p">(</span> <span class="n">model</span><span class="p">,</span> <span class="kt">Random</span><span class="o">.</span><span class="n">generate</span> <span class="kt">NewRandomNumber</span> <span class="p">(</span><span class="kt">Random</span><span class="o">.</span><span class="n">int</span> <span class="mi">0</span> <span class="mi">100</span><span class="p">)</span> <span class="p">)</span>

        <span class="kt">NewRandomNumber</span> <span class="n">number</span> <span class="o">-&gt;</span>
            <span class="p">(</span> <span class="n">number</span><span class="p">,</span> <span class="kt">Cmd</span><span class="o">.</span><span class="n">none</span> <span class="p">)</span></code></pre></figure>

<p>Když je sdělení <code class="highlighter-rouge">NewRandomNumber</code> přijato, vrací se číslo v payloadu jako náš model spolu s prázdným seznamem příkazů. Rovněž jsme nahradili proměnnou <code class="highlighter-rouge">msg</code> typem <code class="highlighter-rouge">Msg</code> v anotaci funkce <code class="highlighter-rouge">update</code>. Dále provedeme import modulů  <code class="highlighter-rouge">Html.Events</code> a <code class="highlighter-rouge">Random</code> a přidáme atribut <code class="highlighter-rouge">onClick</code> našemu tlačítku, aby bylo sdělení <code class="highlighter-rouge">GenerateRandomNumber</code> spuštěno při stisku tlačítka.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">RandomNumber</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Html</span> <span class="n">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Html.Events</span> <span class="n">exposing</span> <span class="p">(</span><span class="n">onClick</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Random</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="n">view</span> <span class="o">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span> <span class="kt">Msg</span>
<span class="n">view</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">div</span> <span class="kt">[]</span>
        <span class="p">[</span> <span class="n">button</span> <span class="p">[</span> <span class="n">onClick</span> <span class="kt">GenerateRandomNumber</span> <span class="p">]</span>
            <span class="p">[</span> <span class="n">text</span> <span class="s">"Generate Random Number"</span> <span class="p">]</span>
        <span class="p">,</span> <span class="n">text</span> <span class="p">(</span><span class="n">toString</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">]</span></code></pre></figure>

<p>Nezapomeňte zaměnit proměnnou <code class="highlighter-rouge">msg</code> za typ <code class="highlighter-rouge">Msg</code> v anotaci typu funkce <code class="highlighter-rouge">view</code>
. Tuto záměnu potřebujeme rovněž provést ve funkcích <code class="highlighter-rouge">init</code> a <code class="highlighter-rouge">main</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">init</span> <span class="o">:</span> <span class="p">(</span> <span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span> <span class="p">)</span>
<span class="n">init</span> <span class="o">=</span>
    <span class="o">...</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="n">main</span> <span class="o">:</span> <span class="kt">Program</span> <span class="kt">Never</span> <span class="kt">Model</span> <span class="kt">Msg</span>
<span class="n">main</span> <span class="o">=</span>
    <span class="o">...</span></code></pre></figure>

<p>Nyní jsme připraveni otestovat náš program. Obnovte stránku na <a href="http://localhost:8000/elm-examples/RandomNumber.elm" target="_blank"><code class="highlighter-rouge">http://localhost:8000/elm-examples/RandomNumber.elm</code></a> a měli byste nyní být schopni generovat náhodná čísla.</p>

<h3 id="summary">Summary</h3>

<p>V této sekci jsme se naučili používat příkazy k provádění operací, které vytvářejí vedlejší účinky. Takto vypadá schematické znázornění Elm Architecture se zahrnutím příkazů:</p>

<p><img src="images/model-view-update-commands.png" alt="" /></p>

<p>Interakce mezi runtime Elmu a naším kódem se také s použitím příkazů poněkud zkomplikovala. Sekvenční diagram dole tuto interakci zobrazuje.</p>

<p><img src="images/elm-runtime-mvu-commands.png" alt="" /></p>

<p>Příkazy jsou v Elmu důležitým konceptem. Potřebujeme jim dobře rozumět abychom byli schopni vytvářet komplexní aplikace v Elmu.<br>
V následující sekci budeme pokračovat ve zkoumání, kterak nám mohou příkazy pomoci provádět tu nejobvyklejší operaci webových aplikací - posílání a příjímání dat ze vzdáleného serveru HTTP a to bez obětování čistoty naši aplikace.</p>
</article>

<nav class="pagination">
<a class="pagination-next" href="side-effects.html">
<em>&larr; Previous</em>
<strong>Vedlejší účinky</strong>
</a>
<a class="pagination-next" href="http-requests.html">
<em>Next &rarr;</em><strong>HTTP requests</strong>
</a>
<a class="elevator" href="aa-index.html"><i class="fa fa-angle-up"></i>
<span>Back to top</span>
</a>
</nav>

</div>
</div>



<footer id="footer" class="page-footer">
<footer class="container">
 <p>Copyright © 2016 Pawan Poudel. All Rights Reserved.</p>
</footer>
</footer>

  </body>
</html>
