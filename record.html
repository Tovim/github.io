<!DOCTYPE html>

<html lang="cs">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title> - Beginning Elm</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/main.css">
<!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">    deformuje zobrazení font awsome -->
</head>

<body>

<section class="heading">
<h1> 3.19 </h1>
<h2>Record - záznam</h2>
</section>

<div class="page-content">
<div class="container">

<div class="breadcrumb-holder">
<header id="breadcrumb" class="breadcrumb">
<a href="aa-index.html" class="breadcrumb-toggle">
  <span></span>
  <span></span>
  <span></span>
</a>

<span class="breadcrumb-section">syntaxe</span>

<a class="breadcrumb-next" href="benefits-intro.html">
<i class="fa fa-angle-right"></i><span>Next article</span>
</a>
<a class="breadcrumb-previous" href="tuple.html">
<i class="fa fa-angle-left"></i><span>Previous article</span>
</a>
          
</header>
</div>

<article class="content">
<p>Stejně jako entice mohou záznamy (records) obsahovat hodnoty různého typu, avšak jsou mnohem flexibilnější než entice.</p>

<h3 id="creating-a-record">Vytvoření záznamu</h3>

<p>Záznamy se píší do složených závorek a jejich elementy jsou odděleny čárkami.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span> <span class="p">}</span></code></pre></figure>

<p>Na rozdíl od datových struktur které jsme dosud poznali, nám záznamy umožňují dávat jména hodnotám jednotlivých elementů.</p>

<p><img src="images/record-syntax.png" alt="" /></p>

<p>Přiřaďme výše uvedený záznam konstantě a vytvořme několik dalších.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">firefly</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="n">fringe</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringe"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"J. J. Abrams"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringe"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"J. J. Abrams"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="n">vice</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Vice"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Shane Smith"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">58</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Vice"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Shane Smith"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">58</span> <span class="p">}</span></code></pre></figure>

<p>Vytvořili jsme tři záznamy s informacemi o populární televizní show. Vložme je všechny do seznamu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">tvShows</span> <span class="o">=</span> <span class="p">[</span> <span class="n">firefly</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">vice</span> <span class="p">]</span>
<span class="o">...</span></code></pre></figure>

<p>Zde je výstup po určitém formátování kvůli lepšímu vzhledu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">[</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringe"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"J. J. Abrams"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">100</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Vice"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"Shane Smith"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">58</span>
  <span class="p">}</span>
<span class="p">]</span></code></pre></figure>

<p>Vytváření záznamů pomocí literální syntaxe (t.j. se složenými závorkami) může být únavné. Existuje lepší způsob? Zjistěmež to. Nejprve dejme struktuře, které podléhá každý ze tří právě vytvořených záznamů, jméno.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">type</span> <span class="n">alias</span> <span class="kt">TVShow</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">creator</span> <span class="o">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">:</span> <span class="kt">Int</span> <span class="p">}</span></code></pre></figure>

<p>Idiom <code class="highlighter-rouge">type alias</code> přiřazuje jméno <code class="highlighter-rouge">TVShow</code> deklarovanému typu. Nyní můžeme pomocí tohoto typu vytvářet záznamy mnohem jednodušeji.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">firefly</span> <span class="o">=</span> <span class="kt">TVShow</span> <span class="s">"Firefly"</span> <span class="s">"Joss Whedon"</span> <span class="mi">14</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="n">fringe</span> <span class="o">=</span> <span class="kt">TVShow</span> <span class="s">"Fringe"</span> <span class="s">"J. J. Abrams"</span> <span class="mi">100</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringe"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"J. J. Abrams"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="n">vice</span> <span class="o">=</span> <span class="kt">TVShow</span> <span class="s">"Vice"</span> <span class="s">"Shane Smith"</span> <span class="mi">58</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Vice"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Shane Smith"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">58</span> <span class="p">}</span></code></pre></figure>

<p>S touto novou syntaxí se záznamy vytvářejí uvedením jména  <code class="highlighter-rouge">TVShow</code>, následovaného  názvem, tvůrcem a počtem episod. Tato syntaxe je povědomá, není-liž pravda? Je to vpodstatě aplikace funkce. Idiom <code class="highlighter-rouge">type alias</code> vytvořil pojmenovanou funkci pro vytváření záznamů s danou strukturou.</p>

<p><img id="record-constructor-function" src="images/record-constructor-function.png" /></p>

<p>Je důležité poznamenat, že při použití <code class="highlighter-rouge">type alias</code> pro deklaraci struktury záznamu, musíme použít <code class="highlighter-rouge">:</code>  nikoliv <code class="highlighter-rouge">=</code> k oddělení názvů vlastností a jejich typů.</p>

<p><img src="images/record-type-alias-syntax.png" alt="" /></p>

<h3 id="accessing-values">Přístup k hodnotám</h3>

<p>Záznamy jsou hodnoty jako všechno jiné v Elmu. Můžeme je zadat funkci jako argument, upravovat je a vracet zpět. Vytvořme funkci, která ověří, zda záznam pro TV show má tvůrce.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">hasCreator</span> <span class="n">tvShow</span> <span class="o">=</span> <span class="kt">String</span><span class="o">.</span><span class="n">length</span> <span class="n">tvShow</span><span class="o">.</span><span class="n">creator</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>

<span class="o">&gt;</span> <span class="n">hasCreator</span> <span class="n">firefly</span>
<span class="kt">True</span>

<span class="o">&gt;</span> <span class="n">got</span> <span class="o">=</span> <span class="kt">TVShow</span> <span class="s">"Game of Thrones"</span> <span class="s">""</span> <span class="mi">60</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Game of Thrones"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">""</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">60</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="n">hasCreator</span> <span class="n">got</span>
<span class="kt">False</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">hasCreator</code> přistupuje k hodnotě vlastnosti <code class="highlighter-rouge">creator</code> s použitím tečkové notace. Zde je několik dalších příkladů:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">firefly</span><span class="o">.</span><span class="n">name</span>
<span class="s">"Firefly"</span>

<span class="o">&gt;</span> <span class="n">firefly</span><span class="o">.</span><span class="n">creator</span>
<span class="s">"Joss Whedon"</span>

<span class="o">&gt;</span> <span class="n">firefly</span><span class="o">.</span><span class="n">episodes</span>
<span class="mi">14</span></code></pre></figure>

<h4 id="special-accessor-functions">Specielní přístupové funkce</h4>

<p>Druhý způsob přístupu k elementu v záznamu je s pomocí specielní funkce.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="o">.</span><span class="n">name</span> <span class="n">firefly</span>
<span class="s">"Firefly"</span>

<span class="o">&gt;</span> <span class="o">.</span><span class="n">creator</span> <span class="n">firefly</span>
<span class="s">"Joss Whedon"</span>

<span class="o">&gt;</span> <span class="o">.</span><span class="n">episodes</span> <span class="n">firefly</span>
<span class="mi">14</span></code></pre></figure>

<p>Specielním formátem tečkové notace jsou specielní funkce <code class="highlighter-rouge">.name</code>, <code class="highlighter-rouge">.creator</code> a <code class="highlighter-rouge">.episodes</code>, vytvořené za scénou při deklaraci záznamu. Jsou dostupné i když při vytváření záznamu použijeme literálovou syntaxi místo konstruktorové funkce. Tyto fukce se však netvoří při použití idiomu <code class="highlighter-rouge">type alias</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">wire</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Wire"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"David Simon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">60</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Wire"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"David Simon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">60</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="o">.</span><span class="n">name</span> <span class="n">wire</span>
<span class="s">"The Wire"</span>

<span class="o">&gt;</span> <span class="o">.</span><span class="n">creator</span> <span class="n">wire</span>
<span class="s">"David Simon"</span>

<span class="o">&gt;</span> <span class="o">.</span><span class="n">episodes</span> <span class="n">wire</span>
<span class="mi">60</span></code></pre></figure>

<p>Proč jim řákáme specielní funkce? Za prvé, začínají tečkou. Normální funkce nesmí začínat specielním znakem. Za druhé, mohou být použity pouze u záznamu, který disponuje označením, shodujícím se s názvem specielní funkce. Zkusme je použít pro přístup k hodnotě v záznamu, která nemá stejné označení.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">sapiens</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Sapiens"</span><span class="p">,</span> <span class="n">author</span> <span class="o">=</span> <span class="s">"Yuval Harari"</span><span class="p">,</span> <span class="n">published</span> <span class="o">=</span> <span class="mi">2015</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Sapiens"</span><span class="p">,</span> <span class="n">author</span> <span class="o">=</span> <span class="s">"Yuval Harari"</span><span class="p">,</span> <span class="n">published</span> <span class="o">=</span> <span class="mi">2015</span> <span class="p">}</span>

<span class="o">&gt;</span> <span class="o">.</span><span class="n">creator</span> <span class="n">sapiens</span>

<span class="c1">------------------ TYPE MISMATCH --------------------</span>
<span class="kt">The</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">this</span> <span class="n">function</span> <span class="n">is</span> <span class="n">causing</span> <span class="n">a</span> <span class="n">mismatch</span><span class="o">.</span>

<span class="mi">8</span><span class="o">|</span>   <span class="o">.</span><span class="n">creator</span> <span class="n">sapiens</span>
              <span class="o">^^^^^^^</span>
<span class="kt">This</span> <span class="n">function</span> <span class="n">is</span> <span class="n">expecting</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">be</span><span class="o">:</span>

    <span class="p">{</span> <span class="n">b</span> <span class="o">|</span> <span class="n">creator</span> <span class="o">:</span> <span class="o">...</span> <span class="p">}</span>

<span class="kt">But</span> <span class="n">it</span> <span class="n">is</span><span class="o">:</span>

    <span class="p">{</span> <span class="n">author</span> <span class="o">:</span> <span class="o">...</span><span class="p">,</span> <span class="n">name</span> <span class="o">:</span> <span class="o">...</span><span class="p">,</span> <span class="n">published</span> <span class="o">:</span> <span class="o">...</span> <span class="p">}</span></code></pre></figure>

<p>Což takhle <code class="highlighter-rouge">.name</code>? Oba záznamy mají označení s názvem <code class="highlighter-rouge">name</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="o">.</span><span class="n">name</span> <span class="n">sapiens</span>
<span class="s">"Sapiens"</span></code></pre></figure>

<p>To chodí, protože funkce <code class="highlighter-rouge">.name</code> není vázána k žádnému ze záznamů, vytvořených před <code class="highlighter-rouge">sapiens</code> (?až na name.wire). Jediné, o co se zajímá je to, zda má záznam označení (label) <code class="highlighter-rouge">name</code> či nikoliv. Tyto specielní funkce jsou v podstatě ekvivalentní k:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">record</span> <span class="o">-&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="o">.</span><span class="n">creator</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">record</span> <span class="o">-&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">creator</span><span class="p">)</span>

<span class="o">.</span><span class="n">episodes</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">record</span> <span class="o">-&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">episodes</span><span class="p">)</span></code></pre></figure>

<p>Tyto (anonymní) funkce přijímají záznam a vracejí hodnotu, reprezentovanou jeho označením.</p>

<h3 id="sorting-records">Třídění záznamů</h3>

<p>Co získáváme, majíce specielní funkce pro přístup k hodnotám záznamu? Konec konců obyčejná tečková notace pracuje stejně dobře a navíc působí přirozeněji. Abychom pochopili jejich užitečnost, zkusme třídit jednotlivá televizní show podle počtu jejich episod.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">sortByEpisodes</span> <span class="n">tvShow1</span> <span class="n">tvShow2</span> <span class="o">=</span> <span class="n">compare</span> <span class="n">tvShow1</span><span class="o">.</span><span class="n">episodes</span> <span class="n">tvShow2</span><span class="o">.</span><span class="n">episodes</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>

<span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">sortWith</span> <span class="n">sortByEpisodes</span> <span class="p">[</span><span class="n">fringe</span><span class="p">,</span> <span class="n">firefly</span><span class="p">,</span> <span class="n">vice</span><span class="p">,</span> <span class="n">wire</span><span class="p">]</span>
<span class="o">...</span></code></pre></figure>

<p>Takto vypadá výstup po menších úpravách:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">[</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Vice"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"Shane Smith"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">58</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Wire"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"David Simon"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">60</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringe"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"J. J. Abrams"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">100</span>
  <span class="p">}</span>
<span class="p">]</span></code></pre></figure>

<p>Pamatujete se na funkci <code class="highlighter-rouge">sortWith</code> z modulu <code class="highlighter-rouge">List</code>? Používali jsme ji ke třídění číselných seznamů v sestupném pořadí:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">descending</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">compare</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">of</span>
        <span class="kt">LT</span> <span class="o">-&gt;</span>
            <span class="kt">GT</span>

        <span class="kt">GT</span> <span class="o">-&gt;</span>
            <span class="kt">LT</span>

        <span class="kt">EQ</span> <span class="o">-&gt;</span>
            <span class="kt">EQ</span>


<span class="kt">List</span><span class="o">.</span><span class="n">sortWith</span> <span class="n">descending</span> <span class="p">[</span> <span class="mi">316</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">337</span><span class="p">,</span> <span class="mi">318</span><span class="p">,</span> <span class="mi">314</span> <span class="p">]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">sortWith</code> přijímá dva argumenty: komparační funkci a seznam, který má být tříděn. Funkce <code class="highlighter-rouge">sortByEpisodes</code> je naše komparační (porovnávací) funkce, která přijímá dvě TV show a jednoduše porovnává počet jejich episod. Jak se ukazuje, modul <code class="highlighter-rouge">List</code> poskytuje další funkci zvanou <code class="highlighter-rouge">sortBy</code>, která třídění seznamů velice usnadňuje.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">sortBy</span> <span class="o">.</span><span class="n">episodes</span> <span class="p">[</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">firefly</span><span class="p">,</span> <span class="n">vice</span><span class="p">,</span> <span class="n">wire</span> <span class="p">]</span>
<span class="o">...</span></code></pre></figure>

<p>Takto vypadá výstup po menších úpravách:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">[</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">14</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Vice"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"Shane Smith"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">58</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"The Wire"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"David Simon"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">60</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringe"</span><span class="p">,</span>
    <span class="n">creator</span> <span class="o">=</span> <span class="s">"J. J. Abrams"</span><span class="p">,</span>
    <span class="n">episodes</span> <span class="o">=</span> <span class="mi">100</span>
  <span class="p">}</span>
<span class="p">]</span></code></pre></figure>

<p>Místo vytváření oddělené komparační funkce, sdělíme funkci <code class="highlighter-rouge">sortBy</code> kterou vlastnost má použít při třídění záznamů. Funkce <code class="highlighter-rouge">sortBy</code> potom porovná určené vlastnosti a podle vyhodnocení utřídí senzam. Prvním argumentem funkce <code class="highlighter-rouge">sortBy</code> musí být funkce. Protože <code class="highlighter-rouge">.episodes</code> je funkce, je absolutně korektní zadat ji funkci <code class="highlighter-rouge">sortBy</code>. Zde je další příklad funkce 
<code class="highlighter-rouge">sortBy</code>, která třídí seznam řetězců podle jejich délky.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">sortBy</span> <span class="kt">String</span><span class="o">.</span><span class="n">length</span> <span class="p">[</span> <span class="s">"Olivia"</span><span class="p">,</span> <span class="s">"Peter"</span><span class="p">,</span> <span class="s">"Walter"</span><span class="p">,</span> <span class="s">"Nina"</span> <span class="p">]</span>
<span class="p">[</span><span class="s">"Nina"</span><span class="p">,</span><span class="s">"Peter"</span><span class="p">,</span><span class="s">"Olivia"</span><span class="p">,</span><span class="s">"Walter"</span><span class="p">]</span></code></pre></figure>

<h3 id="mapping-records">Mapování záznamů</h3>

<p>V odstavci <a href="list.html#mapping-a-list" target="_blank">List</a> jsme viděli použití funkce <code class="highlighter-rouge">map</code> k vytvoření nového seznamu z výsledků aplikace dané funkce na každý element seznamu. Protože seznam může také obsahovat záznamy, můžeme použít funkci <code class="highlighter-rouge">map</code> k transformaci těchto záznamů na cokoli chceme.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">record</span> <span class="o">-&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="p">[</span> <span class="n">firefly</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">vice</span><span class="p">,</span> <span class="n">wire</span><span class="p">,</span> <span class="n">got</span> <span class="p">]</span>
<span class="p">[</span><span class="s">"Firefly"</span><span class="p">,</span><span class="s">"Fringe"</span><span class="p">,</span><span class="s">"Vice"</span><span class="p">,</span><span class="s">"The Wire"</span><span class="p">,</span><span class="s">"Game of Thrones"</span><span class="p">]</span></code></pre></figure>

<p>Vzali jsme seznam záznamů a transformovali jsme jej na seznam řetězců aplikováním anonymní funkce, která vrací hodnotu vlastnosti <code class="highlighter-rouge">name</code> každého záznamu. Můžeme učinit výraz <code class="highlighter-rouge">map</code> ještě přehlednější, když pro přístup k vlastnostem použijeme specielní funkci.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="o">.</span><span class="n">name</span> <span class="p">[</span> <span class="n">firefly</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">vice</span><span class="p">,</span> <span class="n">wire</span><span class="p">,</span> <span class="n">got</span> <span class="p">]</span>
<span class="p">[</span><span class="s">"Firefly"</span><span class="p">,</span><span class="s">"Fringe"</span><span class="p">,</span><span class="s">"Vice"</span><span class="p">,</span><span class="s">"The Wire"</span><span class="p">,</span><span class="s">"Game of Thrones"</span><span class="p">]</span></code></pre></figure>

<p>Jak vidíte, jsou specielní funkce docela užitečné, když chceme pouze vyjmout jednu vlastnost z každého záznamu a vložit ji od samostatného seznamu.</p>

<h3 id="modifying-a-record">Změna záznamu</h3>

<p>Na rozdíl od entic, hodnoty v záznamu můžeme měnit. Pamatujete si, že všechny hodnoty v Elmu jsou neměnitelné a stejně takové jsou záznamy. Z toho důvodu Elm ve skutečnosti nemění existující záznam. Vždy vrací nový záznam, který obsahuje změněné hodnoty. Abychom pochopili jak měnit záznam, vytvořme funkci, která zvětšuje počet epizod o jednu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">incrementEpisode</span> <span class="n">tvShow</span> <span class="o">=</span> <span class="p">{</span> <span class="n">tvShow</span> <span class="o">|</span> <span class="n">episodes</span> <span class="o">=</span> <span class="n">tvShow</span><span class="o">.</span><span class="n">episodes</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>

<span class="o">&gt;</span> <span class="n">firefly</span><span class="o">.</span><span class="n">episodes</span>
<span class="mi">14</span>

<span class="o">&gt;</span> <span class="n">incrementEpisode</span> <span class="n">firefly</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Firefly"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Joss Whedon"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">15</span> <span class="p">}</span></code></pre></figure>

<p>Jak můžeme vidět, počet episod se zvětšil na <code class="highlighter-rouge">15</code> ale když je vytiskneme pro záznam <code class="highlighter-rouge">firefly</code>, je to pořád <code class="highlighter-rouge">14</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">firefly</span><span class="o">.</span><span class="n">episodes</span>
<span class="mi">14</span></code></pre></figure>

<p>Elm nezměnil záznam, na nějž název <code class="highlighter-rouge">firefly</code> ukazuje. Vrátil nový. Syntaxe pro změnu záznamu vypadá poněku divně, není-li pravda? Zkusme ji rozebrat.</p>

<p><img src="images/record-modification-syntax.png" alt="" /></p>

<p>Můžeme modifikovat více vlastností najednou.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">{</span> <span class="n">fringe</span> <span class="o">|</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Alex Kurtzman"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="n">fringe</span><span class="o">.</span><span class="n">episodes</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringe"</span><span class="p">,</span> <span class="n">creator</span> <span class="o">=</span> <span class="s">"Alex Kurtzman"</span><span class="p">,</span> <span class="n">episodes</span> <span class="o">=</span> <span class="mi">101</span> <span class="p">}</span></code></pre></figure>

<p>Výrazy pro aktualizaci jednotlivých vlastností musí být odděleny čárkou. Je-li výraz příliš dlouhý na jeden řádek, je možné jej rozdělit do více řádků./p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="p">{</span> <span class="n">fringe</span> <span class="o">|</span> <span class="nf">\</span>
<span class="o">|</span>   <span class="n">name</span> <span class="o">=</span> <span class="s">"Fringgge"</span><span class="p">,</span> <span class="nf">\</span>
<span class="o">|</span>   <span class="n">creator</span> <span class="o">=</span> <span class="s">"Alex Kurtzman"</span><span class="p">,</span> <span class="nf">\</span>
<span class="o">|</span>   <span class="n">episodes</span> <span class="o">=</span> <span class="n">fringe</span><span class="o">.</span><span class="n">episodes</span> <span class="o">+</span> <span class="mi">1</span> <span class="nf">\</span>
<span class="o">|</span> <span class="p">}</span></code></pre></figure>

<p class="info">Na rozdíl od všech ostatních datových struktur, které jsme dosud prozkoumali, Elm neposkytuje samostatný modul pro záznamy. Je to proto, že kromě <a href="record.html#accessing-values" target="_blank">specielních  accessorů</a> neexistují žádné jiné funkce pro manipulaci se záznamy. I když to nezní příliš povzbudivě, lze pro úpravu záznamů mnohé dosíci použitím <a href="record.html#modifying-a-record" target="_blank">specielní syntaxe</a>. Navíc, specielní přístupové (accessor) funkce jsou generovány za pochodu poté, co byl záznam vytvořen. Tudíž nám není žádného modulu zapotřebí.</p>
</article>

<nav class="pagination">
<a class="pagination-next" href="tuple.html">
<em>&larr; Previous</em>
<strong>Entice</strong>
</a>
<a class="pagination-next" href="benefits-intro.html">
<em>Next &rarr;</em><strong>Výhody Elmu</strong>
</a>
<a class="elevator" href="aa-index.html"><i class="fa fa-angle-up"></i>
<span>Back to top</span>
</a>
</nav>

</div>
</div>



<footer id="footer" class="page-footer">
<footer class="container">
 <p>Copyright © 2016 Pawan Poudel. All Rights Reserved.</p>
</footer>
</footer>

  </body>
</html>
