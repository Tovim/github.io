<!DOCTYPE html>

<html lang="cs">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title> - Beginning Elm</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/main.css">
<!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">    deformuje zobrazení font awsome -->
</head>

<body>

<section class="heading">
<h1> 3.15 </h1>
<h2>Regular Expression</h2>
</section>

<div class="page-content">
<div class="container">

<div class="breadcrumb-holder">
<header id="breadcrumb" class="breadcrumb">
<a href="aa-index.html" class="breadcrumb-toggle">
  <span></span>
  <span></span>
  <span></span>
</a>

<span class="breadcrumb-section">syntaxe</span>

<a class="breadcrumb-next" href="list.html">
<i class="fa fa-angle-right"></i><span>Next article</span>
</a>
<a class="breadcrumb-previous" href="string.html">
<i class="fa fa-angle-left"></i><span>Previous article</span>
</a>
          
</header>
</div>

<article class="content">
<p>Zatím umíme vyjmout substring z řetězce určením jeho počátku a konce. Co když potřebujeme něco sofistikovanějšího? Řekněme, že chceme extrahovat časové údaje <em>(09:32 a.m.)</em> z informace o cestě Apolla 11:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kt">On</span> <span class="kt">July</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1969</span><span class="p">,</span> <span class="n">the</span> <span class="n">massive</span> <span class="kt">Saturn</span> <span class="kt">V</span> <span class="n">rocket</span> <span class="n">lifted</span>
<span class="n">off</span> <span class="n">from</span> <span class="kt">NASA's</span> <span class="kt">Kennedy</span> <span class="kt">Space</span> <span class="kt">Center</span> <span class="n">at</span> <span class="mi">09</span><span class="o">:</span><span class="mi">32</span> <span class="n">a</span><span class="o">.</span><span class="n">m</span><span class="o">.</span> <span class="kt">EDT</span><span class="o">.</span>
<span class="kt">Four</span> <span class="n">days</span> <span class="n">later</span><span class="p">,</span> <span class="n">on</span> <span class="kt">July</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">Neil</span> <span class="kt">Armstrong</span> <span class="n">and</span> <span class="kt">Buzz</span> <span class="kt">Aldrin</span>
<span class="n">landed</span> <span class="n">on</span> <span class="n">the</span> <span class="kt">Moon</span><span class="o">.</span></code></pre></figure>

<p>Je možné to provést s použitím funkcí pro řetězce ale je to rovněž úmorné. S regulárním výrazem (regular expression) to je procházka růžovým sadem, jakmile víme, jak na to.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Regex</span>
<span class="o">&gt;</span> <span class="n">pattern</span> <span class="o">=</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">regex</span> <span class="s">"</span><span class="se">\\</span><span class="s">d</span><span class="se">\\</span><span class="s">d:</span><span class="se">\\</span><span class="s">d</span><span class="se">\\</span><span class="s">d (a</span><span class="se">\\</span><span class="s">.m</span><span class="se">\\</span><span class="s">.|p</span><span class="se">\\</span><span class="s">.m</span><span class="se">\\</span><span class="s">.)"</span>
<span class="p">{}</span>

<span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="s">""" </span><span class="se">\</span><span class="err">
| O</span><span class="se">n</span><span class="s"> July 16, 1969, the massive Saturn V rocket </span><span class="se">\</span><span class="err">
| li</span><span class="se">f</span><span class="s">ted off from NASA's Kennedy Space Center at </span><span class="se">\</span><span class="err">
| </span><span class="se">09</span><span class="s">:32 a.m. EDT. Four days later, on July 20, Neil </span><span class="se">\</span><span class="err">
| A</span><span class="se">r</span><span class="s">mstrong and Buzz Aldrin landed on the Moon. </span><span class="se">\</span><span class="err">
| </span><span class="se">"</span><span class="s">""

&gt; Regex.contains pattern string
True</span></code></pre></figure>

<p>
Regulární výraz (regex) je vzor pro hledání shody s kombinací znaků v řetězci. Než se pokusíme porozumět výše uvedenému kódu, seznámíme se nejprve se základy regexu.</p>

<p class="info">Pokud již víte, jak regulární výrazy pracují, můžete následující odstavec přeskočit.</p>

<h3 id="regular-expression-basics">Základy regulárních výrazů</h3>

<h4 id="matching-a-single-character">Shoda s jedním znakem</h4>

<p>V regexu se písmena a čísla shodují samy se sebou. Na příkad, <code class="highlighter-rouge">A</code> se shoduje s <code class="highlighter-rouge">A</code> a <code class="highlighter-rouge">1</code> se shoduje s <code class="highlighter-rouge">1</code>. Regex je 'case-sensitive'. Takže se <code class="highlighter-rouge">A</code> neshoduje s <code class="highlighter-rouge">a</code>.</p>

<h4 id="matching-multiple-characters">Shoda s více znaky</h4>

<p>Hledanou shodu s více znaky musíme deklarovat výpisem nebo opakováním znaků. <code class="highlighter-rouge">AAA</code> se bude shodovat se třemi <code class="highlighter-rouge">A</code>za sebou a <code class="highlighter-rouge">123</code> se bude shodovat s číslem <code class="highlighter-rouge">123</code>.</p>

<h4 id="dot-character">Tečka</h4>

<p>Nespecifikovaný znak můžeme pro hledání shody nahradit tečkou: <code class="highlighter-rouge">A..</code>. Jedna tečka zastupuje jeden znak, jímž může být písmeno, číslo či jiný specielní znak. Takže se <code class="highlighter-rouge">A..</code> bude shodovat s <code class="highlighter-rouge">AAA</code>, <code class="highlighter-rouge">ABB</code>, <code class="highlighter-rouge">ACC</code>, <code class="highlighter-rouge">ABC</code>, atd. Bude se také shodovat s <code class="highlighter-rouge">A12</code>, <code class="highlighter-rouge">A$3</code>, <code class="highlighter-rouge">A^%</code>, atp. Interpunkční znaky jako <code class="highlighter-rouge">.</code>  nám umožňují vytváření schematických vzorů místo explicitního určení všech znalů v substringu.</p>

<p>Interpunkční znaky mají v regexu speciální významy. Takže chceme-li hledat shodu pro literál tečky, musíme před ní napsat zpětné lomítko, které odpojí její speciální význam pro regex. Zde je několik příkladů pro shodu s literálovou (normální) tečkou.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">\.</code> se bude shodovat s literálem tečky.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Dr\. Strange</code> se bude shodovat s <em>Dr. Strange</em>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Kevin Malone, Esq\.</code> se bude shodovat s <em>Kevin Malone, Esq.</em></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">7\.67</code> se bude shodovat s <em>7.67</em></p>
  </li>
</ul>

<h4 id="matching-a-set">Shoda se sadou</h4>

<p>Zatím jsme se zaměřili na vyhledávání shody s konkretním znakem. Co když potřebujeme nalézt shodu se znaky určitého druhu, například s číslicemi? Pro tento účel můžeme použít sadu (set). Sadu vytvoříme uzavřením znaků do hranatých závorek. Zde je několik příkladů:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">[0123456789]</code> se bude shodovat s jednou číslicí.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">[aeiouy]</code> se bude shodovat s jednou 'lowercase' samohláskou.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">[AEIOUY]</code> se bude shodovat s jednou 'uppercase' samohláskou.</p>
  </li>
</ul>

<p>Je důležité poznamenat, že sada nabídne shodu pouze s jedním znakem. Na příklad <code class="highlighter-rouge">[Pp]</code> se bude shodovat s jediným znakem (buď <code class="highlighter-rouge">P</code> nebo <code class="highlighter-rouge">p</code>), nikoliv <code class="highlighter-rouge">PP</code>, <code class="highlighter-rouge">pp</code> nebo <code class="highlighter-rouge">Pp</code>. Chceme-li shodu s více znaky, můžeme sadu opakovat, například takto: <code class="highlighter-rouge">[Pp][Pp]</code>, což pokryje všechny tyto kombinace: <code class="highlighter-rouge">PP</code>, <code class="highlighter-rouge">Pp</code>, <code class="highlighter-rouge">pp</code>, <code class="highlighter-rouge">pP</code>.</p>

<p>Jedním z příčin všestranné účinnosti regexu je možnost vytvářet složitější a složitější vzory postupným skládáním různých druhů výrazů.</p>

<h4 id="using-ranges-to-make-sets-more-succinct">
Použití intervalů k vytváření výstižnějších sad</h4>

<p>Sety se nesnadno rozšiřují. Chceme-li například hledat shodu pro dvě 'lowercase' písmena, musíme použít tento vzor: <code class="highlighter-rouge">[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz]</code>. Bůů. V těchto případech jsou vhodné intervaly (ranges). Místo vypisování každého prvku sady, prostě definujeme interval. Uvedený super dlouhý regex můžeme nahradit intervaly takto: <code class="highlighter-rouge">[a-z][a-z]</code>.</p>

<p>Podobně se bude <code class="highlighter-rouge">[0-9]</code> shodovat s každou číslicí. A <code class="highlighter-rouge">[A-Za-z0-9_]</code> se bude shodovat s kterýmkoli znakem slova (písmeno, číslo nebo podtržítko). Protože se některé sady znaků používají často, disponuje regex zkratkami, které je reprezentují. Zde je několik příkladů:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">\d</code> se bude shodovat s každou číslicí. Je to zkratka pro <code class="highlighter-rouge">[0-9]</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">\w</code> se bude shodovat s každým znakem slova. Je to zkratka pro <code class="highlighter-rouge">[A-Za-z0-9_]</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">\s</code> se bude shodovat s každou mezerou. Je to zkratka pro <code class="highlighter-rouge">[\t\r\n\f]</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">\s\d</code> se bude shodovat s mezerou před číslicí.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">[\da-f]</code> se bude shodovat s hexadecimální číslicí. Je to zkratka pro <code class="highlighter-rouge">[0-9a-f]</code>. Zde jsme kombinovali zkratku s intervalem. Výrazy můžeme skládat dle libosti.</p>
  </li>
</ul>

<h4 id="matching-alternatives">Shoda s alternativami</h4>

<p>Někdy potřebujeme nalézt shodu s jednou z alternativ. Používáme k tomu svislé dělítko (pipe). Zde je několik příkladů:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">X|Y</code> se bude shodovat buď s <code class="highlighter-rouge">X</code> nebo s <code class="highlighter-rouge">Y</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">EST|PST</code> se bude shodovat buď s <code class="highlighter-rouge">EST</code> nebo s <code class="highlighter-rouge">PST</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Jim|Pam</code> se bude shodovat se jménem jednoho ze dvou nejětších výtečníků, <code class="highlighter-rouge">Jimem</code> nebo <code class="highlighter-rouge">Pamem</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">am|a\.m\.|pm|p\.m\.</code> se bude shodovat s <code class="highlighter-rouge">am</code> nebo s <code class="highlighter-rouge">a.m.</code>nebo s <code class="highlighter-rouge">pm</code> nebo s <code class="highlighter-rouge">p.m.</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">[0-9]|[a-zA-Z]</code> se bude shodovat s číslicí nebo s písmenem</p>
  </li>
</ul>

<h4 id="matching-zero-or-more-characters-with-asterisk">Shoda se znaky s hvězdičkou</h4>

<p>Hvězdička (<code class="highlighter-rouge">*</code>) je patrně nejpůsobivější znak v regexu. Má speciální význam, stejně jako tečka. Vyhledává shodu pro nula či více znaků před hvězdičkou. Viz příklady:</p>

<ul>
<li>
<p><code class="highlighter-rouge">a*</code> se bude shodovat s <code class="highlighter-rouge">a</code>. Bude se také shodovat s <code class="highlighter-rouge">aa</code> nebo <code class="highlighter-rouge">aaa</code> nebo <code class="highlighter-rouge">aaaa</code> nebo <code class="highlighter-rouge">aaaaa</code> atd atp. Kromě znaků <code class="highlighter-rouge">a</code> se <code class="highlighter-rouge">a*</code> bude shodovat i s prázdným stringem.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ab*</code> se bude shodovat s <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">ab</code>, <code class="highlighter-rouge">abb</code>, <code class="highlighter-rouge">abbb</code>, <code class="highlighter-rouge">abbbb</code>, etc.</p>
  </li>
</ul>

<p>Hvězdička nemusí být na konci. Můžme ji vložit kam chceme.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">a*b</code> se bude shodovat s <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">ab</code>, <code class="highlighter-rouge">aab</code>, <code class="highlighter-rouge">aaab</code>, <code class="highlighter-rouge">aaaab</code>, etc.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Cree*d</code> se bude shodovat s <code class="highlighter-rouge">Creed</code>, <code class="highlighter-rouge">Creeed</code>, <code class="highlighter-rouge">Creeeed</code>, <code class="highlighter-rouge">Creeeeed</code>, etc.</p>
  </li>
</ul>

<p>Nemůžeme ji však dát na začátek, protože by potom nebylo co opakovat. Protože regex neklade řádná omezení na spojování výrazů, můžeme použít <code class="highlighter-rouge">*</code> sady nebo intervaly jako zde:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">[0-9]*</code> se bude shodovat s libovolným počtem číslic</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">[a-z]*</code> se bude shodovat s libovolným počtem malých písmen</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">[a-zA-Z0-9_]*</code> se bude shodovat s libovolným počtem číslic a alfanumerických znaků (písmeno, číslice nebo podtržítko = znaky slov)</p>
  </li>
</ul>

<p>Můžeme dokonce kombinovat <code class="highlighter-rouge">*</code> se speciálními zkratkami, jako zde:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">\d*</code> se bude shodovat s libovolným počtem číslic</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">\w*</code> se bude shodovat s libovolným počtem znaků slov</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">\s*</code> se bude shodovat s libovolným počtem mezer</p>
  </li>
</ul>

<h4 id="mother-of-all-regexes">Matka všech regexů</h4>

<p>Vzpomeňte si, jak jsem říkal že  <code class="highlighter-rouge">*</code> je patrně nejpůsobivější znak v regexu. Je pro to důvod. Spojíme-li ji s tečkou, vytvoříme "matku všech regexů": <code class="highlighter-rouge">.*</code>. Toto označení se bude shodovat s libovolným počtem libovolného znaku. Vpodstatě se bude shodovat se vším. Je to proto, že tečka se shoduje s jedním znakem (nezávisle na tom, o jaký znak se jedná) a hvězdička se shoduje s libovolným počtem znaků, reprezentovaných tečkou. Když se shoduje se vším, jak to může být užitečné? Podívejme se na několik příkladů:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">.*Kramer</code> se bude shodovat se jménem každého, jehož poslední jméno je  <em>Kramer</em>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Cosmo.*</code> se bude shodovat se jménem každého, jehož první jméno je <em>Cosmo</em>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">.*Sacamano.*</code> se bude shodovat se jménem, které obsahuje skupinu písmen <em>Sacamano</em>.</p>
  </li>
</ul>

<p>To by mohlo jako úvod do základů regulárních výrazů prozatím stačit. Reguárních výrazů je velmi mnoho. Na toto téma bylo napsáno mnoho knih. Existuje také řada online nástrojů pro <a href="https://regex101.com/" target="_blank">building and testing complex regexes</a>.</p>

<h3 id="regular-expressions-in-elm">Regulární výrazy v Elmu</h3>

<p>Nyní, když máme základy regulárních výrazů za sebou, můžeme porozumět významu slovutného vzoru, který jsme napsali pro vynětí času vypuštění Apolla 11 na počátku této kapitoly. Zde je text onoho kódu:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Regex</span>
<span class="o">&gt;</span> <span class="n">pattern</span> <span class="o">=</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">regex</span> <span class="s">"</span><span class="se">\\</span><span class="s">d</span><span class="se">\\</span><span class="s">d:</span><span class="se">\\</span><span class="s">d</span><span class="se">\\</span><span class="s">d (a</span><span class="se">\\</span><span class="s">.m</span><span class="se">\\</span><span class="s">.|p</span><span class="se">\\</span><span class="s">.m</span><span class="se">\\</span><span class="s">.)"</span>
<span class="p">{}</span>

<span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="s">""" </span><span class="se">\</span><span class="err">
| O</span><span class="se">n</span><span class="s"> July 16, 1969, the massive Saturn V rocket </span><span class="se">\</span><span class="err">
| li</span><span class="se">f</span><span class="s">ted off from NASA's Kennedy Space Center at </span><span class="se">\</span><span class="err">
| </span><span class="se">09</span><span class="s">:32 a.m. EDT. Four days later, on July 20, Neil </span><span class="se">\</span><span class="err">
| A</span><span class="se">r</span><span class="s">mstrong and Buzz Aldrin landed on the Moon. </span><span class="se">\</span><span class="err">
| </span><span class="se">"</span><span class="s">""

&gt; Regex.contains pattern string
True</span></code></pre></figure>

<p>Začínáme importem modulu <code class="highlighter-rouge">Regex</code>, který stejně jako modul <code class="highlighter-rouge">String</code> obsahuje Elm Platform ale nenačte se do replu automaticky. Pro zbytek příkladů v této sekci budeme předpokládat, že je modul <code class="highlighter-rouge">Regex</code> již importován.</p>

<p>Dále používáme funkci <code class="highlighter-rouge">regex</code> k definování vzoru, který se má shodovat s časem <em>(09:32 a.m.)</em>, který hledáme. Řetězec, v němž je časový údaj obsažen je definován jako víceřádkový. Na konci používáme funkci <code class="highlighter-rouge">contains</code> z modulu <code class="highlighter-rouge">Regex</code> (nikoliv z modulu <code class="highlighter-rouge">String</code>) ke zjištění, zda se nějaký substring shoduje s naším vzorem.</p>

<p class="info">To je podruhé, co se setkáváme se dvěma funkcemi stejného jména z různých modulů, což je v Elmu docela běžné. Kromě sdružování podobných funkcí, slouží moduly také jako jmenné prostory. Proto <code class="highlighter-rouge">String.contains</code> a <code class="highlighter-rouge">Regex.contains</code> jsou dvě zcela rozdílné funkce.</p>

<p>Vzor, který jsme použili jako argument funkce <code class="highlighter-rouge">regex</code> působí poněkud chaotickým dojmem, není-liž pravda? Když jsme se učili základy regulárních výrazů v předchozí sekci, používali jsme jeden znak <code class="highlighter-rouge">\</code> buď jako speciální zkratku nebo pro odsazení tečky: <code class="highlighter-rouge">\d</code> a <code class="highlighter-rouge">\.</code>. Nač tedy potřebujeme dvě zpětná lomítka v kódu Elmu?</p>

<p>Je to proto, že <code class="highlighter-rouge">\</code> má v Elmu speciální účel - odznačit (escape) jiné znaky. Když jej umístíme před jiný  znak, odnímáme jeho speciální význam a stává se obyčejným znakem. Vzmpomeňte si, jak jsme v odstavci <a href="string.html#multiline-strings" target="_blank">Řetězce - Víceřádkové řetězce</a>, když jsme použali dvojité uvozovky uvnitř jednořadkového řetězce, museli jsme je odznačit jako zde abychom řetězec neukončili předčasně: <code class="highlighter-rouge">"Michael Scott's Rabies Awareness \"Fun Run\" Race for the Cure"</code>. Chcete-li použít literálový znak <code class="highlighter-rouge">\</code>, musíte jej odznačit stejně jako uvozovky. Uveďte dvě lomítka <code class="highlighter-rouge">\\</code> za sebou a Elm pochopí, že chcete použít literál <code class="highlighter-rouge">\</code>. Použijete-li jenom jedno lomítko <code class="highlighter-rouge">\</code>, Elm jej pochopí jako signál k odebrání speciálního významu u následného znaku.</p>

<p><img src="images/regular-exp-for-time.png" alt="" /></p>

<h4 id="extracting-a-substring">Vyjmutí substringu</h4>

<p>Rozhodli jsme se extrahovat substring <em>09:32 a.m.</em> ale všechno, co jsme dosud udělali bylo to, že jsme si ověřili, že  tento substring existuje. K vyjmutí použijeme funkci <code class="highlighter-rouge">Regex.find</code>, která je mnohem účinnější než funkce <code class="highlighter-rouge">slice</code> z modulu  <code class="highlighter-rouge">String</code>. Funkce <code class="highlighter-rouge">find</code> přijímá tři parametry:</p>

<ul>
   <li>
   <p>počet výskytů substringu, které chceme nalézt. Na příklad, <code class="highlighter-rouge">All</code> vyhledá všechny výskyty, zatímco <code class="highlighter-rouge">Atmost 2</code> vyhledá nejvíce dva výskyty,</p>
   </li>
   <li>
   <p>vzor regulárního výrazu, reprezentující substring,</p>
   </li>
   <li>
   <p>prohledávaný řetězec.</p>
   </li>
</ul>

<p>Použijme funkci <code class="highlighter-rouge">find</code> k vyhledání shody s <em>09:32 a.m.</em></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">launchTimes</span> <span class="o">=</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">find</span> <span class="p">(</span><span class="kt">Regex</span><span class="o">.</span><span class="kt">AtMost</span> <span class="mi">1</span><span class="p">)</span> <span class="n">pattern</span> <span class="n">string</span>
<span class="p">[{</span> <span class="n">match</span> <span class="o">=</span> <span class="s">"09:32 a.m."</span><span class="p">,</span> <span class="n">submatches</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Just</span> <span class="s">"a.m."</span><span class="p">],</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">97</span><span class="p">,</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}]</span></code></pre></figure>

<p>Výstup je poněkud nepřehledný. Dovolte mi jej přeformátovat do přehlednějšího tvaru.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">[</span>
  <span class="p">{</span> <span class="n">match</span> <span class="o">=</span> <span class="s">"09:32 a.m."</span><span class="p">,</span>
    <span class="n">submatches</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Just</span> <span class="s">"a.m."</span><span class="p">],</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">97</span><span class="p">,</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">]</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">find</code> nevrací jenom hledaný substring. Obsahuje také výpis informací o shodě.</p>

<p class="info">Pro tuto chvíli považujete 'record' za kolekci párů key/value. Podrobněji se tím budeme zabývat v sekci <a href="record.html" target="_blank">Record</a>.</p>

<p>Jak výstup nahoře ukazuje, funkce <code class="highlighter-rouge">find</code> vrací čtyři údaje o každé shodě, kterou nalezla:</p>

<ul>
  <li>
    <p>Hledaný substring.</p>
  </li>
  <li>
    <p>Subshody - funkce <code class="highlighter-rouge">find</code> také hledá substringy, které se shodují s každým subvzorem, obsaženým ve vlastním vzoru. V našem případě se substring "a.m." shoduje se subvzorem <code class="highlighter-rouge">(a\\.m\\.|p\\.m\\.)</code>. Všechny subshody jsou přiřazeny k parametru <code class="highlighter-rouge">Just</code>, o němž pojednáme později. Příklady v této sekci subshody nepoužívají, takže je můžeme prozatím bezpečně ignorovat.</p>
  </li>
  <li>
    <p>Index substringu v původním řetězci.</p>
  </li>
  <li>
    <p>Vyhledá-li <code class="highlighter-rouge">find</code>
    více substringů, označí každou shodu přadovým číslem, začínajícím od jedničky. První shoda je označena číslem  <code class="highlighter-rouge">1</code>, druhá číslem <code class="highlighter-rouge">2</code>, atd atp. Tato čísla budou důležitá při pozdějším nahrazování všech výskytů substringu.</p>
  </li>
</ul>

<p>
Jsme už jen jeden krok od vynětí našeho potměšilého substringového přítele. Potřebujeme jenom zjistit, jak se dostat ke klíči <code class="highlighter-rouge">match</code> uvnitř záznamu. Použijeme k tomu funkci zvanou <code class="highlighter-rouge">List.map</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">List</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">launchTime</span> <span class="o">-&gt;</span> <span class="n">launchTime</span><span class="o">.</span><span class="n">match</span><span class="p">)</span> <span class="n">launchTimes</span>
<span class="p">[</span><span class="s">"09:32 a.m."</span><span class="p">]</span></code></pre></figure>

<p>Konečně máme náš substring. Je sice stále uzavřen v seznamu, o němž si budeme povídat v sekci <code class="highlighter-rouge">List</code>.</p>

<dl>
<dt>List.map</dt>
<dd><code class="highlighter-rouge">List.map</code> vytváří nový seznam, jehož elementy tvoří výsledky aplikace poskytnuté funkce na každý element seznamu původního. Funkci <code class="highlighter-rouge">String.filter</code> v předchozím odstavci jsme poskytli anonymní funkci, která čte hodnotu, uloženou v klíči <code class="highlighter-rouge">match</code>.</dd>
</dl>

<h4 id="finding-multiple-occurrences-of-a-substring">Nalezení vícerých výskytů substringu </h4>

<p>Vezměme si příklad řetězce s vícerými výskyty hledaného substringu.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">pattern</span> <span class="o">=</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">regex</span> <span class="s">"quitter"</span>
<span class="p">{}</span>

<span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="s">""" </span><span class="se">\</span><span class="err">
| I</span><span class="se">'</span><span class="s">m a great quitter. It's one of the few things </span><span class="se">\</span><span class="err">
| I do well. I come </span><span class="se">f</span><span class="s">rom a long line of quitters. </span><span class="se">\</span><span class="err">
| My </span><span class="se">f</span><span class="s">ather was a quitter, my grandfather was a </span><span class="se">\</span><span class="err">
| qui</span><span class="se">t</span><span class="s">ter... I was raised to give up. </span><span class="se">\</span><span class="err">
| </span><span class="se">"</span><span class="s">""

&gt; Regex.find Regex.All pattern string
...</span></code></pre></figure>

<p>Zde je výstup po menším formátování:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">[</span>
  <span class="p">{</span> <span class="n">match</span> <span class="o">=</span> <span class="s">"quitter"</span><span class="p">,</span>
    <span class="n">submatches</span> <span class="o">=</span> <span class="kt">[]</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">match</span> <span class="o">=</span> <span class="s">"quitter"</span><span class="p">,</span>
    <span class="n">submatches</span> <span class="o">=</span> <span class="kt">[]</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">89</span><span class="p">,</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">match</span> <span class="o">=</span> <span class="s">"quitter"</span><span class="p">,</span>
    <span class="n">submatches</span> <span class="o">=</span> <span class="kt">[]</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">116</span><span class="p">,</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="n">match</span> <span class="o">=</span> <span class="s">"quitter"</span><span class="p">,</span>
    <span class="n">submatches</span> <span class="o">=</span> <span class="kt">[]</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">147</span><span class="p">,</span>
    <span class="n">number</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="p">}</span>
<span class="p">]</span></code></pre></figure>

<p>Tentokrát jsme zadali <code class="highlighter-rouge">Regex.All</code> jako první argument funkci <code class="highlighter-rouge">find</code>, protože hledáme všechny výskyty substringu "quitter". Byly nalezeny čtyři. Všimněte si, jak se postupně u každé shody zvětšuje číslo u parametru <code class="highlighter-rouge">number</code>.</p>

<h4 id="replacing-a-substring">Nahrazení substringu</h4>

<p>I když se George rád chvástá, jaký je vynikající "quitter", udělejme z něj pro jednou "go-getter". Nahradíme všechny výskyty slova "quitter" slovem "go-getter". K tomu účelu použijeme funkci <code class="highlighter-rouge">replace</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">replace</span> <span class="kt">Regex</span><span class="o">.</span><span class="kt">All</span> <span class="n">pattern</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="s">"go-getter"</span><span class="p">)</span> <span class="n">string</span>
<span class="o">...</span></code></pre></figure>

<p>Po menším formátování vypadá výstup takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="s">"I'm a great go-getter. It's one of the few things
I do well. I come form a long line of go-getters.
My father was a go-getter, my grandfather was a
go-getter... I was raised to give up."</span></code></pre></figure>

<p>Odstranil jsem znaky <code class="highlighter-rouge">\n</code> a přebytečné mezery aby měl text lepší úpravu. Také na začátku výsledného řetězce uvidíte extra mezeru a znak <code class="highlighter-rouge">\n</code>. To proto, že když jsme definovali konstantu <code class="highlighter-rouge">string</code> s víceřádkovou syntaxí, použili jsme mezeru a znak <code class="highlighter-rouge">\n</code> aby kód působil úpravněji.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="s">""" </span><span class="se">\</span><span class="err">
| I</span><span class="se">'</span><span class="s">m a great quitter. It's one of the few things </span><span class="se">\</span><span class="err">
...</span></code></pre></figure>

<p>Mohli jsme stejně dobře začít náš řetězec na prvním řádku takto:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="s">"""I'm a great quitter. It's one of the few things </span><span class="se">\</span><span class="err">
...</span></code></pre></figure>

<p>Funkce <code class="highlighter-rouge">replace</code> přijímá čtyři argumenty:</p>

<ul>
  <li>
    <p>Kolik shod nahradit. My jsme zadali <code class="highlighter-rouge">Regex.All</code>, protože jsme chtěli nahradit všechny výskyty substringu "quitter". Kdybychom chtěli nahradit jenom první výskyt, zadali bychom <code class="highlighter-rouge">(Regex.AtMost 1)</code>.</p>
  </li>
  <li>
    <p>Vzor pro shodu se substringem, který chceme nahradit.</p>
  </li>
  <li>
    <p>Funkci, která přijímá jako argument shodný substring a vrací alternativu. Všimněte si, že jsme v anonymní funkci místo názvu parametru použili podtržítko <code class="highlighter-rouge">_</code>. Protože naše funkce jednoduše vrací úplně nový substring ("go-getter") a nesnaží se nijak měnit původní substring ("quitter"), nezajímá nás, co je naši funkci zadáváno. Použitím <code class="highlighter-rouge">_</code> vpodstatě tento argument ignorujeme.</p>
  </li>
  <li>
    <p>Původní řetězec se substringy, které chceme nahradit.</p>
  </li>
</ul>

<p><img src="images/regex-replace-syntax.png" alt="" /></p>

<h4 id="splitting-a-string">Štěpení řetězce</h4>

<p>Již víme, jak rozdělit řetězec použitím funkce <code class="highlighter-rouge">String.split</code>. Tato funkce je však omezena na štěpení řetězce na základě separátoru. Co když chceme rozdělit řetězec s použitím složitého vzoru? Například, následující řetězec obsahuje dvě instance času: <em>09:32</em> a <em>10:56</em></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="s">"""On July 16, 1969, the massive Saturn </span><span class="se">\</span><span class="err">
| V </span><span class="se">r</span><span class="s">ocket lifted off from NASA's Kennedy Space Center </span><span class="se">\</span><span class="err">
| </span><span class="se">a</span><span class="s">t 09:32 a.m. EDT. Four days later, on July 20 at </span><span class="se">\</span><span class="err">
| </span><span class="se">10</span><span class="s">:56 p.m. EDT, Neil Armstrong and Buzz Aldrin landed </span><span class="se">\</span><span class="err">
| o</span><span class="se">n</span><span class="s"> the Moon. </span><span class="se">\</span><span class="err">
| </span><span class="se">"</span><span class="s">""</span></code></pre></figure>

<p>Řekněme, že jej chceme rozdělit na tři substringy přesně tam, kde se vyskytují časové údaje:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="s">"On July 16, 1969, the massive Saturn V rocket lifted
off from NASA's Kennedy Space Center at "</span><span class="p">,</span>

<span class="s">" a.m. EDT. Four days later, on July 20 at"</span><span class="p">,</span>

<span class="s">" p.m. EDT, Neil Armstrong and Buzz Aldrin landed on the Moon."</span></code></pre></figure>

<p>Nevím, proč bychom měli chtít rozdělit řetězec zrovna uvedeným způsobem ale v tom případě budeme potřebovat něco flexibilnějšího než funkci <code class="highlighter-rouge">String.split</code>. Jak se ukazuje, poskytuje modul <code class="highlighter-rouge">Regex</code> také funkci <code class="highlighter-rouge">split</code>, která pro rozdělení řetězce na substringy používá regexový 'vzor'.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">pattern</span> <span class="o">=</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">regex</span> <span class="s">"</span><span class="se">\\</span><span class="s">d</span><span class="se">\\</span><span class="s">d:</span><span class="se">\\</span><span class="s">d</span><span class="se">\\</span><span class="s">d"</span>
<span class="p">{}</span>

<span class="o">&gt;</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">split</span> <span class="kt">Regex</span><span class="o">.</span><span class="kt">All</span> <span class="n">pattern</span> <span class="n">string</span>
<span class="o">...</span></code></pre></figure>

<p>Zde je mírně formátovaný výstup:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">[</span>
  <span class="s">"On July 16, 1969, the massive Saturn </span><span class="se">\n</span><span class="s">V rocket lifted off from NASA's Kennedy Space Center </span><span class="se">\n</span><span class="s">at "</span><span class="p">,</span>

  <span class="s">" a.m. EDT. Four days later, on July 20 at </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>

  <span class="s">" p.m. EDT, Neil Armstrong and Buzz Aldrin landed </span><span class="se">\n</span><span class="s">on the Moon. </span><span class="se">\n</span><span class="s">"</span>
<span class="p">]</span></code></pre></figure>

<h4 id="removing-case-sensitivity">Zrušení case-sensitivity</h4>

<p>Regulární výrazy jsou implicitně case-sensitive. Zde je příklad:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">pattern</span> <span class="o">=</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">regex</span> <span class="s">"phoenix"</span>
<span class="p">{}</span>

<span class="o">&gt;</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">contains</span> <span class="n">pattern</span> <span class="s">"I'm like the Phoenix, rising from Arizona."</span>
<span class="kt">False</span></code></pre></figure>

<p>Toto chování můžeme vypnout funkcí <code class="highlighter-rouge">caseInsensitive</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">pattern</span> <span class="o">=</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">caseInsensitive</span> <span class="p">(</span><span class="kt">Regex</span><span class="o">.</span><span class="n">regex</span> <span class="s">"phoenix"</span><span class="p">)</span>
<span class="p">{}</span>

<span class="o">&gt;</span> <span class="kt">Regex</span><span class="o">.</span><span class="n">contains</span> <span class="n">pattern</span> <span class="s">"I'm like the Phoenix, rising from Arizona."</span>
<span class="kt">True</span></code></pre></figure>

<p>Hovořili jsme téměř o všem v modulu <code class="highlighter-rouge">Regex</code>. Úplnou dokumentaci k tématu naleznete  <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Regex" target="_blank">zde</a>.</p>
</article>

  <nav class="pagination">
<a class="pagination-next" href="string.html">
<em>&larr; Previous</em>
<strong>Řetězce</strong>
</a>
<a class="pagination-next" href="list.html">
<em>Next &rarr;</em><strong>Seznamy</strong>
</a>
<a class="elevator" href="aa-index.html"><i class="fa fa-angle-up"></i>
<span>Back to top</span>
</a>
</nav>

</div>
</div>



<footer id="footer" class="page-footer">
<footer class="container">
 <p>Copyright © 2016 Pawan Poudel. All Rights Reserved.</p>
</footer>
</footer>

  </body>
</html>
