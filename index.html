<!DOCTYPE html>

<html lang="cs">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title> - Beginning Elm</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="css/main.css">  
</head>

<body>
<!-- <div class="page-hero"></div>-->
 

<section class="heading">
<h2>Beginning Elm</h2>
<h1>Jemný úvod do programování v jazyce Elm</h1>
<h1><a href="http://elmprogramming.com">(elmprogramming.com)</a></h1>
<br>
<h2></h2>
</section>

<section class="toc-component">
<div class="container">


<article class="toc-section toc-section--web">
<br>
<div class="toc-heading">
<h3>1 - Úvodní kapitola</h3>
</div>

<ol class="toc-content">

<!--<li class="toc-month"><a href="introduction.html">
           <em>01</em> Úvodní kapitola</a></li> -->  
<li><a href="introduction.html#1.1"> Úvodní slovo překladatele</a>
</li>
<li><a href="introduction.html#1.2">Úvodní slovo autora</a>
</li>
<li><a href="introduction.html#1.3">O autorovi</a>
</li>
<li><a href="introduction.html#1.4">Proč Elm</a>
</li>
<li><a href="introduction.html#1.5">Komu je kniha určena</a>
</li>
<li><a href="introduction.html#1.6">Použité konvence</a>
</li></ol></article>

<article class="toc-section toc-section--web">
<div class="toc-heading">
<h3>2 - Instalace a nástroje</h3>
</div>
<ol class="toc-content">            
<li><a href="getting-started.html"> Začínáme</a>
</li>
              
<li><a href="getting-started.html#2.1" >Instalace</a>
</li>
<li><a href="getting-started.html#2.2" >
             Vytvoření webové stránky</a>
</li>
<li><a href="getting-started.html#2.3" >Platforma Elm</a>
</li>
<li><a href="getting-started.html#2.4" >Programovací jazyk Elm</a>
</li>
<li><a href="getting-started.html#2.5" >Kompilátor Elmu</a>
</li>
<li><a href="getting-started.html#2.6" >Architektura Elmu</a>
</li>
<li><a href="getting-started.html#2.7" >Runtime Elmu</a>
</li>
<li><a href="getting-started.html#2.8" >Elm-make</a>
</li>
<li><a href="getting-started.html#2.9" >Elm-package</a>
</li>
<li><a href="getting-started.html#2.10" >Elm-reactor</a>
</li>
<li><a href="getting-started.html#2.11" >Elm-repl</a>
</li>
<li><a href="getting-started.html#2.12" >Try Elm Site</a>
</li>
</ol></article>

<article class="toc-section toc-section--web">
<div class="toc-heading">
<h3>3 - Syntaxe a sémantika</h3>
</div>

<ol class="toc-content">

<li><a href="elm-basics-intro.html">3.1 &nbsp; Základy jazyka Elm</a>
</li> 
<li><a href="simple-arithmetic.html" >3.2 &nbsp;  Jednoduchá artimetika</a>
</li>
<li><a href="boolean.html" >3.3 &nbsp;  Boolean</a>
</li>
<li><a href="comparison.html" >3.4 &nbsp; Srovnávání</a>
</li>
<li><a href="comment.html" >3.5 &nbsp; Komentáře</a>
</li>
<li><a href="expression.html" >3.6 &nbsp; Výrazy</a>
</li>
<li><a href="value.html" >3.7 &nbsp; Hodnota</a>
</li>
<li><a href="constant.html" >3.8 &nbsp; Konstanty</a>
</li>
<li><a href="if-expression.html" >3.9 &nbsp; Výraz IF</a>
</li>
<li><a href="function.html" >3.10 &nbsp; Funkce</a>
</li>
<li><a href="let-expression.html" >3.11 &nbsp; Výraz LET</a>
</li>
<li><a href="case-expression.html" >3.12 &nbsp; Výraz CASE</a>
</li>
<li><a href="indentation.html" >3.13 &nbsp; Indentace</a>
</li>
<li><a href="string.html" >3.14 &nbsp; String</a>
</li>
<li><a href="regular-expression.html" >3.15 &nbsp; Regulerní výraz</a>
</li>
<li><a href="list.html" >3.16 &nbsp; List</a>
</li>
<li><a href="array.html" >3.17 &nbsp; Array</a>
</li>
<li><a href="tuple.html" >3.18 &nbsp; Tuple</a>
</li>
<li><a href="record.html" >3.19 &nbsp; Record</a>
</li></ol></article>
            
<!--<li><a href="benefits-intro.html">Výhody Elmu</a></li>-->
<article class="toc-section toc-section--web">  
<div class="toc-heading">
<h3>4 - Výhody Elmu</h3>
</div>
<ol class="toc-content">
<li><a href="benefits-intro.html">4.1 &nbsp; Výhody Elmu</a></li>  
<li><a href="immutability.html" >4.2 &nbsp; Neměnitelnost</a>
</li>
<li><a href="pure-functions.html" >4.3 &nbsp; Čisté funkce</a>
</li>
<li><a href="function-composition.html" >4.4 &nbsp; 
     Ripple-Carry Adder</a>
</li>
<li><a href="easy-to-test.html">4.5 &nbsp; Snadné testování</a>
</li>
<li><a href="type-system.html" >4.6 &nbsp; Typový systém</a>
</li>
<li><a href="easier-code-organization.html" >4.7 &nbsp; 
              Organizace kódu</a>
</li>
<li><a href="fuzz-testing.html" >4.8 &nbsp; Fuzz Testing</a>
</li>
<li><a href="pattern-matching.html" >4.9 &nbsp; Pattern Matching</a>
</li>
<li><a href="benefits-conclusion.html" >4.10 &nbsp; 
              Shrnutí</a>
</li>
</ol></article>

<article class="toc-section toc-section--web">
<div class="toc-heading">
<h3>5 - Architektura Elmu</h3>
</div>
<ol class="toc-content">

<li><a href="elm-architecture.html">5.1 &nbsp; Elm Architecture</a></li>
		  
<li><a href="model-view-update-part-1.html">5.2 &nbsp; 
          Skladba EA - 1</a>
</li>
<li><a href="virtual-dom.html" >5.3 &nbsp; Virtuální DOM</a></li>
<li><a href="model-view-update-part-2.html" >5.4 &nbsp; 
          Skladba EA - 2</a>
</li>
<li><a href="side-effects.html" >5.5 &nbsp; Vedlejší účinky</a>
</li>
<li><a href="commands.html" >5.6 &nbsp; Příkazy</a>
</li>
<li><a href="http-requests.html" >HTTP Requests - <em>in progress</em></a>
</li>
<li><a href="json-encoding-decoding.html" >
              JSON Encoding & Decoding - <em>in progress</em></a>
</li>
<li><a href="tasks.html" >Tasks - <em>in progress</em></a>
</li>
<li><a href="subscriptions.html" >Subscriptions - <em>in progress</em></a>
</li>
<li><a href="ports.html" >Ports - <em>in progress</em></a>
</li>
</ol></article>

<footer id="footer" class="page-footer">
 <p>Copyright © 2016 Pawan Poudel. All Rights Reserved.</p>
</footer>
<!--
<div class="toc-heading">
<h4 style="text-align:center">Copyright © 2016 Pawan Poudel. All Rights Reserved.</h4>
</div>-->

</div>
</section>
 
     
</body>
</html>
=======
<html>
<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8" lang="cs">
<title>Appendix 1 - Values</title>
<style type="text/css">
html, body, p, td, li {font-family: arial, sans-serif, helvetica; font-size: 10pt;}
h1 {margin-left: 0cm; font-size: 16pt; font-weight: bold;}
h2 {font-size: 14pt; color: #2030a0; Font-Weight: bold; width: 100%; border-bottom: 1px solid #c09060;}
h3 {font-size: 12pt; color: #2030a0; Font-Weight: bold;}
h4 {font-size: 10pt; color: #2030a0; Font-Weight: bold;}
h5 {font-size: 10pt; Font-Weight: bold;}
tt {font-family: "courier new", monospace, courier; color: #990099; font-weight: 600;}
blockquote {margin-left: 25px;}
ii {color: #009933;}
.output {color: #000080; font-weight: normal;}
pre {font: bold 10pt "courier new", monospace, console;
	background-color: #e0e0e0; padding: 16px; border: solid #a0a0a0 1px;}	
.toc1 {margin-left: 0cm; font-size: 12pt; font-weight: 500;}
.toc2 {margin-left: 0.5cm; font-size: 10pt; font-weight: 500; text-decoration: none;}
.toc3 {margin-left: 2cm; font-size: 10pt; text-decoration: none;}
.toc4 {margin-left: 3cm; font-size: 10pt; color: grey; text-decoration: none;}
.output {color: #000080; font-weight: normal;}
.ale {color:#4B0082; font-weight: normal;}
.note {background-color: #f0e090; width: 100%; padding: 16px; border: solid #a0a0a0 1px;}
.tail {color: gray; font-size: 8pt;}
</style>
</head>

<body bgcolor="beige">
<center>
<table border="0" cellpadding="4" cellspacing="0" width="660">
<tbody>
<tr><td height="24"> </td></tr>
<tr><td>
<h1>Appendix 1 - Slova a datové typy</h1>

REBOL/Core Users Guide<br><a href="http://www.rebol.com/docs/core23/rebolcore.html">Main Table of Contents</a><br>

<h2>Obsah:</h2>
<a class="toc1" href="#section-1">1. Číselné hodnoty </a><br>
<a class="toc2" href="#section-1.1">1.1 Float</a><br>
<a class="toc2" href="#section-1.2">1.2 Integer</a><br>
<a class="toc1" href="#section-2">2. Series</a><br>
<a class="toc2" href="#section-2.1">2.1 Binary</a><br>
<a class="toc2" href="#section-2.2">2.2 Block</a><br>
<a class="toc2" href="#section-2.3">2.3 Email</a><br>
<a class="toc2" href="#section-2.4">2.4 File</a><br>
<a class="toc2" href="#section-2.5">2.5 Hash</a><br>
<a class="toc2" href="#section-2.6">2.6 Image</a><br>
<a class="toc2" href="#section-2.7">2.7 Issue</a><br>
<!--<a class="toc2" href="#section-2.8">2.8 List</a><br> -->
<a class="toc2" href="#section-2.9">2.9 Paren</a><br>
<a class="toc2" href="#section-2.10">2.10 Path</a><br>
<a class="toc2" href="#section-2.11">2.11 String</a><br>
<a class="toc2" href="#section-2.12">2.12 Tag</a><br>
<a class="toc2" href="#section-2.13">2.13 URL</a><br>
<a class="toc1" href="#section-3">3. Jiné hodnoty</a><br>
<a class="toc2" href="#section-3.1">3.1 Character</a><br>
<a class="toc2" href="#section-3.2">3.2 Date</a><br>
<a class="toc2" href="#section-3.3">3.3 Logic</a><br>
<a class="toc2" href="#section-3.4">3.4 Money</a><br>
<a class="toc2" href="#section-3.5">3.5 None</a><br>
<a class="toc2" href="#section-3.6">3.6 Pair</a><br>
<a class="toc2" href="#section-3.7">3.7 Refinement</a><br>
<a class="toc2" href="#section-3.8">3.8 Time</a><br>
<a class="toc2" href="#section-3.9">3.9 Tuple</a><br>
<a class="toc2" href="#section-3.10">3.10 Words</a><br>
<br>
<h3>Často používané funkce</h3>
<ul>
<li>Funkce <tt>form</tt> konvertuje zadanou hodnotu na řetězec, čitelný uživatelem:
<pre>
>> form/part 0,22222 4
<span class="output">== "0.22"</span>
</pre></li>
<li>Funkce <tt>mold</tt> konvertuje zadanou hodnotu na řetězec, čitelný uživatelem i Redem:
<pre>
>> mold/only [12,34 + 5]
<span class="output">== "12.34 + 5"</span>
</pre></li>
<li>Funkce <tt>probe</tt> vrací argument, poté co jej vytiskne v upravené (molded) formě:
<pre>
>> probe [1 2 3]
<span class="output">[1 2 3]
== [1 2 3]</span>
</pre></li>
<li>Funkce <tt>print (prin)</tt> vytiskne argument do konzoly s přechodem (bez přechodu) na nový řádek.
</li>

<br>
<h2 id="section-1">1. Číselné hodnoty</h2>

<h3 id="section-1.1">1.1 Float neboli číslo desetinné</h3>

<h4 id="section-1.1.1">1.1.1 Koncept</h4>
<p>Datový typ <tt>float!</tt> 
je založen na 64 bitovém formátu desetinného čísla standardu IEEE. </p>
<h4 id="section-1.1.2">1.1.2 Formát</h4>
<p>Desetinná čísla jsou sekvencí numerických číslic, oddělených tečkou nebo čárkou na část "celou" a desetinnou.</p>
<pre>1.23
123.
123.0
0.321
0.123
1234.5678
</pre>
<p>Místo tečky  lze použít čárku:</p>
<pre>1,23
0,321
1234,5678
</pre>
<p>Pro rozdělení dlouhého čísla lze použít apostrofu (`). Apostrof nemůže přijít na začátek čísla.</p>
<pre>100'234'562.3782
100'234'562,3782
</pre>
<p>Desetinná část čísla se nerozděluje.</p>
<p>Pro vyjádření čísla lze také použít vědecké notace:</p>
<pre>1.23E10
1.2e007
123.45e-42
56,72E300
-0,34e-12
0.0001e-001
</pre>
<p>Desetinná čísla vyplňují řadu od 2.2250738585072e-308 až po 1.7976931348623e+308 a mohou mít až 15 desetinných číslic.</p>

<h4 id="section-1.1.3">1.1.3 Konverze</h4>
<p>Pro přeměnu typů <tt>string!</tt> a 
<tt>integer!</tt> na typ  <tt>float!</tt> slouží funkce <tt>to-float</tt>:</p>
<pre>
to-float "123.45"
<span class="output">123.45</span>
to-float 123
<span class="output">123.0</span>
</pre>

<!--
<h4 id="section-1.1.3">1.1.3 Vytvoření</h4>
<p>V Redu neexistuje typ decimal; obdoba  <b><tt>to-float</tt> (k funkci to-decimal) pro  konverzi typů <b><tt>string!</tt></b>,
<b><tt>integer!</tt></b>, <b><tt>block!</tt></b>, na <b><tt>float!</tt></b> zatím nechodí:
</p>
<pre>probe to-decimal "123.45"
<span class="output">123.45</span>
probe to-decimal 123
<span class="output">123</span>
probe to-decimal [-123 45]
<span class="output">-1.23E+47</span>
probe to-decimal [123 -45]
<span class="output">1.23E-43</span>
probe to-decimal -123.8
<span class="output">-123.8</span>
probe to-decimal 12.3
<span class="output">12.3</span>
</pre> -->
<p>Je-li v jednom výrazu použito číslo desetinné i celé, je celé číslo konvertováno na číslo desetinné:</p>
<pre>1.2 + 2
<span class="output">3.2</span>
2 + 1.2
<span class="output">3.2</span>
1.01 &gt; 1
<span class="output">true</span>
1 &gt; 1.01
<span class="output">false</span>
</pre>

<h4 id="section-1.1.4">1.1.4 Souvisí</h4>
<p> K ověření, zda hodnota je typu <tt>float!</tt> či  <tt>integer!</tt> slouží funkce  <tt>float?</tt> či <tt>integer?</tt>.</p>
<pre>float? 0.123
<span class="output">true</span>
</pre>
<!--
<p><ii>V Redu vesměs chodí jinak:</ii>
 Use the <b><tt>form</tt></b>, <b><tt>print</tt></b>, and <b><tt>mold</tt></b> functions with an integer argument to print a decimal value in its simplest form:</p>
<ul>
<li>integer. If it can be represented as one.</li>
<li>decimal without exponent. If it's not too big or too small.</li>
<li>scientific notation. If it's too big or small.</li>
</ul>
<p>For example,</p>
<pre>probe mold 123.4
<span class="output">123.4</span>           ; <ii>jiný výsledek: "123.4"</ii>
probe form 2222222222222222
<span class="output">2.22222222222222E+15</span>           ; <ii>nechodí</ii>
print 1.00001E+5
<span class="output">100001</span>          ; <ii>jiný výsledek: 100001.0</ii>
</pre>
-->
<p>Jednoduché apostrofy (`) a znaménko (+) se u výstupu desetinného čísla neobjeví:</p>
<pre>print +1'100'200.222'112
<span class="output">1100200.222112</span>   
</pre>

<br>
<h3 id="section-1.2">1.2 Integer neboli číslo celé</h3>

<h4 id="section-1.2.1">1.2.1 Koncept</h4>
<p>Datový typ <tt>integer!</tt> je positivní i 
negativní celočíselná hodnota o velikosti 64 bitů . </p>
<h4 id="section-1.2.2">1.2.2 Formát</h4>
<p>Celočíselné hodnoty (kladné či záporné) tvoří sekvence číslic. Znaménko plus (+) či mínus (-) se zapisují přímo před první číslici čísla. Nuly před první číslem jsou ignorovány.</p>
<pre>0 1234 +1234 -1234 00012 -0123
</pre>
<p>Zápis delšího celého čísla lze zpřehlednit vkládáním apostrofů mezi číslice. Interpret Redu však tyto apostrofy zcela ignoruje.</p>
<pre>2'147'483'647
</pre>
<p>Množina celých čísel vyplňuje řadu od -2147483648 do 2147483647.</p>
<h4 id="section-1.2.3">1.2.3 Konverze</h4>
<p>Pro přeměnu typů <tt>string!</tt> a <tt>float!</tt> na <tt>integer!</tt> slouží funkce <<tt>to-integer</tt>:</p>
<pre>to-integer "123"
<span class="output">123</span>
<!--probe to-integer false
<span class="output">0</span>
probe to-integer true
<span class="output">1</span>
probe to-integer 123.4
<span class="output">123</span>-->
to-integer 123.8
<span class="output">123</span>
to-integer -123.8
<span class="output">-123</span>
to integer! #{1000}
<span class="output">4096</span>
</pre>

<h4 id="section-1.2.4">1.2.4 Souvisí</h4>
<p>K ověření, zda hodnota je typu <tt>integer!</tt> či <tt>float!</tt>, slouží funkce <tt>integer?</tt> či  <tt>float?</tt>.</p>
<pre>probe integer? -1234
<span class="output">true</span>
</pre>
<p>K vytištění celého čísla ve formátu řetězce se použijí funkce <tt>form</tt> a  <tt> mold</tt>:</p>
<pre>mold 123
<span class="output">"123"</span>
form 123
<span class="output">"123"</span>
</pre>
<p>Je-li ve výrazu kombinováno celé a decimální číslo, je celé číslo konvertováno na decimální (float):</p>
<pre>1.2 + 2
<span class="output">3.2</span>
</pre>
<br>
<h2 id="section-2">2. Seriové hodnoty</h2>

<p>Řada (series) je uspořádaná sada hodnot různých typů. Datový typ <tt>series!</tt> je kolektivním typem (pseudotypem) pro entity typu binary!, block!, email!, file! hash!, image!, paren!, path!, tag!, string!, url! a vector!. Se všemi lze manipulovat stejným způsobem.


<h3 id="section-2.1">2.1 Binary (binár)</h3>

<h4 id="section-2.1.1">2.1.1 Koncept</h4>
<p>Binání hodnoty obsahují binární data libovolného typu. V tomto formátu lze uložit libovolnou sekvenci bajtů (image, audio, spustitelný soubor, komprimovaná či zašifrovaná data).<br>
Formát zdroje binárních dat může být číslo se základem 2 (base-2: binary), 16 (base-16: hex) a 64 (base-64). Implicitní hodnota základu číselné soustavy v Redu je base-16.</p>
<h4 id="section-2.1.2">2.1.2 Formát</h4>
<p>Binární řetězce se zapisují do složených závorek s předsazeným znakem #. Znaky uvnitř řetězce vycházejí z kódování, určeného číslicí před znakem #. Nepřítomnost číslice avizuje implicitní kódování base-16.</p>
<pre>#{3A18427F 899AEFD8}                  ; base-16
2#{10010110110010101001011011001011}  ; base-2
64#{LmNvbSA8yw9CB0aGvXmgUkVCu2Uz934b} ; base-64
</pre>
<p>Mezery, taby a nové řádky jsou uvnitř řetězce povoleny.</p>
<pre>probe #{
    3A
    18
    92
    56
}
<span class="output">#{3A189256}</span>
</pre>
<p>Řetězce s nedostatečným počtem znaků pro vytvoření správného binárního výsledku jsou doplněny (padded) zprava.</p>

<h4 id="section-2.1.3">2.1.3 Vytvoření</h4>
<p>Funkce <tt>to-binary</tt> konvertuje data na datový typ <tt>binary!</tt> v základním kódování:</p>
<pre>system/options/binary-base
<span class="output">==16</span>
to-binary "123"
<span class="output">#{313233}</span>
to-binary "today is the day..."
<span class="output">#{746F64617920697320746865206461792E2E2E}</span>
</pre>
<p>Celé číslo při konverzi na binární tvar vkládáme do bloku:</p>
<pre>to-binary [1]
<span class="output">#{01}</span>
to-binary [11]
<span class="output">#{0B}</span>
</pre>
<p>Konverze řady celých čísel vrací binární konverzi každého jednotlivého čísla, spojenou do jediné hodnoty:</p>
<pre>to-binary [1 1 1 1]
<span class="output">#{01010101}</span>
</pre>
<h4 id="section-2.1.4">2.1.4 Souvisí</h4>
<p>K ověření zda hodnota je typu <tt>binary!</tt> slouží funkce <tt>binary?</tt>.</p>
<pre>binary? #{616263}
<span class="output">true</span>
</pre>
<p>Binární hodnoty jsou subtypem pseudotypu <tt>series!</tt>:</p>
<pre>series? #{616263}
<span class="output">true</span>
length? #{616263} ; three hex values in this binary
<span class="output">3</span>
</pre>
<p>S datovým typem <tt>binary!</tt> úzce souvisí funkce <tt>enbase</tt> a <tt>debase</tt>. Funkce <tt>enbase</tt> konvertuje řetězce na bitovou prezentaci pro base-2, -16 nebo -64. Funkce <tt>debase</tt> 
přemění "enbased" výraz na binární hodnotu pro základ, uvedený v <tt>system/options/binary-base</tt>.</p>
<pre>
>> x: enbase "Red is beautiful"          <ii>; implicitně pro base-64</ii>
<span class="output">== "UmVkIGlzIGJlYXV0aWZ1bA=="</span>
>> y: debase x
<span class="output">== #{5265642069732062656175746966756C}</span>
>> to string! y
<span class="output">== "Red is beautiful"</span>
</pre>



<h3 id="section-2.2">2.2 Bloky</h3>


<h3> <a id="1">Koncept</a></h3>

<p>Bloky jsou skupiny hodnot a slov. Používají se všude, od samotného skriptu až po bloky dat a bloky kódu ve skriptu.</p>
<p>
Hodnoty bloku jsou označeny hranatými závorkami.</p>
<pre>
[123 data "hi"]      <ii>; blok s daty</ii>
[]                   <ii>; prázdný blok</ii>
</pre>
Bloky mohou obsahovat záznamy informací:
<pre>
woodsmen: [
    "Paul" "Bunyan" paul@bunyan.dom
    "Grizzly" "Adams" grizzly@adams.dom
    "Davy" "Crocket" davy@crocket.dom
]
</pre>
Bloky mohou obsahovat kód:
<pre>
[print "this is a segment of code"]
</pre>
<p>Bloky jsou datovým typem skupiny series (řady) a proto vše, co lze provést s řadami, lze provést s hodnotou bloku.</p>

Bloky lze prohledávat:
<pre>
copy/part (find woodsmen "Grizzly") 3
<span class="output">== ["Grizzly" "Adams" grizzly@adams.dom]</span>
</pre>
Bloky lze měnit:
<pre>
append woodsmen [
    "John" "Muir" john@muir.dom ]
probe woodsmen
<span class="output">[
    "Paul" "Bunyan" paul@bunyan.dom
    "Grizzly" "Adams" grizzly@adams.dom
    "Davy" "Crocket" davy@crocket.dom
    "John" "Muir" john@muir.dom
]</span>
</pre>
Bloky lze vyhodnotit:
<pre>
blk: [print "data in a block"]
do blk
<span class="output">data in a block</span>
</pre>
Bloky mohou obsahovat jiné bloky:
<pre>
blks: [
    [print "block one"]
    [print "block two"]
    [print "block three"]
]
foreach blk blks [do blk]
<span class="output">block one
block two
block three</span>
</pre>

<h3 id="2">Formát</h3>

<p>Bloky mohou obsahovat libovolný počet hodnot nebo žádnou hodnotu. Mohou zabírat více řádků a zahrnovat jakýkoli typ hodnoty včetně dalších bloků.</pre>

Prázdný blok:
<pre>
[ ]
</pre>
Blok celých čísel:
<pre>
[24 37 108]
</pre>
Záhlaví skriptu:
<pre>

Red [
    Title: "Test Script"
    Date: 31-Dec-1998        <ii>; date není zaveden</ii>
    Author: "Ima User"
]
</pre>
Podmínka a vyhodnocení bloku funkce:
<pre>
while [time < 10:00] [
    print time               <ii>; time není zaveden</ii>               
    time: time + 0:10
]
</pre>
Slova v bloku nemusí mít určený význam:
<pre>
blk: [undefined words in a block]
value? pick blk 1
<span class="output">false</span>
</pre>
<p>Blok může obsahovat libovolný počet řádků, mezer nebo tabulátorových posunů. Řádky a mezery lze v bloku umístit kamkoli, pokud nerozdělují zápis hodnoty.</p>

<h3 id="3">Transformace na blok</h3>

<p>Funkce <tt><b>to-block</b></tt> mění data na typ <tt><b>block!</b></tt>:
<pre>
to-block luke@rebol.com
<span class="output">[luke@rebol.com]</span>
to-block {123 10:30 "string" luke@rebol.com}
<span class="output">[123 10:30 "string" luke@rebol.com]</span>
</pre>


<h3 id="4">Souvisí</h3>
<p>K ověření datového typu <tt><b>block!</b></tt> slouží funkce <tt><b>block?</b></tt>.</p>
<pre>
block? [123 10:30]
<span class="output">true</span>
</pre>
Protože bloky jsou podskupinou skupiny <tt><b>series!</b></tt>, použijeme také <tt><b>series?</b></tt>:
<pre>
series? [123 10:30]
<span class="output">true</span>
</pre>
<p>Funkce <tt><b>form</b></tt> vytvoří řetězec z obsahu bloku:</p>
<pre>
form [123 10:30]
<span class="output">"123 10:30"</span>
</pre>
<p>Funkce  <tt><b>mold</b></tt> vytvoří řetězec z celého bloku:</p>

<pre>mold [123 10:30]
<span class="output">"[123 10:30]"</span>
</pre>
<!--
<p>Blízce příbuznými datovými typy jsou <tt><b>hash!</b></tt> (slovník) a <tt><b>list!</b></tt> (seznam). Používají se téměř stejně jako bloky ale jsou rychlejší při modifikaci a vyhledávání částí jejich obsahů.</p> -->


<h3 id="section-2.3">2.3 Email </h3>

<h4 id="section-2.3.1">2.3.1 Koncept</h4>

<p>Emailová addresa je datový typ <tt>email!</tt>, který umožňuje snadné vyjádření emailové adresy: </p>
<pre>send luke@rebol.com {some message}

emails: [
    john@keats.dom
    lord@byron.dom
    edger@guest.dom
    alfred@tennyson.dom
]
mesg: {poetry reading at 8:00pm!}      <ii>; údaj pm! dosud nezaveden</ii>
foreach email emails [send email mesg]
</pre>
<p>Tento typ rovněž patří do skupiny <tt>series!</tt>, 
takže pro něj platí stejná pravidla jako pro tuto skupinu :</p>
<pre>head change/part jane@doe.dom "john" 4
<span class="output">john@doe.dom</span>
</pre>
<h4 id="section-2.3.2">2.3.2 Formát</h4>
<p>Standardním formátem emailové adresy je jméno následované znakem zavináč (@), následovaným doménou. Emailová adresa může mít libovolnou délku ale nesmí obsahovat zapovězené znaky, jako jsou hranaté závorky, uvozovky, složené závorky, mezery, nové řádky atp.</p>
<p>Následující formáty datového typu <tt>email!</tt> jsou platné:</p>
<pre>info@rebol.com
123@number-mail.org
my-name.here@an.example-domain.com
</pre>
<p>Velká a malá písmena jsou v emailových adresách zachovávána.</p>
<h4 id="section-2.3.3">2.3.3 Přístup</h4>
<p>Pro přístup ke jménu uživatele nebo k jeho doméně lze použít následující upřesnění (refinement):</p>
<ul>
<li>/user - get the user name.</li>
<li>/host - get the domain.</li>
</ul>
<p>Například:</p>
<pre>email: luke@rebol.com
email/user
<span class="output">luke</span>
email/host
<span class="output">rebol.com</span>
</pre>
<h4 id="section-2.3.4">2.3.4 Konverze</h4>
<p>Funkce <tt>to-email</tt> konvertuje data na datový typ <tt>email!</tt>:</p>
<pre>to-email "info@rebol.com"
<span class="output">info@rebol.com</span>
to-email [info rebol.com]
<span class="output">info@rebol.com</span>
to-email [info rebol com]
<span class="output">info@rebol.com</span>
to-email [user some long domain name out there dom]
<span class="output">user@some.long.domain.name.out.there.dom</span>
</pre>
<h4 id="section-2.3.5">2.3.5 Souvisí</h4>
<p>K ověření, zda je hodnota typem <tt>email!</tt>, použijeme funkci <tt>email?</tt>.</p>
<pre>email? luke@rebol.com
<span class="output">true</span>
</pre>
<p>Protože emaily jsou podskupinou skupiny (pseudotypu) <tt>series!</tt> použijeme i funkci <tt>series?</tt> ke zjištění, zda hodnota do tohoto pseudotypu patří:</p>
<pre>series? luke@rebol.com
<span class="output">true</span>
</pre>
<pre>pick luke@rebol.com 5
<span class="output">#"@"</span>
</pre>

<h3 id="section-2.4">2.4 File</h3>

<h4 id="section-2.4.1">2.4.1 Koncept</h4>
<p>Entitou typu <tt>file!</tt> (soubor) může být název souboru, složky nebo výpis cesty..</p>
<pre>%file.txt
%directory/
%directory/path/to/some/file.txt
</pre>
<p>Hodnoty typu <tt>file!</tt> jsou subtypem pseudotypu <tt>series!</tt> a lze s nimi jako s řadami (series) manipulovat:</p>
<pre>probe find %dir/path1/path2/file.txt "path2"
<span class="output">%path2/file.txt</span>
f: %dir/path/file.txt
probe head remove/part (find f "path/") (length? "path/")
<span class="output">%dir/file.txt</span>
</pre>
<h4 id="section-2.4.2">2.4.2 Formát</h4>
<p>Soubory se uvádějí s předsazeným znakem procenta (%):</p>
<pre>load %image.jpg
prog: load %examples.r
save %this-file.txt "This file has few words."
files: load %../programs/
</pre>
<p>Neobvyklé znaky v názvech souborů musí být vyjádřeny hexadecimálním číslem se znakem %. Název souboru s mezerou se píše se sekvencí %20:</p>
<pre>%cool%20movie%20clip.mpg
<span class="output">%cool%20movie%20clip.mpg</span>
print %cool%20movie%20clip.mpg
<span class="output">cool movie clip.mpg</span>
</pre>
<p>Jiný způsob je uzavření názvu do uvozovek:</p>
<pre>%"cool movie clip.mpg"
<span class="output">%cool%20movie%20clip.mpg</span>
print %"cool movie clip.mpg"
<span class="output">cool movie clip.mpg</span>
</pre>
<p>Standardním znakem pro oddělení adresářů v cestě je lomítko (/) nebo (\). Red umí používat obě:</p>
<pre>%some\path/to\some/where\movieclip.mpg
<span class="output">%some\path/to\some/where\movieclip.mpg</span>
</pre>
<h4 id="section-2.4.3">2.4.3 Konverze</h4>
<p>Funkce <tt>to-file</tt> konvertuje data na datový typ 
<tt>file!</tt>:</p>
<pre>to-file "testfile"
<span class="output">%testfile</span>
</pre>
<p>Data zadaná v bloku jsou spojena do názvu souboru:</p>
<pre>to-file [some path to a file the-file.txt]
<span class="output">%somepathtoafilethe-file.txt</span>
</pre>
<h4 id="section-2.4.4">2.4.4 Souvisí</h4>
<p>K ověření zda hodnota je typu <tt>file!</tt> slouží funkce <tt>file?</tt>.</p>
<pre>file? %rebol.r
<span class="output">true</span>
file? %rebol.red
<span class="output">true</span>
</pre>
<p>Protože <tt>file!</tt> je subtyp pseudotypu <tt>series!</tt>, můžeme k ověření typu použít funkci  <tt>series?</tt>:</p>
<pre>series? %rebol.r
<span class="output">true</span>
</pre>

<h3 id="section-2.5">2.5 Hash</h3>

<h4 id="section-2.5.1">2.5.1 Koncept</h4>
<p>Hash je blok, vytvořený pro rychlejší vyhledávání dat. Vyhledávání se uskutečňuje s použitím hešových tabulek, jež u velkých bloků zrychlují vyhledávání až stonásobně.</p>
<h4 id="section-2.5.2">2.5.2 Formát</h4>
<p>Hešové bloky se vytvářejí s použitím funkce <tt>make</tt>.  Nemají lexikální formát.</p>
<h4 id="section-2.5.3">2.5.3 Vytvoření</h4>
<p>K deklaraci hešového bloku použijeme funkci <tt>make</tt>:</p>
<pre>hsh: make hash 10  <ii> ; prázdný blok s alokovaným místem pro 10 prvků</ii>

bosh: make hash [1 "one" 2 "two" 3 "three"]
</pre>
<p>Funkce <tt>to-hash</tt> konvertuje data na datový typ <tt>hash!</tt>:</p>
<pre>blk: [1 "one" 2 "two" 3 "three" 4 "four"]
bash: to-hash blk
<span class="output">make hash! [1 "one" 2 "two" 3 "three" 4 "four"]</span>

print select hash 2
<span class="output">two</span>
</pre>
<p>Funkcí <tt>to-hash</tt> lze na typ <tt> hash!</tt>konvertovat různé hodnoty:</p>
<pre>to-hash luke@rebol.com

to-hash 123.5

to-hash {123 10:30 "string" luke@rebol.com}
</pre>

<h4 id="section-2.5.4">2.5.4 Souvisí</h4>
<p>K otestování datového typu použijeme funkci <tt> hash?</tt>.</p>
<pre>hsh: make hash [1 "one" 2 "two" 3 "three" 4 "four"]
hash? hsh
<span class="output">true</span>
</pre>
<p>Protože je hash! subtypem pseudotypu  series!, použijeme funkci <tt>series?</tt> k ověření jeho typu:</p>
<pre>series? bosh
<span class="output">true</span>
</pre>
<p>Funkce <tt>form</tt> vytvoří řetězec z obsahu heše:</p>
<pre>form hsh
<span class="output">"1 one 2 two 3 three 4 four"</span>
</pre>
<p>Funkce <tt>mold</tt> vrátí genezi celého heše::</p>
<pre>mold hsh
<span class="output">{make hash! [1 "one" 2 "two" 3 "three" 4 "four"]}</span>
</pre>

<h3 id="section-2.6">2.6 Image</h3>

<h4 id="section-2.6.1">2.6.1 Koncept</h4>
<p>Datový typ <tt>image!</tt> je řada, která obsahuje RGB zobrazení. Tento datový typ se používá v systému Red/View.</p>
<p>Podporované obrazové formáty jsou GIF, JPEG, and BMP. Načtený objekt typu image může být manipulován jako řada (series).</p>
<h4 id="section-2.6.2">2.6.2 Formát</h4>
<p>Obrazy se obvykle načítají ze souboru. Mohou být však vyjádřeny i ve zdrojovém kódu. Vytvořený blok obsahuje velikost obrazu a jeho hodnoty RGB.</p>
<pre>image: make image! [192x144 #{
    B34533B44634B44634B54735B7473
    84836B84836B84836BA4837BA4837
    BC4837BC4837BC4837BC4837BC483 ...
}
</pre>
<h4 id="section-2.6.3">2.6.3 Vytvoření</h4>
<p>Prázdný obraz lze vytvořit příkazem <tt>make</tt>:</p>
<pre>empty-img: make image! 300x300
<span class="output">== make image! [300x300 #{FFFFFFFFFFFFFFFFFF...</span>

empty-img: to-image 300x300  <ii>; v Redu nechodí</ii>
</pre>

<p><ii>Neověřeno: </ii>Images can also be made from snapshots of a face object. This is also done using <tt>make</tt> or <tt>to-image:</tt></p>
<pre>face-shot: make image! face
</pre>
<p>K načtení obrazového souboru použijeme příkaz  <tt>load</tt>. </p>
<pre>img: load %test/bay.jpg
<span class="output">== make image! [1280x1024 #{59561152530F46520A...</span>
</pre>
<h4 id="section-2.6.4">2.6.4 Souvisí</h4>
<p>K ověření zda hodnota je typu <tt>image!</tt> slouží funkce <tt>image?</tt>.</p>
<pre>image? img
</pre>
<p>Typ <tt>image!</tt> je subtypem pseudotypu  <tt>series!</tt>:</p>
<pre>series? img
</pre>
<p>Upřesněním (refinement) <tt>/size</tt> získáme velikost obrazu v pixelech coby hodnotu typu <tt>pair!</tt>:</p>
<pre>img/size
<span class="output">== 1280x1024</span>
</pre>
<p>Hodnoty jednotlivých pixelů získáme příkazem <tt>pick</tt> a změnit je můžeme příkazem  <tt>poke</tt>. Hodnota, vrácená příkazem <tt>pick</tt>, je entice (tuple) s hodnotami RGB. Hodnota, změněná příkazem <tt>poke</tt>, by rovněž měla být entice s hodnotami RGB.</p>
<p>Vybírání určitých pixelů:</p>
<pre>pick img 1
<span class="output">== 89.86.17.0</span> 

pick img 1500
<span class="output">== 41.44.1.0</span>
</pre>
<p>Měnění určitých pixelů:</p>
<pre>poke img 1 255.255.255
<span class="output">== 255.255.255</span> 
pick img 1
<span class="output">== 255.255.255.0</span> 
</pre>

<h3 id="section-2.7">2.7 Issue</h3>

<h4 id="section-2.7.1">2.7.1 Koncept</h4>
<p>Datový typ <tt>issue!</tt> (emise) je sekvence znaků použitá k vyjádření čísla telefonního, seriového, atp, atp, případně čísla kreditní karty.</p>
<!--
<p>Hodnoty typu <b><tt>issue!</tt> jsou subtypem pseudotypu <b><tt>series!</tt> a lze s nimi jako se seriemi manipulovat:</p>
<pre>probe copy/part find #888-555-1212 "555" 3  
<span class="output">#555</span>  <ii>; sorry: příkaz copy nepodporuje argument typu issue! </ii>
</pre> -->
<h4 id="section-2.7.2">2.7.2 Formát</h4>
<p>Emise začínají znakem čísla (#) a pokračují až k prvnímu oddělovači (např. k mezeře). </p>
<pre>#707-467-8000
#A-0987654321-CD-09876
#1234-5678-4321-8765
#MG82/32-7
</pre>
<p>Hodnoty, které obsahují oddělovací znaky, by měly být psány jako řetězce - spíše než emise.</p>
<h4 id="section-2.7.3">2.7.3 Konverze</h4>
<p><ii>V Redu nechodí:</ii> The <tt>to-issue</tt> function converts data to the <tt>issue!</tt> datatype:</p>
<pre>to-issue "1234-56-7890"
<span class="output">#1234-56-7890</span>
</pre>
<h4 id="section-2.7.4">2.7.4 Souvisí</h4>
<p>K ověření datového typu emise použijeme funkci <tt>issue?</tt>.</p>
<pre>issue? #1234-56-7890
<span class="output">true</span>
</pre>
<!--
<p>Protože jsou emise subtypem pseudotypu <b><tt>series!</tt>, můžeme pro ověření typu použit funkci  <b><tt>series?</tt>:</p>
<pre>probe series? #1234-56-7890
<span class="output">true</span>
</pre> -->
<p>Funkce <tt>form</tt> vrací emisi jako řetězec bez znaku #:</p>
<pre>form #1234-56-7890
<span class="output">"1234-56-7890"</span>
</pre>
<p>Funkce <tt>mold</tt> vrací emisi jako řetězec se znakem #, použitelný jako hodnota pro Red:</p>
<pre>mold #1234-56-7890
<span class="output">"#1234-56-7890"</span>
</pre>
<p>Funkce <tt>print</tt> provede standardní výstup emise (poté, co na ni provede úkon <tt>reform</tt> (?)):</p>
<pre>print #1234-56-7890
<span class="output">1234-56-7890</span>
</pre>
<!--
<h3 id="section-2.8">2.8 List - seznam</h3>
<h4 id="section-2.8.1">2.8.1 Koncept</h4>
<p>Seznamy jsou 'linkované' bloky, které umožňují rychlejší a účinnější vkládání a odebírání hodnot, zejména u velkých bloků.</p>
<h4 id="section-2.8.2">2.8.2 Formát</h4>
<p>Bloky seznamů se vytvářejí příkazem  <b><tt>make</tt>.  Nemají lexikální formát. </p>
<p>Hodnoty seznamů nejsou přímou náhradou bloků. Mezi bloky a seznamy existuje řada rozdílů:</p>
<ul>
<li>Prvky seznamu tvoří iterovatelnou indexovanou řadu - s prvkem prvním (head - čelo) a posledním (tail - chvost).</li>
<li>Vložení hodnoty do seznamu ovlivní indexování až za místem vložení.</li>
<li>Removing the element currently referenced in a list causes the reference to reset to the tail of the list</li>
</ul>
<p>Následující příklady ukazují rozdíl v chování při vkládání do bloku a do seznamu.</p>
<p>Vytvoření bloku a seznamu:</p>
<pre>blk: [1 2 3]
lst: to-list [1 2 3] 
</pre>
<p>Inserting into a block and list:</p>
<pre>insert blk 0

insert lst 0
</pre>
<p>Looking at the word after the block and list after insertion. Notice <b><tt>blk</tt> points to the head, as before the insertion of <b><tt>0</tt>, but <b><tt>lst</tt> points to just after the point of insertion:</p>
<pre>print blk
<span class="output">0 1 2 3</span>
print lst
<span class="output">1 2 3</span>
print head lst
<span class="output">0 1 2 3</span>
</pre>
<p>The following examples show the difference in behavior between removing an element from a list and a block.</p>
<p>Initializing a block and a list:</p>
<pre>blk: [1 2 3]

lst: to-list [1 2 3]
</pre>
<p>Removing from the block and list:</p>
<pre>remove blk

remove lst
</pre>
<p>Looking at the word after removal of the value. Notice <b><tt>lst</tt> now points to the tail of the series:</p>
<pre>print blk
<span class="output">2 3</span>
print tail? lst
<span class="output">true</span>
print head lst
<span class="output">2 3</span>
</pre>
<p>If you don't want the word to be at the tail after removing a value, 
step forward and remove the value behind the current index. The 
following examples depicts this.</p>
<p>Initializing a list:</p>
<pre>lst: to-list [1 2 3]
</pre>
<p>Stepping forward and removing the value behind the current index:</p>
<pre>remove back (lst: next lst)
</pre>
<p>Looking at the word after removing the value:</p>
<pre>probe lst
<span class="output">make list! [2 3]</span>
</pre>
<h4 id="section-2.8.3">2.8.3 Creation</h4>
<p>Use <b><tt>make</tt> to initialize a list value:</p>
<pre>lst: make list! 10 ; allocating space for 10 elements
</pre>
<p>The <b><tt>to-list</tt></b> function converts data to the <b><tt>list!</tt></b> datatype:</p>
<p>Convert a block:</p>
<pre>blk: [1 "one" 2 "two" 3 "three" 4 "four"]
probe to-list blk
</pre>
<h4 id="section-2.8.4">2.8.4 Related</h4>
<p>Use <b><tt>list?</tt></b> to determine whether a value is an <b><tt>list!</tt></b>  datatype.</p>
<pre>lst: to-list [1 "one" 2 "two" 3 "three" 4 "four"]
probe list? Lst
<span class="output">true</span>
</pre>
<p>Since lists are a subset of the <b><tt>series!</tt></b> datatype, use <b><tt>series?</tt></b> to check whether a list is a series:</p>
<pre>probe series? lst
<span class="output">true</span>
</pre>
<p>Using <b><tt>form</tt></b> on a list value creates a string from the contents contained in the list:</p>
<pre>probe form lst
<span class="output">"1 one 2 two 3 three 4 four"</span>
</pre>
<p>Using <b><tt>mold</tt></b> on a list value creates a string of the 
list value itself and it's contents, thus allowing it to be reloaded as a
 REBOL list value:</p>
<pre>probe mold lst
<span class="output">make list! [1 "one" 2 "two" 3 "three" 4 "four"]</span>
</pre>
-->
<h3 id="section-2.9">2.9 Paren</h3>

<h4 id="section-2.9.1">2.9.1 Koncept</h4>
<p>Datový typ <tt>paren!</tt> je blok, který je ohraničen kulatými závorkami. Samotné závorky však k vytvoření tohoto typu nestačí.</p>
<p>
Protože v Redu mají aritmetické operátory stejnou preferenci (výraz je mechanicky vyhodnocován zleva doprava), jsou závorky nápomocné při určení preference podle představy programátora:</p>
<pre>print 1 + 2 * 3
<span class="output">9</span>
print 1 + (2 * 3)
<span class="output">7</span>
zav: (1 + 2 * 3)
<span class="output">9</span>
</pre>
<h4 id="section-2.9.2">2.9.2 Vytvoření</h4>
<p>Objekt typu <tt>paren!</tt> můžeme vytvořit odkazem na počátek bloku: </p>
<pre>paren: first [(1 + 2 * 3 / 4)]
<span class="output">== (1 + 2 * 3 / 4) </span></pre>
<p>Případně lze k deklaraci objektu použít funkci <tt>make</tt> :</p>
<pre>prn: make paren! ["a" 5]    
prn
<span class="output">== ("a" 5)</span>
insert prn `+       
<ii>; Operátory je nutné vložit ve tvaru lit-word (nikoliv get-word!)</ii>
print prn
<span class="output">+ "a" 5</span>
print paren
<span class="output">1 + 2 * 3 / 4</span>
</pre>
<p>Funkce <tt>to-paren</tt> konvertuje data na formát typu <tt>paren!</tt>:</p>
<pre>to-paren "123 456"
<span class="output">(123 456)</span>
to-paren [123 456]
<span class="output">(123 456)</span>
</pre>
<p>Objekty typu <tt>paren!</tt> patří do skupiny <tt>series!</tt> a tudíž vše, co lze provést s řadami, lze provést s 'pareny'.</p>
<pre>
paren? paren
<span class="output">true</span>
type? paren
<span class="output">paren!</span>
length? paren
<span class="output">7</span>
first paren
<span class="output">1</span>
last :paren
<span class="output">4</span>
insert paren [10 + 5 *]
paren
<span class="output">(10 + 5 * 1 + 2 * 3 / 4)</span>
</pre>

<h4 id="section-2.9.3">2.9.3 Souvisí</h4>

<pre>blk: [(3 + 3)]

pick blk 1
<span class="output">(3 + 3)</span>
paren? pick blk 1
<span class="output">true</span>
series? pick blk 1
<span class="output">true</span>
form pick blk 1
<span class="output">"3 + 3"</span>
print pick blk 1
<span class="output">3 + 3</span>
</pre>

<h3 id="section-2.10">2.10 Path</h3>

<h4 id="section-2.10.1">2.10.1 Koncept</h4>
<p>Cesty (paths) jsou kolekcemi slov a hodnot oddělených lomítky. Používají se k navigaci nebo k vyhledání čehosi. Slova a hodnoty cesty jsou určitou formou upřesnění (refinement).</p>
<p>Formát cesty lze použít pro bloky, soubory, řetězce, heše (hashes), funkce a objekty. Působení cesty závisí na použitém datovém typu.</p>
<p>Cesty lze použít k výběru hodnot z bloků, znaků z řetězců, pro přístup k proměnným v objektech, k upřesnění operace funkce:</p>
<pre>USA/CA/Ukiah/size (výběr bloku)

names/12          (pozice v řetězci)

account/balance   (funkce objektu)

match/any         (režim funkce)
</pre>
<p>Následující příklad ukazuje jednoduchost použití cesty pro přístup k mini databázi, vytvořené z několika bloků:</p>
<pre>towns: [
    Hopland [
        phone #555-1234
        web   http://www.hopland.ca.gov
    ]

    Ukiah [
        phone #555-4321
        web   http://www.ukiah.com
        email info@ukiah.com
    ]
]

print towns/ukiah/web
<span class="output">http://www.ukiah.com</span>
</pre><br>
<p>Přehled sestav pro <tt>path</tt>:</p>
<table bgcolor="#505050" border="0" cellpadding="4" cellspacing="1">
        <tbody><tr bgcolor="silver"><th align="left">
<p>Akce</p>
</th><th align="left">
<p>Označení typu</p>
</th><th align="left">
<p>Test typu</p>
</th><th align="left">
<p>Konverze</p>

</th></tr><tr><td bgcolor="white" valign="top">
<p><tt>path/word:</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>set-path!</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>set-path?</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>to-set-path</tt></p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>path/word</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>path!</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>path?</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>to-path</tt></p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>'path/word</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>lit-path!</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>lit-path?</tt></p>
</td><td bgcolor="white" valign="top">
<p><tt>to-lit-path</tt></p>
</td></tr></tbody></table>
<p>Příklady cest:</p>
<p>Pro vyhodnocení funkce objektu:</p>
<pre>obj: make object! [
    hello: func [] [print "hello! hello!"]
]
obj/hello
<span class="output">hello! hello!</span>
</pre>
<p>Pro vyhodnocení slova objektu:</p>
<pre>obj: make object! [
    text: "do you believe in magic?"
]
obj/text
<span class="output">do you believe in magic?</span>
</pre>
<p>Upřesnění (refinements) funkce:</p>
<pre>hello: func [/again] [
    print either again ["hello again!"]["hello"]
]
hello/again
<span class="output">hello again!</span>
</pre>
<p>Výběr z bloku:</p>
<pre>USA: [
    CA [
        Ukiah [
            population 15050
            elevation [610 feet]
        ]
        Willits [
            population 5073
            elevation [1350 feet]
        ]
    ]
]
print USA/CA/Ukiah/population
<span class="output">15050</span>
print form USA/CA/Willits/elevation
<span class="output">1350 feet</span>
</pre>
<p>Výběr prvků z řad a vnořených řad (series) podle jejich číselné pozice:</p>
<pre>string-series: "abcdefg"
block-series: ["John" 21 "Jake" 32 "Jackson" 43 "Joe" 52]
block-with-sub-series: [ "abc" [4 5 6 [7 8 9]]]
string-series/4
<span class="output">#"d"</span>
block-series/3
<span class="output">"Jake"</span>
block-series/6
<span class="output">43</span>
block-with-sub-series/1/2
<span class="output">#"b"</span>
block-with-sub-series/2/2
<span class="output">5</span>
block-with-sub-series/2/4/2
<span class="output">8</span>
</pre>
<p>Slovo, zadané jako cesta, je symbolické a proto se nevyhodnocuje. To je nezbytné pro intuitivní formu odkazování na objekty. Při použití odkazu na slovo je požadovaná explicitní reference na hodnotu slova:</p>
<pre>city: 'Ukiah
USA/CA/city
<span class="output">[
    population 15050 
    elevation "610 feet"
]</span>
</pre>
<p>Cesty v blocích, heších nebo objektech se vyhodnocují hledáním shody pro slovo na počátku cesty a ověřením onoho slova jako hodnoty typu <tt>block!</tt>, <tt>hash!</tt> nebo <tt>object!</tt>. Poté je hledáno další slovo cesty jako slovo vyjádřené v bloku, heši nebo objektu a je aktivována implicitní funkce <tt>select</tt>. Vrací se hodnota následující za shodujícím se slovem. Je-li vrácenou hodnotou blok, hash nebo objekt, může být cesta rozšířena:</p>
<p>Získání hodnoty, asociované s <tt>CA</tt> v <tt>USA:</tt></p>
<pre>probe USA/CA
<span class="output">[
    Ukiah [
        population 15050 
        elevation "610 feet"
    ] 
    Willits [
        population 5073 
        elevation "1350 feet"
    ]
]</span>
</pre>
<p>Získání hodnoty, asociované s <tt>Willits</tt> v <tt>USA/CA:</tt></p>
<pre>probe USA/CA/Willits
<span class="output">[
    population 5073 
    elevation "1350 feet"
]</span>
</pre>
<p>Získání hodnoty, asociované s <tt>population</tt> v <tt>USA/CA/Willits:</tt></p>
<pre>USA/CA/Willits/population
<span class="output">5073</span>
</pre>
<p>Je-li v cestě použito slovo, které v daném místě struktury neexistuje, vrací se:</p>
<pre>USA/CA/Mendocino
<span class="output">==none</span>
</pre>
<p>Cest lze použít ke změně hodnot v blocích a objektech:</p>
<pre>USA/CA/Willits/elevation: "1 foot, after the earthquake"
USA/CA/Willits
<span class="output">[
    population 9935 
    elevation "1 foot, after the earthquake"
]</span>
obj/text: "yes, I do believe in magic."
obj
<span class="output">make object! [
    text: "yes, I do believe in magic."
]</span>
</pre>
<p>Bloky, heše, funkce a objekty lze v cestách mísit.</p>
<p>Výběr z elementů v bloku uvnitř objektu:
</p>
<pre>obj: make object! [
    USA: [
        CA [
            population "too many"
        ]
    ]
]
obj/USA/CA/population
<span class="output">too many</span>
</pre>
<p>
Upřesnění funkce uvnitř objektu:</p>
<pre>obj: make object! [
    hello: func [/again] [
        print either again [
            "hello again"
        ] [
            "oh, hello"
        ]
    ]
]
obj/hello/again
<span class="output">hello again</span>
</pre>
<p>Cesty jsou typem pseudotypu <tt>series!</tt> a proto vše, co lze učinit s řadou, lze provést s hodnotami cesty:</p>
<pre>root: [sub1 [sub2 [
    word "a word at the end of the path"
    num 55
]   ]   ]
path: 'root/sub1/sub2/word
probe :path
probe path             <ii>; v obou případech dostáváme:</ii>
<span class="output">root/sub1/sub2/word</span>
</pre>
<p>Abychom získali odpovídající hodnotu slova "word", musíme použít formu:</p>
<pre>get path
<span class="output">"a word at the end of the path"</span>
</pre>
<p>Zjištění délky cesty:</p>
<pre>length? path
<span class="output">4</span>
</pre>
<p>Nalezení slova v cestě:</p>
<pre>find path 'sub2
<span class="output">sub2/word</span>
</pre>
<p>Změna slova v cestě:</p>
<pre>change find path 'word 'num
path
<span class="output">root/sub1/sub2/num</span>
</pre>

<h4 id="section-2.10.2">2.10.2 Vytvoření cesty</h4>
<p>Prázdnou cestu dané velikosti lze vytvořit příkazem <tt>make</tt>:</p>
<pre>path: make path! 10
insert path "test"
insert tail path "this"
print path
<span class="output">test/this</span>
</pre>
<p>Funkce <tt>to-path</tt> konvertuje data na datový typ <tt>path!</tt>:</p>
<pre>to-path [root sub]
<span class="output">root/sub</span>
to-path "root sub"
<span class="output">root/sub</span>
</pre>
<p>Funkce <tt>to-set-word</tt> konvertuje hodnoty na datový typ <tt>set-word</tt>.</p>
<pre>to-set-path "root sub"
<span class="output">root/sub:</span>
</pre>
<p>Funkce <tt>to-lit-word</tt> konvertuje hodnoty na datový typ <tt>lit-word</tt>.</p>
<pre>to-lit-path "root sub"
<span class="output">'root/sub</span>
</pre>
<h4 id="section-2.10.3">2.10.3 Souvisí</h4>
<p>K určení datového typu hodnoty použijeme funkce <tt>path?</tt>, <tt>set-path?</tt> a <tt>lit-path?</tt>.</p>
<pre>path? second [1 two "3"]
<span class="output">false</span>
blk: [sub1 [sub2 [word 1]]]
blk2: [blk/sub1/sub2/word: 2]
if set-path? (pick blk2 1) [print "it is set"]
<span class="output">it is set</span>
lit-path? first ['root/sub]
<span class="output">true</span>
</pre>
<p>Protože jsou cesty subtypem pseudotypu <tt>series!</tt>, můžeme k ověření použít funkci <tt>series?</tt>:</p>
<pre>series? pick [root/sub] 1
<span class="output">true</span>
</pre>
<p>Funkce <tt>form</tt> vytvoří z cesty řetězec:</p>
<pre>form pick [root/sub] 1
<span class="output">"root/sub"</span>
</pre>
<p>Funkce <tt>mold</tt> vytvoří z cesty řetězec, použitelný Redem jako hodnota cesty:</p>
<pre>mold pick [root/sub] 1
<span class="output">"root/sub"</span>
</pre>

<h3 id="section-2.11">2.11 String</h3>

<h4 id="section-2.11.1">2.11.1 Koncept</h4>
<p>Řetězce (strings) jsou serie znaků. Všechny operace, proveditelné na hodnotách řad (series), lze provést na řetězcích.</p>
<h4 id="section-2.11.2">2.11.2 Formát</h4>
<p>Řetězce se zapisují jako posloupnost znaků, ohraničená dvojitými uvozovkami " " nebo složenými závorkami {}. Řetězce ve dvojitých uvozovkách jsou určeny pro jeden řádek a nesmějí obsahovat netisknutelné znaky.</p>
<pre>"Toto je krátký řetězec znaků."
</pre>
<p>Řetězce ve složených závorkách se používají pro delší texty na více řádcích. Všechny znaky řetězce, včetně mezer, tabulátorů a nových řádků, jsou součástí řetězce.</p>
<pre>{This is a long string of text that will 
not easily fit on a single line of source.
These are often used for documentation
purposes.}
</pre>
<p>Řetězec se složenými závorkami může obsahovat další složené závorky, pokud se shoduje počet levých a pravých závorek.</p>
<pre>{
This is another long string of text that would
never fit on a single line. This string also
includes braces { a few layers deep { and is 
valid because there are as many closing braces }
as there are open braces } in the string.
}
</pre>
<p>Do řetězců lze vkládat specielní znaky spolu se znakem ^ (caret):</p>
<table bgcolor="#505050" border="0" cellpadding="4" cellspacing="1">
        <tbody><tr bgcolor="silver"><th align="left">
<p>Znak</p>
</th><th align="left">
<p>Definice</p>

</th></tr><tr><td bgcolor="white" valign="top">
<p>^"</p>
</td><td bgcolor="white" valign="top">
<p>Vloží dvojitou uvozovku (").</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^}</p>
</td><td bgcolor="white" valign="top">
<p>Vloží pravou složenou závorku (}).</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^^</p>
</td><td bgcolor="white" valign="top">
<p>Vloží caret (^).</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^/</p>
</td><td bgcolor="white" valign="top">
<p>Započne nový řádek.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(line)</p>
</td><td bgcolor="white" valign="top">
<p>Započne nový řádek.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^-</p>
</td><td bgcolor="white" valign="top">
<p>Vloží tabulátor.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(tab)</p>
</td><td bgcolor="white" valign="top">
<p>Vloží tabulátor.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(page)</p>
</td><td bgcolor="white" valign="top">
<p>Započne novou stránku.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(back)</p>
</td><td bgcolor="white" valign="top">
<p>Vymaže znak vlevo od bodu vložení.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(null)</p>
</td><td bgcolor="white" valign="top">
<p>Vloží znak nuly.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(escape)</p>
</td><td bgcolor="white" valign="top">
<p>Vloží znak 'escape'.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(letter)</p>
</td><td bgcolor="white" valign="top">
<p>Vloží písmeno (A-Z).</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p>^(xx)</p>
</td><td bgcolor="white" valign="top">
<p>Vloží znak ASCII jako hexadecimální (xx) číslo. </p>
</td></tr></tbody></table>
<h4 id="section-2.11.3">2.11.3 Vytvoření</h4>
<p>Prázdný řetězec s vymezenou velikostí prostoru vytvoříme příkazem <tt>make</tt>:</p>
<pre>make string! 40'000 <ii>; prostor pro 4k znaků</ii>
</pre>
<p>Funkce <tt>to-string</tt> konvertuje data na datový typ <tt>string!</tt>:</p>
<pre>to-string 29-2-2000            <ii>; dosud nechodí</ii>
<span class="output">"29-Feb-2000"</span>
to-string 123456.789
<span class="output">"123456.789"</span>
to-string #888-555-2341
<span class="output">"888-555-2341"</span>
</pre>
<p>Konverze dat v bloku způsobí jejich sloučení bez vyhodnocení:</p>
<pre>to-string [123 456]
<span class="output">"123456"</span>
to-string [225.225.225.0 none true 'word]
<span class="output">"225.225.225.0nonetrueword"</span>
</pre>
<h4 id="section-2.11.4">2.11.4 Souvisí</h4>
<p>K určení zda je hodnota typu <tt>string!</tt> použijeme funkce <tt>string?</tt> nebo <tt>series?</tt>:</p>
<pre>string? "123"
<span class="output">true</span>
series? "123"
<span class="output">true</span>
</pre>
<p>Funkce <tt>form</tt> a <tt>mold</tt> vytvářejí řetězce z jiných datových typů. Funkce <tt>form</tt> vytváří jednoduše čitelnou verzi, zatímco funkce <tt>mold</tt> vytváří verzi, čitelnou Redem.</p>
<pre>form "111 222 333"
<span class="output">"111 222 333"</span>
mold "111 222 333"
<span class="output">{"111 222 333"}</span>
</pre>

<h3 id="section-2.12">2.12 Tag</h3>

<h4 id="section-2.12.1">2.12.1 Koncept</h4>
<p>Tagy se používají v HTML a v jiných značkovacích jazycích k vyjádření úprav textového pole. Například, tag  <tt>&lt;HTML&gt;</tt> na počátku souboru určuje, že text má být parsován podle pravidel Hypertext Markup Language. Tag s lomítkem, např. <tt>&lt;/HTML&gt;</tt>, označuje závěrný tag na konci stránky.</p>
<p>Datový typ <tt>tag!</tt> patří do skupiny <tt>series!</tt> a jako řada je manipulovatelný:</p>
<pre>a-tag: &lt;img src="mypic.jpg"&gt;
a-tag
<span class="output">&lt;img src="mypic.jpg"&gt;</span>
append a-tag { alt="My Picture!"}
a-tag
<span class="output">&lt;img src="mypic.jpg" alt="My Picture!"&gt;</span>
</pre>
<h4 id="section-2.12.2">2.12.2 Formát</h4>
<p>Platné tagy začínají levou lomenou závorkou (&lt;) a končí pravou závorkou (&gt;), na příklad:</p>
<pre>&lt;a href="index.html"&gt;
&lt;img src="mypic.jpg" width="150" height="200"&gt;
</pre>
<h4 id="section-2.12.3">2.12.3 Vytvoření</h4>
<p>Funkce <tt>to-tag</tt> konvertuje data na datový typ  <tt>tag!</tt>:</p> 
<pre>to-tag "title"
<span class="output">&lt;title&gt;</span>
</pre>
<p>Tag se jménem a atributy vytvoříme pomocí funkce <tt>build-tag</tt>. Argumentem této funkce je blok, obsahující jméno tagu a další údaje, použité pro vytvoření atributu:</p>
 <ii>dosud nechodí</ii>
<pre>build-tag [a href http://www.rebol.com/]
<span class="output">&lt;a href="http://www.rebol.com/"&gt;</span>
build-tag [
    img src %mypic.jpg width 150 alt "My Picture!"
]
<span class="output">&lt;img src="mypic.jpg" width="150" alt="My Picture!"&gt;</span>
</pre>
<h4 id="section-2.12.4">2.12.4 Souvisí</h4>
<p>K ověření, zda hodnota je typu <tt>tag!</tt>, použijeme funkci <tt>tag?</tt> nebo <tt>series?</tt>:</p>
<pre>tag? &lt;a href="http://www.rebol.com/"&gt;
<span class="output">true</span>
</pre>
<pre>series? &lt;a href="http://www.rebol.com/"&gt;
<span class="output">true</span>
</pre>
<p>Funkce <tt>form</tt> a <tt>mold</tt> vracejí tag jako řetězec:</p>
<pre>form &lt;a href="http://www.rebol.com/"&gt;
<span class="output">{&lt;a href="http://www.rebol.com/"&gt;}</span>
</pre>
<pre>mold &lt;a href="http://www.rebol.com/"&gt;
<span class="output">{&lt;a href="http://www.rebol.com/"&gt;}</span>
</pre>
<p>Funkce <tt>print</tt> vytiskne tag v konzole: </p>
<pre>print &lt;a href="http://www.rebol.com/"&gt;
<span class="output">&lt;a href="http://www.rebol.com/"&gt;</span>
</pre>

<h3 id="section-2.13">2.13 URL</h3>

<h4 id="section-2.13.1">2.13.1 Koncept</h4>
<p>URL je zkratka pro Uniform Resource Locator, což je internetový standard, používaný pro přístup přes síť ke zdrojům jako jsou webové stránky, obrázky, soubory a emaily.</p>
<p>Hodnoty URL jsou subtypem pseudotypu <tt>series!</tt> a tudíž je možné s nimi manipulovat jako s řadami:</p>
<pre>url: http://www.rebol.com/reboldoc.html
to-file find/reverse (tail url) "rebol"
<span class="output">%reboldoc.html</span>
</pre>
<h4 id="section-2.13.2">2.13.2 Formát</h4>
<p>První část URL uvádí komunikační protokol, zvaný schéma. Jazyk podporuje několik schemat, včetně: webové stránky (<tt>HTTP:</tt>), přenos souborů (<tt>FTP:</tt>), zpráv (<tt>NNTP:</tt>), emailu (<tt>MAILTO:</tt>), file (<tt>FILE:</tt>), finger (<tt>FINGER:</tt>), whois (<tt>WHOIS:</tt>), small network time (<tt>DAYTIME:</tt>), post office (<tt>POP:</tt>), transmission control (<tt>TCP:</tt>) a domain name service (<tt>DNS:</tt>). Tyto názvy schemat jsou následovány znaky, jež závisí na použitém schematu.</p>
<pre>http://host.dom/path/file
ftp://host.dom/path/file
nntp://news.some-isp.net/some.news.group
mailto:name@domain
file://host/path/file
finger://user@host.dom
whois://rebol@rs.internic.net
daytime://everest.cclabs.missouri.edu
pop://user:passwd@host.dom/
tcp://host.dom:21
dns://host.dom
</pre>
<p>Některá pole jsou volitelná. Například, hostitel může být následován číslem portu, pokud se liší od implicitního. FTP URL doplňuje heslo, pokud není zadáno:</p>
<pre>ftp://user:password@host.dom/path/file
</pre>
<p>Znaky v URL musí odpovídat internetovým standardům. Vyhrazené znaky musí být uvedeny v hexadecimálním formátu, předznačeném znakem  %:</p>
<pre>probe http://www.somesite.dom/odd%28dir%29/odd%7Bfile%7D.txt
<span class="output">http://www.somesite.dom/odd%28dir%29/odd%7Bfile%7D.txt</span>
print http://www.somesite.dom/odd%28dir%29/odd%7Bfile%7D.txt
<span class="output">http://www.somesite.dom/odd(dir)/odd{file}.txt</span>
</pre>
<h4 id="section-2.13.3">2.13.3 Vytvoření konverzí</h4>
<ii>Chodí poněkud zkomoleně</ii>
<p>Funkce <tt>to-url</tt> konvertuje blok na datový typ <b><tt>url!</tt>, jeho prvním elementem je schema, druhým elementem je doména (s/bez <tt>user:pass</tt> a portem) zbývající elementy jsou cesta a soubor:</p>
<pre>to-url [http www.rebol.com reboldoc.html]
<span class="output">http://www.rebol.com/reboldoc.html</span>
to-url [http www.rebol.com %examples "websend.r"]
<span class="output">http://www.rebol.com/examples/websend.r</span>
to-url [http usr:pass@host.com:80 "(path)" %index.html]
<span class="output">http://usr:pass@host.com:80/%28path%29/index.html</span>
</pre>
<h4 id="section-2.13.4">2.13.4 Souvisí</h4>
<p>Datový typ hodnoty <tt>url!</tt> ověříme funkcí<tt>url?</tt> (případně <tt>series?</tt>).</p>
<pre>url? ftp://ftp.rebol.com/
<span class="output">true</span>
series? http://www.rebol.com/
<span class="output">true</span>
</pre>

<h2 id="section-3">3. Jiné hodnoty</h2>


<h3 id="section-3.1">3.1 Character</h3>

<h4 id="section-3.1.1">3.1.1 Koncept</h4>
<p>Znaky (characters) nejsou řetězce. Jsou to individuální hodnoty, z nichž se řetězce tvoří. Znak může být tisknutelný, netisknutelný a řídící.</p>
<h4 id="section-3.1.2">3.1.2 Formát</h4>
<p>Hodnota typu <tt>char!</tt> se píše jako sekvence znaků:</p>
<pre>#"R"    <ii>; znak: R</ii>
"R"     ; <ii>řetězec se znakem: R</ii>
</pre>
<p>Součástí znaků mohou být únikové sekvence začínající karetem (^) následovaným jedním nebo více znaky kódování. Toto kódování může zahrnovat znaky <tt>#"^A<w>"</w></tt> až <tt>#"^Z<w>"</w></tt> pro <tt>Control</tt> <tt>A</tt> až <tt>Control</tt> <tt>Z</tt> (velká i malá písmena jsou stejná):</p>
<pre>#"^A" #"^Z"
</pre>
<p>Pokud jsou se znakem použity závorky, označují hodnotu. Například nulu lze psát jako:</p>
<pre>"^@"
"^(null)"
"^(00)"
</pre>
<p>Druhý řádek je zapsán v hexadecimálním formátu (base 16).
Thes last line is written in hex format (base 16).</p>
<p>Následuje tabulka řídících znaků, které lze v Redu použít.</p>
<ii>Poněkud nechodí</ii>

<table bgcolor="#505050" border="0" cellpadding="4" cellspacing="1">
        <tbody><tr bgcolor="silver"><th align="left">
<p>Character</p>
</th><th align="left">
<p>Definition</p>

</th></tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(null)" or #"@"</tt></p>
</td><td bgcolor="white" valign="top">
<p>null (zero)</p>

</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(line)", #"/" or, #"."</tt></p>
</td><td bgcolor="white" valign="top">
<p>end of line</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(tab)" or #"-"</tt></p>
</td><td bgcolor="white" valign="top">
<p>horizontal tab</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(page)"</tt></p>
</td><td bgcolor="white" valign="top">
<p>new page (and page eject)</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(esc)"</tt></p>
</td><td bgcolor="white" valign="top">
<p>escape</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(back)"</tt></p>
</td><td bgcolor="white" valign="top">
<p>backspace</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(del)"</tt></p>
</td><td bgcolor="white" valign="top">
<p>delete</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"^"</tt></p>
</td><td bgcolor="white" valign="top">
<p>caret character</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"^""</tt></p>
</td><td bgcolor="white" valign="top">
<p>quotation mark</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>#"(00)" to #"(FF)"</tt></p>
</td><td bgcolor="white" valign="top">
<p>hex forms of characters</p>
</td></tr></tbody></table>
<h4 id="section-3.1.3">3.1.3 Vytvoření konverzí</h4>
<p>Hodnoty typu  <tt>char!</tt> lze vytvořit z jiných datových typů funkcí <b><tt>to-char</tt> function:</p>
<pre>to-char "a"
<span class="output">#"a"</span>
to-char "z"
<span class="output">#"z"</span>
</pre>
<p>Znaky konvenují se standardem ASCII a lze je vytvořít zadáním číselného ekvivalentu:</p>
<pre>to-char 65
<span class="output">#"A"</span>
to-char 52
<span class="output">#"4"</span>
to-char 52.3
<span class="output">#"4"</span>
</pre>
<p>Jiným způsobem získání znaku je jeho vyjmutí z řetězce:</p>
<pre> second "ABC"
<span class="output">#"B"</span>
</pre>
<p>Zatímco znaky v řetězcích nejsou "case" senzitivní, porovnání dvou znaků je:</p>
<pre>"a" = "A"
<span class="output">true</span>
#"a" = #"A"
<span class="output">false</span>
</pre>
<p>V některých typech funkcí není porovnávání citlivé na velikost písmen, pokud není specificky určeno:</p>
<pre>
find "abcde" #"B"
<span class="output">"bcde"</span>
find/case "abcde" #"B"
<span class="output">none</span>
select [#"A" 1] #"a"
<span class="output">none</span>                              <ii>; case sensitive</ii>
select/case [#"A" 1] #"a"
<span class="output">none</span>                               <ii>; přirozeně</ii>
switch #"A" [#"a" [print true]]    <ii>; switch nemá /case</ii>
<span class="output">true</span>
</pre>
<h4 id="section-3.1.4">3.1.4 Souvisí</h4>
<p>K ověření, zda hodnota je typu <tt>char!</tt>, použijeme funkci <tt>char?</tt>.</p>
<pre>char? "a"
<span class="output">false</span>
char? #"a"
<span class="output">true</span>
</pre>
<p>Funkce <tt>form</tt> vytiskne znak bez dvojitého křížku:</p>
<pre>form #"A"
<span class="output">"A"</span>
</pre>
<p>Funkce <tt>mold</tt> vytiskne znak s dvojitým křížkem a dvojitými uvozovkami uvnitř složených závorek:</p>
<pre>mold #"A"
<span class="output">{#"A"}</span>
</pre>

<h3 id="section-3.2">3.2 Date</h3>
<ii>Není dosud zavedeno</ii>
<h4 id="section-3.2.1">3.2.1 Concept</h4>
<p>Around the world, dates are written in a variety of formats. However, most countries use the <tt>day-month-year</tt> format. One of the few exceptions is the United States, which commonly uses a <tt>month-day-year</tt>
 format. For example, a date written numerically as 2/1/1999 is 
ambiguous. The month could be interpreted as either February or January.
 Some countries use a dash (-), some use a forward slash (/), and others
 use a period (.) as a separator. Finally, computer people often prefer 
dates in the 
year-month-day (ISO) format so they can be easily sorted.</p>
<h4 id="section-3.2.2">3.2.2 Format</h4>
<p>The REBOL language is flexible, allowing <tt>date!</tt> 
datatypes to be expressed in a variety of formats. For example, the 
first day of March can be expressed in any of the following formats:</p>
<pre>probe 1/3/1999
<span class="output">1-Mar-1999</span>
probe 1+++1999
<span class="output">1-Mar-1999</span>
probe 1999+++1  ;ISO format
<span class="output">1-Mar-1999</span>
</pre>
<p>The year can span up to 9999 and down to 1. Leap days (February 29) can only be written for leap years:</p>
<pre>probe 29-2-2000
<span class="output">29-Feb-2000</span>
</pre>
<p>The fields of dates can be separated with forward slashes (/) or 
dashes (-). Dates can be written in either a year-month-day format or a 
day-month-year format:</p>
<pre>probe 1999-10-5
<span class="output">5-Oct-1999</span>
probe 1999/10/5
<span class="output">5-Oct-1999</span>
probe 5-10-1999
<span class="output">5-Oct-1999</span>
probe 5/10/1999
<span class="output">5-Oct-1999</span>
</pre>
<p>Because the international date formats that are not widely used in the USA, a month name or month abbreviation can also be used:</p>
<pre>probe 5/Oct/1999
<span class="output">5-Oct-1999</span>
probe 5-October-1999
<span class="output">5-Oct-1999</span>
probe 1999/oct/5
<span class="output">5-Oct-1999</span>
</pre>
<p>When the year is the last field, it can be written as either a four digit or two digit number:</p>
<pre>probe 5/oct/99
<span class="output">5-Oct-1999</span>
probe 5/oct/1999
<span class="output">5-Oct-1999</span>
</pre>
<p>However, it is preferred to write the year in full. Otherwise, 
problems occur with date comparison and sorting operations. While two 
digits can be used to express a year, the interpretation of a two-digit 
year is relative to the current year and is only valid for 50 years in 
the future or in the past:</p>
<pre>probe 28-2-66   ; refers to 1966
<span class="output">28-Feb-1966</span>
probe 12-Mar-20 ; refers to 2020
<span class="output">12-Mar-2020</span>
probe 11+++45   ; refers to 2045, not 1945
<span class="output">11-Mar-2045</span>
</pre>
<p>It is recommended to use a four-digit year to avoid potential problems.</p>
<p>To represent dates in the first century (which is rarely done because
 the Gregorian calendar did not exist), use leading zeros to represent 
the century (as in <tt>9-4-0029</tt>).</p>
<p>Dates can also include an optional time field and an optional time 
zone. The time is separated from the date with a forward slash (/). The 
time zone is appended using a plus (+) or minus (-), and no spaces are 
allowed. Time zones are written as a time shift (plus or minus) from 
GMT. The resolution of the time zone is to the half hour. If the time 
shift is an integer, it is assumed to be hours:</p>
<pre>probe 4/Apr/2000/6:00+8:00
<span class="output">4-Apr-2000/6:00+8:00</span>
probe 1999-10-2/2:00-4:00
<span class="output">2-Oct-1999/2:00-4:00</span>
probe 1/1/1990/12:20:25-6
<span class="output">1-Jan-1990/12:20:25</span>
</pre>
<p>There can be no spaces within the date. For example:</p>
<pre>10 - 5 - 99
</pre>
<p>would be interpreted as a subtraction expression, not a date.</p>
<h4 id="section-3.2.3">3.2.3 Access</h4>
<p>Refinements can be used with a date value to get any of its defined fields:</p>
<table bgcolor="#505050" border="0" cellpadding="4" cellspacing="1">
        <tbody><tr bgcolor="silver"><th align="left">
<p>Refinement</p>
</th><th align="left">
<p>Description</p>

</th></tr><tr><td bgcolor="white" valign="top">
<p><tt>/day</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the day.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/month</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the month.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/year</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the year.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/julian</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the day of the year.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/weekday</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the weekday (1-7/Mon-Sun).</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/time</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the time (if present).</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/hour</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the time's hour (if present)</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/minute</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the time's minute (if present).</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/second</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the time's second (if present).</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/zone</tt></p>
</td><td bgcolor="white" valign="top">
<p>Gets the time zone (if present).</p>
</td></tr></tbody></table>
<p>Here's how these refinements work:</p>
<pre>some-date: 29-Feb-2000
probe some-date/day
<span class="output">29</span>
probe some-date/month
<span class="output">2</span>
probe some-date/year
<span class="output">2000</span>
days: ["Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun"]
probe pick days some-date/weekday
<span class="output">Tue</span>
</pre>
<p>When a time is present, the time related refinements can be used. The <tt>/hour</tt>, <tt>/minute</tt> and <tt>/second</tt> refinements are used with the <tt>/time</tt> refinement that isolates the time segment of the date value for them to work on:</p>
<pre>lost-time: 29-Feb-2000/11:33:22.14-8:00
probe lost-time/time
<span class="output">11:33:22.14</span>
probe lost-time/time/hour
<span class="output">11</span>
probe lost-time/time/minute
<span class="output">33</span>
probe lost-time/time/second
<span class="output">22.14</span>
probe lost-time/zone
<span class="output">-8:00</span>
</pre>
<h4 id="section-3.2.4">3.2.4 Creation</h4>
<p>Use the <tt>to-date</tt> function to convert values to a <tt>date!:</tt></p>
<pre>probe to-date "5-10-1999"
<span class="output">5-Oct-1999</span>
probe to-date "5 10 1999 10:30"
<span class="output">5-Oct-1999/10:30</span>
probe to-date [1999 10 5]
<span class="output">5-Oct-1999</span>
probe to-date [5 10 1999 10:30 -8:00]
<span class="output">5-Oct-1999/10:30-8:00</span>
</pre>
<p>[!Note When converting to a <tt>date!</tt>, the year must be specified as four digits.</p>
<p>Conversions can be applied to various math operations on dates:</p>
<pre>probe 5-Oct-1999 + 1
<span class="output">6-Oct-1999</span>
probe 5-10-1999 - 10
<span class="output">25-Sep-1999</span>
probe 5-Oct-1999/23:00 + 5:00
<span class="output">6-Oct-1999/4:00</span>
</pre>
<h4 id="section-3.2.5">3.2.5 Related</h4>
<p>Use <tt>date?</tt> to determine whether a value is a <tt>date!</tt>  datatype.</p>
<pre>probe date? 5/1/1999
<span class="output">true</span>
</pre>
<p>The related function <tt>to-idate</tt> returns a standard 
Internet date string. The Internet date format is day, date, month, 
year, time (24-hour clock), and time zone offset from GMT.</p>
<pre>probe to-idate now
<span class="output">Fri, 30 Jun 2000 14:42:26 -0700</span>
</pre>
<p>The <tt>now</tt> function returns the current date and time in full format including the time zone offset:</p>
<pre>probe now
<span class="output">30-Jun-2000/14:42:26-7:00</span>
</pre>

<h3 id="section-3.3">3.3 Logic</h3>

<h4 id="section-3.3.1">3.3.1 Koncept</h4>
<p>Datový typ <<tt>logic!</tt> obsahuje hodnoty <tt>true</tt> a <tt>false</tt>. Tyto jsou často vraceny jako odpověď na porovnání:</p>
<pre>age: 100
age = 100
<span class="output">true</span>
time: 10:31:00
time &lt; 10:30
<span class="output">false</span>
str: "this is a string"
probe (length? str) &gt; 10
<span class="output">true</span>
</pre>
<p>Datový typ <tt>logic!</tt> se nejčastěji používá jako parametr u podmínkových funkcí jako <tt>if</tt>, <tt>while</tt> a <tt>until</tt>:</p>
<pre>if age = 100 [print "Centennial human"]
<span class="output">Centennial human</span>
while [time &gt; 6:30] [
    send person "Wake up!"
    wait [0:10]
]
</pre>
<p>Komplementární hodnota logické hodnotě se získá funkcí <tt>not</tt>:</p>
<pre>there: place = "Ukiah" 
if not there [...]
</pre>
<h4 id="section-3.3.2">3.3.2 Formát</h4>
<p>Normálně se logické hodnoty získají z vyhodnocení porovnávacích výrazů. Lze je však přiřadit ke slovům a použít je k jejich aktivaci či deaktivaci:</p>
<pre>print-me: false
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
print-me: true
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
</pre>
<p>Hodnota <tt>false</tt> není ekvivalentní celočíselné nule nebo hodnotě <tt>none</tt>. V podmínkových výrazech však mají <tt>false</tt> a <tt>none</tt> stejný účinek:</p>
<pre>print-me: none
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
</pre>
<p>Téměř každá hodnota, přiřazená ke slovu, má stejný účinek jako <tt>true</tt>:</p>
<pre>print-me: "just a string"
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
print-me: 11-11-1999
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
</pre>
<p>Následující slova mají implicitně přířazeny logické hodnoty true nebo false:</p>
<pre>true: on, yes
false: off, no
</pre>
<p>Takže tam, kde  to má význam, lze místo <tt>true</tt> a <tt>false</tt> použít slova <tt>on</tt> a <tt>off</tt> nebo <tt>yes</tt> a <tt>no</tt>:</p>
<pre>print-me: yes
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
print-me: no
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
print-me: on
print either print-me ["turned on"]["turned off"]
<span class="output">turned on</span>
print-me: off
print either print-me ["turned on"]["turned off"]
<span class="output">turned off</span>
</pre>
<h4 id="section-3.3.3">3.3.3 Vytvoření</h4>
<p>Funkce <tt>to-logic</tt> konvertuje hodnoty typu <tt>integer!</tt> nebo <tt>none!</tt> na datový typ <tt>logic!</tt>:</p>
<pre>to-logic 0
<span class="output">false</span>
to-logic 200
<span class="output">true</span>
to-logic none
<span class="output">false</span>
to-logic []
<span class="output">true</span>
to-logic "a"
<span class="output">true</span>
to-logic none
<span class="output">false</span>
</pre>
<h4 id="section-3.3.4">3.3.4 Souvisí</h4>
<p>Funkci <tt>logic?</tt> použijeme k ověření datového typu <tt>logic!</tt>.</p>
<pre>logic? 1
<span class="output">false</span>
logic? on
<span class="output">true</span>
logic? false
<span class="output">true</span>
</pre>
<p>Funkce <tt>form</tt>, <tt>print</tt>a <tt>mold</tt> použijeme k vytištění logické hodnoty:</p>
<pre>form true
<span class="output">true</span>
mold false
<span class="output">false</span>
print true
<span class="output">true</span>
</pre>

<h3 id="section-3.4">3.4 Money</h3>
<ii>Dosud v Redu nepodporováno</ii>
<h4 id="section-3.4.1">3.4.1 Concept</h4>
<p>There is a wide variety of international symbols for monetary 
denominations. Some symbols are used before the amount and some after. 
As a standard for representing international monetary values, the REBOL 
language uses the United States monetary format, but allows the 
inclusion of specific denominations.</p>
<h4 id="section-3.4.2">3.4.2 Format</h4>
<p>The <tt>money!</tt> datatype uses standard IEEE floating point numbers allowing up to 15 digits of precision including cents.</p>
<p>The language limits the length to 64 characters. Values that are out 
of range or cannot be represented in 64 characters are flagged as an 
error.</p>
<p>Monetary values are prefixed with an optional currency designator, 
followed by a dollar sign ($). A plus (+) or minus (-) can appear 
immediately before the first character (currency designator or dollar 
sign) to indicate sign.</p>
<pre>$123
-$123
$123.45
US$12
US$12.34
-US$12.34
$12,34
-$12,34
DEM$12,34
</pre>
<p>To break long numbers into readable segments, a single quote (`) can 
be placed anywhere between two digits within the amount, but not before 
the amount.</p>
<pre>probe $1'234.56
<span class="output">$1234.56</span>
probe $1'234'567,89
<span class="output">$1234567.89</span>
</pre>
<p>Do not use commas and periods to break up large amounts, as both these characters represent decimal points.</p>
<p><tt>The</tt> money! datatype is a hybrid datatype. 
Conceptually money is scalar--an amount of money. However, because the 
currency designation is stored as a string, the <tt>money!</tt> datatype has two elements:</p>
<ul>
<li><w>string! - The currency designator string, which can have 3 characters maximum.</w></li>
<li><w>decimal! - The money amount.</w></li>
</ul>
<p>To demonstrate this, the following money is specified with the USD prefix:</p>
<pre>my-money: USD$12345.67
</pre>
<p>Here are the two components:</p>
<pre>probe first my-money
<span class="output">USD</span>
probe second my-money
<span class="output">12345.67</span>
probe pick my-money 3       ; only two components
<span class="output">none</span>
</pre>
<p>If no currency designator is used, the currency designator string is empty:</p>
<pre>my-money: $12345.67

probe first my-money
<span class="output">""</span>
probe second my-money
<span class="output">12345.67</span>
</pre>
<p>Various international currencies can be specified in the currency designator, such as:</p>
<pre>my-money: DKM$12'345,67

probe first my-money
<span class="output">DKM</span>
probe second my-money
<span class="output">12345.67</span>
</pre>
<h4 id="section-3.4.3">3.4.3 Creation</h4>
<p>Use the <tt>to-money</tt> function to convert money from a <tt>string!</tt>, <tt>integer!</tt>, <tt>decimal!</tt>, or <tt>block!</tt>.</p>
<pre>probe to-money 123
<span class="output">$123.00</span>
probe to-money "123"
<span class="output">$123.00</span>
probe to-money 12.34
<span class="output">$12.34</span>
probe to-money [DEM 12.34]
<span class="output">DEM$12.34</span>
probe to-money [USA 12 34]
<span class="output">USA$12.34</span>
</pre>
<p>Money can be added, subtracted, and compared with other money of the 
same currency. An error occurs if a different currency is used for such 
operations (automatic conversions are not currently supplied).</p>
<pre>probe $100 + $10
<span class="output">$110.00</span>
probe $100 - $50
<span class="output">$50.00</span>
probe equal? DEM$100.11 DEM$100.11
<span class="output">true</span>
</pre>
<p>Money can be multiplied and divided by integers and decimals. Money 
can also be divided by money, resulting in an integer or decimal.</p>
<pre>probe $100 + 11
<span class="output">$111.00</span>
probe $100 / 4
<span class="output">$25.00</span>
probe $100 * 5
<span class="output">$500.00</span>
probe $100 - 20.50
<span class="output">$79.50</span>
probe 10 + $1.20
<span class="output">$11.20</span>
probe 10 - $0.25
<span class="output">$9.75</span>
probe $10 / .50
<span class="output">$20.00</span>
probe 10 * $0.75
<span class="output">$7.50</span>
</pre>
<h4 id="section-3.4.4">3.4.4 Related</h4>
<p>Use <tt>money?</tt> to determine whether a value is an <tt>money!</tt>  datatype.</p>
<pre>probe money? USD$12.34
<span class="output">true</span>
</pre>
<p>Use the <tt>form</tt>, <tt>print</tt>, and <tt>mold</tt>
 functions with a money argument to print a money value with the 
currency designator and dollar sign ($), as a decimal number with two 
digits of decimal precision.</p>
<pre>probe form USD$12.34
<span class="output">USD$12.34</span>
probe mold USD$12.34
<span class="output">USD$12.34</span>
print USD$12.34
<span class="output">USD$12.34</span>
</pre>

<h3 id="section-3.5">3.5 None</h3>

<h4 id="section-3.5.1">3.5.1 Koncept</h4>
<p>Datový typ <tt>none!</tt> obsahuje jedinou hodnotu <tt>none</tt>, která reprezentuje nepřítomnost hodnoty.</p>
<p>Koncept hodnoty <tt>none</tt> se liší od prázdného bloku či řetězce nebo znaku nuly. Je to skutečná hodnota která reprezentuje neexistenci.</p>
<p>Hodnota <tt>none!</tt> může být vrácena různými funkcemi, primárně těmi, které se týkají řad (například <tt>pick</tt>, <tt>find</tt> a <tt>select</tt>).</p>
<p>V databázích může být <tt>none</tt> držitelem místa pro chybějící hodnoty:</p>
<pre>email-database: [
    "Bobby" bob@rebol.com 40
    "Linda" none 23
    "Sara"  sara@rebol.net 33
]
</pre>

<h4 id="section-3.5.2">3.5.2 Formát</h4>
<p>I když <tt>none</tt> není ekvivalentní <tt>nule</tt> či slovu <tt>false</tt>, je platné uvnitř podmínkových výrazů a má stejný účinek jako <tt>false:</tt></p>
<pre>probe find "abcd" "e"
<span class="output">== none</span>
if find "abcd" "e" [print "found"]
<span class="output">== none</span>
</pre>
<h4 id="section-3.5.3">3.5.3 Souvisí</h4>
<p>Funkce <tt>to-none</tt> vždy vrací <tt>none</tt>.</p>
<pre>to-none "abcd"
<span class="output">== none</span>
</pre>
<p>Funkcí <tt>none?</tt> ověříme typ hodnoty.</p>
<pre>none? 1
<span class="output">false</span>
none? find [1 2 3] 4
<span class="output">true</span>
</pre>
<p>Funkce <tt>form</tt>, <tt>print</tt> a <tt>mold</tt> vytisknou hodnotu <tt>none</tt>, je-li jim zadán argument <tt>none</tt> argument.</p>
<pre>form none
<span class="output">none</span>
mold none
<span class="output">none</span>
print none
<span class="output">none</span>
</pre>

<h3 id="section-3.6">3.6 Pair</h3>

<h4 id="section-3.6.1">3.6.1 Koncept</h4>
<p>Datový typ pair! (pár) se používá pro vyjádření dvojice čísel, které vyjadřují rozměr nebo souřadnice bodu v rovině. Tento typ se používá hlavně v proceduře Red/View.</p>
<h4 id="section-3.6.2">3.6.2 Format</h4>
<p>Pár tvoří dvojice celých čísel se znakem <tt>x</tt>.</p>
<pre>100x50

1024x800

-50x200
</pre>
<h4 id="section-3.6.3">3.6.3 Vytvoření</h4>
<p>Funkce <tt>to-pair</tt> konvertuje blok nebo řetězec na datový typ <tt>pair!</tt>:</p>
<pre>p: to-pair "640x480" 
probe p
<span class="output">640x480</span>
p: to-pair [800 600] 
probe p
<span class="output">800x600</span>
</pre>
<h4 id="section-3.6.4">3.6.4 Souvisí</h4>
<p>Ke zjištění zda hodnota je typu <tt>pair!</tt> použijeme funkci <tt>pair?</tt>:</p>
<pre>probe pair? 400x200
<span class="output">true</span>
probe pair? pair
<span class="output">true</span>
</pre>
<p>Páry lze použít s většinou aritmetických operátorů:</p>
<pre>100x200 + 10x20

10x20 * 2x4

100x30 / 10x3

100x100 * 3

10x10 + 3
</pre>
<p>Páry lze prohlížet jednotlivě po členech:</p>
<pre>pair: 640x480
probe first pair
<span class="output">640</span>
probe second pair
<span class="output">480</span>
</pre>
<p>Všechny páry také podporují upřesnění <tt>/x</tt> a <tt>/y</tt> pro přístup k jednotlivým prvkům páru.</p>
<p>Za účelem jejich zobrazení:</p>
<pre>probe pair/x
<span class="output">640</span>
probe pair/y
<span class="output">480</span>
</pre>
<p>Za účelem jejic změny:</p>
<pre>pair/x: 800
pair/y: 600
probe pair
<span class="output">800x600</span>
</pre>

<h3 id="section-3.7">3.7 Refinement</h3>

<h4 id="section-3.7.1">3.7.1 Koncept</h4>
<p>Upřesnění (refinement) je modifikátor, podobný přídavným jménům přirozené lidské řeči. Upřesnění indikuje variaci v použití nebo rozšíření významu funkce, objektu, jména souboru, URL nebo cesty. </p>
<p>Upřesnění se používají u funkcí:</p>
<pre>block: [1 2]
append/only block (3 4)
<span class="output">== [1 2 3 4]</span>
</pre>
<p>jako atributy objektů:</p>
<pre>print system/version
<span class="output">0.6.1</span>
</pre>
<p>u souborů zobrazují cestu:</p>
<pre>dir: %docs/core
print read dir/file.txt
</pre>
<p>podobně jako  u url:</p>
<pre>site: http://www.rebol.com
print read site/index.html
</pre>
<h4 id="section-3.7.2">3.7.2 Formát</h4>
<p>Upřesnění se skládá z lomítka a platného slova Redu. Příklady:</p>
<pre>/only
/test1
/save-it
</pre>
<p>Upřesnění se obvykle připojují k  jiným slovům, jako v případě (který nechodí):</p>
<pre>port: open/binary file  <ii>; Red zatím nezná slovo 'open'</ii>
</pre>
<p> <ii>Zatím nechodí:</ii> Lze je však také psát samostatně, jako při určování upřesnění pro funkci:</p>
<pre>save-data: function [file data /limit /reload] ...
</pre>
<h4 id="section-3.7.3">3.7.3 Vytvoření</h4>
<p>Upřesnění lze vytvořit zápisem ve zdrojovém kódu:</p>
<pre>/test
</pre>
<p>nebo jej lze vytvořit funkcí <tt>to-refinement</tt>:</p>
<pre>to-refinement "test"
<span class="output">/test</span>
</pre>
<h4 id="section-3.7.4">3.7.4 Souvisí</h4>
<p>K otestování datového typu <tt>refinement!</tt> použijeme funkci <tt>refinement?</tt>:</p>
<pre>refinement? /test
<span class="output">true</span>
refinement? 'word
<span class="output">false</span>
</pre>

<h3 id="section-3.8">3.8 Time</h3>

<h4 id="section-3.8.1">3.8.1 Koncept</h4>
<p>Jazyk Red podporuje standardní vyjádření času v hodinách, minutách, vteřinách a subvteřinách. U hodin se používá 24 hodinový cyklus. Jsou povoleny kladné i záporné hodnoty.</p>
<h4 id="section-3.8.2">3.8.2 Formát</h4>
<p>Datový typ <tt>time!</tt> vyžaduje uvedení hodin a minut, vteřiny nejsou povinné:</p>
<pre>10:30
0:00
18:59
23:59:50
8:6:20
8:6:2
</pre>
<p>Pole pro minuty a vteřiny mohou obsahovat celá čísla větší než 60. Čísla větší než 60 jsou automaticky konvertována. Například  <tt>0:120:00</tt> je totéž jako <tt>2:00</tt>.</p>
<pre>probe 0:87363.21
<span class="output">24:16:03.21</span>
</pre>
<p>Části vteřin jsou určeny jako desetinná část v poli pro vteřiny. Při přítomnosti desetinné části (oddělené tečkou nebo čárkou) je uvedení hodin nepovinné. Část vteřiny menší než milióntina vteřiny je zaokrouhlena na nulu:</p>
<pre>probe 32:59:29.5
<span class="output">32:59:29.5</span>
probe 1:10,25
<span class="output">0:01:10.25</span>
probe 0:0.000000001
<span class="output">0:00:00</span>
probe 0:325.2
<span class="output">0:05:25.2</span>
</pre>
<p><ii>V Redu nechodí:</ii> Časový údaj může být doplněn <tt>AM</tt> or <tt>PM</tt> bez mezilehlé mezery. Přípona<tt>PM</tt> přídává 12 hodin k zadanému údaji:</p>
<pre>probe 10:20PM
<span class="output">22:20</span>
probe 3:32:20AM
<span class="output">3:32:20</span>
</pre>
<h4 id="section-3.8.3">3.8.3 Přístup</h4>
<p>Časové hodnoty mají tři upřesnění (refinements) pro vyjádření specifického údaje:</p>
<table bgcolor="#505050" border="0" cellpadding="4" cellspacing="1">
        <tbody><tr bgcolor="silver"><th align="left">
<p>Refinement</p>
</th><th align="left">
<p>Description</p>

</th></tr><tr><td bgcolor="white" valign="top">
<p><tt>/hour</tt></p>
</td><td bgcolor="white" valign="top">
<p>Vrátí počet hodin zadané hodnoty.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/minute</tt></p>
</td><td bgcolor="white" valign="top">
<p>Vrátí počet minut zadané hodnoty.</p>
</td>
</tr><tr><td bgcolor="white" valign="top">
<p><tt>/second</tt></p>
</td><td bgcolor="white" valign="top">
<p>Vrátí počet vteřin zadané hodnoty.</p>
</td></tr></tbody></table>
<p>Nástroj refinement (upřesnění) použijeme takto:</p>
<pre>lapsed-time: 91:32:12.14
probe lapsed-time/hour
<span class="output">91</span>
probe lapsed-time/minute
<span class="output">32</span>
probe lapsed-time/second
<span class="output">12.14</span>
</pre>
<p><ii>V Redu nechodí:</ii> Times with time zones can only be used with the <tt>date!</tt>.</p>
<h4 id="section-3.8.4">3.8.4 Vytvoření</h4>
<p>Číselný údaj lze konvertovat na datový typ <tt>time!</tt> funkcí <tt>to-time</tt>:</p>
<pre>to-time "10:30"
<span class="output">10:30</span>
to-time [10 30]
<span class="output">10:30</span>
to-time [0 10 30]
<span class="output">0:10:30</span>
to-time [10 30 20.5]
<span class="output">10:30:20.5</span>
</pre>
<p>Hodnoty v předchozích ukázkách nejsou vyhodnocovány. Vyhodnocení hodnot coby matematických výrazů zařídí funkce <tt>reduce</tt>:</p>
<pre>to-time reduce [10 30 + 5]
<span class="output">10:35</span>
</pre>
<p>V různých matematických operacích s časem dochází k následujícím konverzím:</p>
<pre>probe 10:30 + 1
<span class="output">10:30:01</span>
probe 10:00 - 10
<span class="output">9:59:50</span>
probe 0:00 - 10
<span class="output">-0:00:10</span>
probe 5:10 * 3
<span class="output">15:30</span>
probe 0:0:0.000000001 * 1'500'600
<span class="output">0:00:00.0015006</span>
probe 8:40:20 / 4
<span class="output">2:10:05</span>
probe 8:40:20 / 2:20:05
<span class="output">3</span>
probe 8:40:20 // 4:20
<span class="output">0:00:20</span>
</pre>
<h4 id="section-3.8.5">3.8.5 Souvisí</h4>
<p>K ověření datového typu <tt>time!</tt> použijeme funkci <tt>time?</tt>:</p>
<pre>time? 10:30
<span class="output">true</span>
time? 10.30
<span class="output">false</span>
</pre>
<p>Upřesnění <tt>/time</tt> k funkci <tt>now</tt> vrací aktuální čas:</p>
<pre>now/time
<span class="output">14:42:15</span>
</pre>
<p>Use the <tt>wait</tt> function to wait for a duration, port, or both.</p>
<ii>Ověřený argument funkce wait je typu integer (počet vteřin).</ii> 
<p>If a value is a <tt>time!</tt> datatype, <tt>wait</tt> delays for that period of time. If a value is a <tt>date!/time!</tt>, <tt>wait</tt> waits until the indicated date and time. If the value is an <tt>integer!</tt> or <tt>decimal!</tt>, the function waits the indicated number of seconds. If the value is a <tt>port</tt>,
 the function will wait for an event from that port. If a block is 
specified, it will wait for any of the times or ports to occur. It 
returns the port that caused the wait to complete or returns <tt>none</tt> if the timeout occurred. For example,</p>
<pre>probe now/time
<span class="output">14:42:16</span>
wait 0:00:10      <ii>V Redu nechodí:</ii>
probe now/time
<span class="output">14:42:26</span>
</pre>

<h3 id="section-3.9">3.9 Tuple - entice</h3>

<h4 id="section-3.9.1">3.9.1 Koncept</h4>
<p>Čísla verzí, internetové adresy a RGB hodnoty barev se obvykle prezentují jako skupiny tří nebo čtyř celých čísel.
Takováto skupina tvoří v Redu datový typ zvaný <tt>tuple!</tt> (entice - podobně jako trojice, šestice)
a zapisuje se jako sada celých čísel, oddělených tečkami.</p>
<pre>1.3.0 2.1.120 1.0.2.32     ; versions
199.4.80.250 255.255.255.0 ; net addresses/masks
0.80.255 200.200.60        ; RGB colors
</pre>
<h4 id="section-3.9.2">3.9.2 Formát</h4>
<p>Každé celočíselné pole datového typu <tt>tuple!</tt> může obsahovat hodnotu od 0 do 255. Negativní čísla produkují chybu.</p>
<p>Entice se může skládat ze dvou až z deseti celých čísel. Jsou-li dána jen dvě čísla, musí být doplněna dvěma tečkami aby nebyl zápis považován za desetinné číslo.</p>
<pre>probe 1.2     ; is decimal
<span class="output">1.2</span>
probe type? 1.2
<span class="output">decimal!</span>
probe 1.2.3   ; is tuple
<span class="output">1.2.3</span>
probe 1.2.    ; is tuple
<span class="output">1.2.0</span>
probe type? 1.2.
<span class="output">tuple!</span>
</pre>
<h4 id="section-3.9.3">3.9.3 Vytvoření</h4>
<p>Funkci <tt>to-tuple</tt> použijeme ke konverzi dat na datový typ <tt>tuple!</tt></p>
<pre>probe to-tuple "12.34.56"
<span class="output">12.34.56</span>
probe to-tuple [12 34 56]
<span class="output">12.34.56</span>
</pre>
<h4 id="section-3.9.4">3.9.4 Souvisí</h4>
<p>K ověření datového typu použijeme funkci <tt>tuple?</tt>.</p>
<pre>probe tuple? 1.2.3.4
<span class="output">true</span>
</pre>
<p>K transformaci entice na řetězec použijeme funkci <tt>form</tt>:</p>
<pre>probe form 1.2.3.4
<span class="output">1.2.3.4</span>
</pre>
<p>K transformaci entice na řetězec, který může být načten zpět jako entice poslouží funkce <tt>mold</tt>:</p>
<pre>probe mold 1.2.3.4
<span class="output">1.2.3.4</span>
</pre>
<p>Funkce <tt>print</tt> vytiskne entici v konzole:</p>
<pre>print 1.2.3.4
<span class="output">1.2.3.4</span>
</pre>

<h3 id="section-3.10">3.10 Slova - words</h3>

<h4 id="section-3.10.1">3.10.1 Koncept</h4>
<p>Slova jsou klíčovým pojmem v jazyce Red. Mohou být označením <tt>proměnných</tt>, které ukazují na hodnoty či funkce nebo mohou být jenom prostými <tt>symboly</tt>. </p>
<p>Red nemá žádná restriktivně vymezená klíčová slova. Lze například definovat vlastní funkci s názvem <tt>print</tt> a používat ji místo nativní funkce, rovněž zvané 'print'. Názvy nativních (předdefinovaných) entit tvoří skupinu tak zvaných "předdefinovaných" slov.</p>
<p>V závislosti na požadované operaci se používají čtyři různé fomáty slov:</p>
<table bgcolor="#505050" border="0" cellpadding="4" cellspacing="1">
<tbody>
<tr bgcolor="silver">
<th align="left">
<p>Akce</p></th>
<th align="left">
<p>Název typu</p></th>
<th align="left">
<p>Test typu</p></th>
<th align="left">
<p>Konverze</p></th>
<th align="left">
<p>Použití</p></th>
</tr>
<tr>
<td bgcolor="white" valign="top">
<p><tt>word:</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>set-word!</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>set-word?</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>to-set-word</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>deklarace proměnné</tt></p></td>
</tr>
<tr>
<td bgcolor="white" valign="top">
<p><tt>:word</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>get-word!</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>get-word?</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>to-get-word</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>odkaz na jméno</tt></p></td>
</tr><tr>
<td bgcolor="white" valign="top">
<p><tt>word</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>word!</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>word?</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>to-word</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>odkaz na hodnotu</tt></p></td>
</tr><tr>
<td bgcolor="white" valign="top">
<p><tt>'word</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>lit-word!</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>lit-word?</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>to-lit-word</tt></p></td>
<td bgcolor="white" valign="top">
<p><tt>odkaz na slovo jako symbol</tt></p></td>
</tr></tbody></table>
<h4 id="section-3.10.2">3.10.2 Složení slov</h4>
<p>Slova jsou složena z písmen abecedy, čísel a z následujících znaků:</p>
<pre>? ! . ' + - * &amp; | = _ &amp;#126;
</pre>
<p>Konec slova je vyznačen mezerou, novým řádkem nebo některým z následujících znaků:</p>
<pre>[ ] ( ) { } " : ; /
</pre>
<p>Hranaté závorky bloku nejsou součástí slova:</p>
<pre>[test]
</pre>
<p>Slova nemohou začínat čislem a nemohou obsahovat tyto znaky:</p>
<pre>@ # $ % ^ ,
</pre>
<p>Slova nemohou být delší než délka řádku.</p>
<pre>this-is-a-very-long-word-used-as-an-example
</pre>
<p>Příklady slov:</p>
<pre>Copy print test

number?  time?  date!

image-files  l'image

++ -- == +-

***** *new-line*

left&amp;right left|right
</pre>
<p>Red není "case-sensitive".  Zápisy:</p>
<pre>blue

Blue

BLUE
</pre>
<p>odkazují na jedno a totéž slovo. Velikost písmen se zachovává při tisku do konzoly.</p>

<h4 id="section-3.10.3">3.10.3 Vytvoření konverzí</h4>

<p>Funkce <tt>to-word</tt> konvertuje hodnotu na datový typ <tt>word!</tt>.</p>
<pre>to-word "test"
<span class="output">test</span>
</pre>
<p>Funkce <tt>to-set-word</tt> konvertuje hodnotu na datový typ <tt>set-word!</tt>.</p>
<pre>to-set-word! "test"
<span class="output">test:</span>
</pre>
<p>Funkce <tt>to-get-word</tt> konvertuje hodnotu na datový typ <tt>get-word!</tt>.</p>
<pre>to-get-word "test"
<span class="output">:test</span>
</pre>
<p>Funkce <tt>to-lit-word</tt> konvertuje hodnotu na datový typ <tt>lit-word!</tt>.</p>
<pre>to-lit-word "test"
<span class="output">'test</span>
</pre>
<h4 id="section-3.10.4">3.10.4 Kontext určuje význam</h4>
<p>Význam slova je závislý na kontextu, ve kterém se nachází.</p>
<pre>sizes: [large medium small]
print sizes
<span class="output">*** Script Error: large has no value</span>
</pre>
<p>Slova large, medium, small jsou uvnitř bloku netečnými symboly, které se implicitně nevyhodnocují.</p>
<p>Pokud slova vybavíme hodnotami, stanou se z nich proměnné: </p>
<pre>large:  1000
medium: 100
small:  10
print sizes
<span class="output">1000 100 10</span>
</pre>
<h4 id="section-3.10.5">3.10.5 Souvisí</h4>
<p>K otestování datového typu použijeme funkce <tt>word?</tt>, <tt>set-word?</tt>, <tt>get-word?</tt> a <tt>lit-word?</tt> :</p>
<pre>probe word? second [1 two "3"]
<span class="output">true</span>
if set-word? first [word: 10] [print "it is set"]
<span class="output">it is set</span>
probe get-word? second [pr: :print]
<span class="output">true</span>
probe lit-word? first ['foo bar]
<span class="output">true</span>
</pre>

</td></tr>
</tbody></table>
</center>


</body></html>
>>>>>>> 2cf344877782b2dc9eacb2f3a29a1297affb2c8a
